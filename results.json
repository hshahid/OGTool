{
  "team_id": "aline123",
  "items": [
    {
      "title": "Nil's Blog",
      "content": "Teaching DS&A · research highlights · SWE thoughts · building in public\n\nStay in the loop\n\nI'd love to tell you when I publish a new post.\n\nGet notified when I write about DS&A or software engineering. Unsubscribe anytime if it's not your vibe.\n\nIn Defense of Coding Interviews\n\nA collection of arguments in favor of coding interviews.\n\nGet Binary Search Right Every Time, Explained Without Code\n\nA binary search recipe that works for every problem, explained without code.\n\nProblem Solving BCtCI Style\n\nA problem walkthrough using the concepts from Beyond Cracking the Coding Interview.\n\nHeapify Analysis Without Math\n\nA proof that heapify takes linear time without using complex equations.\n\nLazy vs Eager Algorithms\n\nExploring the tradeoffs between lazy and eager implementations of common algorithms.\n\nActually Implementing Dijkstra's Algorithm\n\nA comprehensive guide to different implementations of Dijkstra's algorithm, with code.\n\nReachability Problems and DFS\n\nAn extensive list of questions that can be solved with DFS.\n\nBreaking Down Dynamic Programming\n\nA step-by-step guide to understanding and implementing dynamic programming algorithms with practical examples.\n\nIterative Tree Traversals: A Practical Guide\n\nA guide to implementing preorder, inorder, and postorder tree traversals iteratively.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/category/dsa",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Reachability Problems and DFS",
      "content": "Reachability Problems and DFS\n\nIntroduction\n\nDepth-first search, or DFS, is a fundamental graph algorithm that can be used to solve reachability problems. This post shows how to adapt the basic DFS template to solve several problems of this kind. Reachability problems are often easier in undirected graphs. Below, we specify if the algorithm works for undirected graphs, directed graphs, or both.\n\nPrerequisites\n\nWe assume that the reader is already familiar with the concept of DFS. Here is an excellent video introducing DFS with step-by-step animations. We also assume that the reader is familiar with the adjacency list representation of a graph, and we use big-O notation in the analysis.\n\nCoding conventions\n\nThe algorithms below are in Python. n denotes the number of nodes. Nodes are identified with integers in the range 0..n-1. The graph G is a graph stored as an adjacency list: G is a list of n lists. For each v between 0 and n-1, G[v] is the list of neighbors of G.\n\nIf the graph is given as an edge list instead, we can initialize it as follows:\n\nIf the graph is given as an adjacency matrix, we can iterate through the rows of the adjacency matrix instead of through the adjacency lists. To iterate through the neighbors of a node v, instead of\n\nNote that using an adjacency matrix affects the runtime analysis of DFS: O(n²) instead of O(m).\n\nWhich nodes can be reached from node s?\n\nThis is the simplest question that can be answered with DFS. The primary data structure in DFS is a list of booleans to keep track of already visited nodes (we call it vis). If we start a DFS search from a node s, the reachable nodes will be the ones for which vis is true.\n\nFor this, G can be directed or undirected. We make use of a nested function in Python so that we do not need to pass G and vis as parameters (in Python nested functions have visibility over the variables in the scope where they are defined).\n\nDFS runs in O(m) time and O(n) space, where m is the number of edges. This is because each edge is considered twice, once from each endpoint, if the endpoints end up being visited, or zero times if the endpoints are not visited.\n\nIterative version\n\nThe iterative version takes O(m) space instead of O(n) because nodes can be inserted into the stack multiple times (up to one time for each incident edge). Alternatively, we can mark the nodes as visited when we add them to the stack instead of when we remove them. This change reduces the space usage to the usual O(n). However, with this change, the algorithm is no longer DFS. It still works for answering reachability questions because the set visited nodes is the same, but the order in which they are visited is no longer consistent with a depth-first search order (it is closer to a BFS (breath-first search) order, but also not exactly a BFS order).\n\nThe difference between marking nodes when they added vs removed from the stack is discussed in detail here. Since the recursive version is shorter and optimal in terms of space, we favor it from now on. That said, it should be easy to adapt the iterative version above to the problems below.\n\nCan node s reach node t?\n\nWe use the same code from before, but we add early termination as soon as we see t. Now, the recursive function has a return value.\n\nAdding the early termination can make the DFS faster, but in the worst-case the time/space complexity is the same.\n\nPractice problems\n\nhttps://leetcode.com/problems/the-maze/\n\nThe hardest part on this problem is constructing the graph in the first place.\n\nFind a path from s to t\n\nThe edges \"traversed\" in a DFS search form a tree called the \"DFS tree\". The DFS tree changes depending on where we start the search. The starting node is called the root. We can construct the DFS tree by keeping track of the predecessor of each node in the search (the root has no predecessor). If we construct the DFS tree rooted at s, we can follow the sequence of predecessors from t to s to find a path from s to t in reverse order.\n\nInstead of using the list vis to keep track of visited nodes, we know a node is unvisited if it has no predecessor yet. We indicate that a node has no predecessor with the special value -1.\n\nNote that DFS does not find the shortest path form s to t. For that, we can use BFS (breath-first search). It just returns any path without repeated nodes.\n\nIs the graph connected?\n\nFor undirected graphs, this is almost the same question as the first question (\"which nodes can be reached by s?\") because of the following property:\n\nAn undirected graph is connected if and only if every node can be reached from s, where s is any of the nodes.\n\nThus, the code is exactly the same as for the first question, with two differences: 1) we choose s to be 0 (could be anything), and 2) we change the last line to check if every entry in vis is true.\n\nFor directed graphs, we need to take into account the direction of the edges. A directed graph is strongly connected if every node can reach every other node. We can use the following property:\n\nA directed graph is strongly connected if and only if s can reach every node and every node can reach s, where s is any of the nodes.\n\nWe already know how to use DFS to check if s can reach every node. To check if every node can reach s, we can do a DFS starting from s, but in the reverse graph of G. The reverse graph of G is like G but reversing the directions of all the edges.\n\nThe runtime is still O(m), but the space is now O(m) because we need to create and store the reverse graph. There are alternative algorithms (like Tarjan's algorithm) which can do this in O(n) space.\n\nHow many connected components are there?\n\nWe can use the typical DFS to answer this question for undirected graphs. We use a common pattern in DFS algorithms: an outer loop through all the nodes where we launch a search for every yet-unvisited node.\n\nThe runtime is now O(n+m) because, if m < n, we still spend O(n) time iterating through the loop at the end.\n\nFor directed graphs, instead of connected components, we talk about strongly connected components. A strongly connected component is a maximal subset of nodes where every node can reach every other node.\n\nIf we want to find the number of strongly connected components, we can use something like Tarjan's algorithm, a DFS-based algorithm that requires some additional data structures.\n\nPractice problems\n\nhttps://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/ (Premium only)\n\nhttps://leetcode.com/problems/number-of-islands/\n\nhttps://leetcode.com/problems/friend-circles/\n\nWhich nodes are in the same connected components?\n\nThis question is more general than the previous two. We label each node v with a number CC[v] so that nodes with the same number belong to the same CC. Instead of having a list CC in addition to vis, we use the CC number -1 to indicate unvisited nodes. This way, we do not need vis\n\nFor directed graphs, again we need Tarjan's algorithm or an equivalent algorithm.\n\nPractice problems\n\nhttps://leetcode.com/problems/max-area-of-island/\n\nhttps://leetcode.com/problems/sentence-similarity-ii/\n\nIn the second problem, nodes are given by names, not indices, so they need to be converted.\n\nIs the graph acyclic?\n\nFor undirected graphs, this question is simple. First, we consider the problem in each CC independently. This is very common pattern in graph problems. We do this with an outer loop through all the nodes where we launch a search for every yet-unvisited node.\n\nDuring the DFS search in each CC, if we find an edge to an already visited node that is not the predecessor in the search (the node we just came from), there is a cycle. Such edges in a DFS search are called back edges. We add one parameter to the recursive function visit to know the predecessor node.\n\nFor directed graphs, it is not as simple: the fact that a neighbor nbr is already visited during the DFS search does not mean that nbr can reach the current node. To check if a directed graph is acyclic, we can use the linear-time peel-off algorithm for finding a topological ordering. This algorithm detects if the graph is acyclic and finds a topological ordering if so, though we are only interested in the first part.\n\nPractice problems\n\nhttps://leetcode.com/problems/redundant-connection/\n\nThis problem is easier to solve using union-find, but it can be done with DFS.\n\nIs the graph a tree?\n\nUsually, we ask this question for undirected graphs. We can use this characterization of trees:\n\nAn undirected graph is a tree if and only if it is connected and has exactly n-1 edges.\n\nWe already saw how to check if the graph is connected with DFS, and counting the number of edges is straightforward:\n\nPractice problems\n\nhttps://leetcode.com/problems/graph-valid-tree/\n\nIs the graph bipartite?\n\nThis is exactly the same question as whether the graph can be two-colored, so see the next section.\n\nCan the graph be two-colored?\n\nTwo-coloring a graph means assigning colors to the nodes such that no two adjacent nodes have the same color, using only two colors. Usually, we consider coloring question for undirected graphs.\n\nWe consider whether each CC can be colored independently from the others. We can color each CC using DFS. We use values 0 and 1 for the colors. The color of the start node can be anything, so we set it to 0. For the remaining nodes, the color has to be different from the parent, so we only have one option.\n\nInstead of having a vis array, we use the special color -1 to denote unvisited nodes.\n\nWith 3 or more colors, the problem becomes a lot harder.\n\nPractice problems\n\nhttps://leetcode.com/problems/is-graph-bipartite/\n\nWhat is the distance from a node s to every other node in a tree?\n\nWe cannot use DFS to find the distance between nodes in a graph which can have cycles, because DFS is not guaranteed to follow the shortest path from the root to the other nodes. For that, BFS is more suitable (if the graph is unweighted). However, since trees are acyclic, there is a unique path between any two nodes, so DFS must use the unique path, which, by necessity, is the shortest path. Thus, we can use DFS to find distances in a tree.\n\nPractice problems\n\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/\n\nFind a spanning tree\n\nA spanning tree of a connected, undirected graph G is a subgraph which has the same nodes as G that is a tree. The edges traversed by a DFS search on a connected graph form a spanning tree (sometimes called a DFS tree). Thus, we do DFS and add the traversed edges to the resulting tree.\n\nConclusions\n\nDFS has many uses. We showed how to make minor modifications to the DFS template to answer reachability and connectivity questions.\n\nAfter DFS, the next algorithm to learn would be BFS (breath-first search). Like DFS, it can answer reachability questions. On top of that, it can also answer questions about distance in undirected graphs.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/reachability-problems-and-dfs?category=dsa",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Lazy vs Eager Algorithms",
      "content": "Lazy vs Eager Algorithms\n\nWarning: I have not tested any code snippet below. Please let me know if you find a bug.\n\nIntroduction\n\nMost algorithms have multiple valid implementations. For instance, in a binay tree problem, you have multiple ways of handling NULL nodes. I'm currently writing Beyond Cracking the Coding Interview (beyondctci.com), which means that my co-authors and I need to take a stance on what version of each algorithm to use. Ideally, we want to show the simplest version of each algorithm:\n\nEasy to recall for interview,\n\nEasy to explain to interviewers,\n\nEasy to debug by hand,\n\nShort, so that it is quick to code.\n\nIn the book, we don't claim that the version we show is \"the best\" - we say to use the one that works best for you. But showing one in the book is an implicit endorsement.\n\nOne particular decision that comes up again and again with recursive algorithms is choosing between the lazy version and the eager version of an algorithm.\n\nAn eager recursive function expects 'valid' inputs and ensures to only call the recursive function with 'valid' inputs. We can also call it a clean (call) stack algorithm.\n\nA lazy recursive algorithm allows 'invalid' inputs, so it starts by validating the input. Then, it calls the recursive function without validating the inputs passed to it. We can also call it a dirty stack algorithm.\n\nWhat 'valid' means depends on the algorithm--we'll see plenty of examples. We'll also translate the concept of eager vs lazy to iterative algorithms.\n\nLazy vs Eager Tree Traversals\n\nAn eager tree traversal eagerly validates that the children are not NULL before passing them to the recursive function. A lazy tree traversal doesn't, so it needs to check if the current node is NULL before accessing it.\n\nFor instance, here is eager vs lazy preorder traversal:\n\nBoth have the same runtime and space analysis. Even the constant factors probably don't change much, so it comes down to style preference. Which one do you prefer?\n\nLazy vs Eager graph DFS\n\nAn eager graph DFS eagerly checks that the neighbors are not already visited before passing them to the recursive function. A lazy graph DFS doesn't, so it needs to check if the current node is already visited.\n\nFor a graph DFS, we can also do a mix between lazy and eager: we can eagerly check if nodes are already visited, and lazily mark them as visited:\n\nAgain, they all have the same analysis. Which one do you prefer?\n\nLazy vs Eager grid algorithms\n\nConsider the same DFS algorithm but on a grid of 0's and 1's. The 0's are walkable cells, the 1's are obstacles, and walkable cells next to each other are connected. This time, we need to check that the neighbors are not out of bounds, which we can do lazily or greedily.\n\nLazy vs Eager Memoization DP\n\nIn a lazy memoization DP (Dynamic Programming) algorithm, we call the recursive function for a subproblem without checking first if we have already computed that subproblem. In an eager algorithm, we only call the recursive function for subproblems that we still need to compute.\n\nFor memoization DP, I think lazy is cleaner and more conventional.\n\nLazy vs Eager Iterative Tree traversals\n\nConsider a level-order traversal on a binary tree. A level-order traversal is an iterative algorithm that uses a queue data structure.\n\nA lazy version puts children in the queue without checking if they are NULL first. We can call it a dirty queue algorithm.\n\nAn eager version checks for NULL nodes and avoids putting them in the queue. We can call it a clean queue algorithm.\n\nEager Graph BFS is better than lazy Graph BFS\n\nThis is the first exception where one is better than the other in terms of big O analysis. The lazy BFS allows adding already-visited nodes to the queue, while the eager one does not. We'll first look at the two versions, and then analyze them.\n\nIt may come as a surprise that these two are not equivalent like all the other examples.\n\nLet's say V is the number of nodes and E is the number of edges. To keep things simple, consider that the graph is connected, meaning that E is at least V-1 and at most O(V²).\n\nBoth versions take O(E) time. The difference is in the space complexity: the eager version takes O(V) space because we never have the same node twice in the queue. The lazy version takes O(E) space because we allow the same nodes multiple times in the queue.\n\nTo see this, consider a complete graph:\n\nWhen we visit start, we add A, B, C, D, E to the queue. Now the queue is: [A, B, C, D, E]\n\nWhen we visit A, we add start, B, C, D, E to the queue. Now the queue is: [B, C, D, E, start, B, C, D, E]\n\nWhen we visit B, we add start, A, C, D, E to the queue. Now the queue is: [C, D, E, start, B, C, D, E, start, A, C, D, E]\n\nBy the time we finish popping the nodes added as neighbors of the start node, we've done V queue pops and V² queue appends, so the queue size is O(V²).\n\nSo, why didn't this happen for other lazy algorithms we have seen?\n\nFor tree traversals, each tree node has a single parent that it can be reached from, so we don't need to worry about the same node appearing twice in the call stack or in the level-order traversal queue.\n\nFor graph DFS, every node in the call stack is marked visited, so if we call visit() on a node that is already in the call stack, we'll immediately return as we'll see it is marked as visited.\n\nEager Dijkstra is better than Lazy Dijkstra, but harder to implement\n\nI wrote extensively about different Dijktsra implementations in this Dijkstra blog post.\n\nDijkstra is similar to BFS, with the main difference that it uses a priority queue (PQ) instead of a queue to visit the nodes that are closer first (in terms of shortest paths).\n\nIn BFS, when a node is added to the queue, its distance from the starting node is already established and there is never a reason to add it again to the queue. In Dijkstra, when a node is added to the PQ, we might later find a shorter path while it is still in the PQ. When that happens, we can do two things:\n\nLazy Dijkstra: just add the node again with the new, improved distance. It will get popped before the previous occurrence because it has higher priority in the PQ. When a node with a \"stale\" distance gets popped off from the queue, we just ignore it.\n\nEager Dijkstra (called textbook Dijkstra in the other blog post): instead of adding the node again, find the existing occurrence of it in the PQ, and update it with the new found distance. This guarantees that the same node never appears twice in the PQ.\n\nBoth versions take O(E*log V) time, but eager is more space efficient, analogously to eager BFS: O(V) for eager Dijkstra vs O(E) for lazy Dijkstra.\n\nHere is lazy Dijkstra:\n\nUnfortunately, eager Dijkstra is not so easy to implement in Python because we are missing the decrease_key() operation in a heap (and Python does have a self-balancing BST data structure, which can also be used for eager Dijkstra). You can see a BST-based C++ implementation in my other blog post.\n\nThe dijkstra_lazy() algorithm above is more or less standard and it has been known as \"lazy Dijkstra\" for a while. However, it is possible to make an even lazier version which has the same runtime and space analysis (but likely bigger constant factors). The idea is that instead of only adding to the PQ the neighbors for whom we find an improved distance, we can simply add all of them, and discard duplicates once we extract them from the PQ:\n\nSo, Lazy or Eager?\n\nWe could keep looking at lazy vs eager algorithms, but I'll stop here. In aggregate, these are the pros and cons that I see:\n\nPros of lazy algorithms\n\nLazy algorithms require less code. This is because you only need to validate the parameters of the recursive function once at the beginning, instead of validating what you pass to each recursive call. This is specially true in binary tree problems, where you usually have two recursive calls. It doesn't apply as much for graphs.\n\nLazy algorithms require less indentation. For instance, in graph problems, we don't need to do checks inside the for loop over the neighbors.\n\nLazy algorithms do not require special handling for the first recursive call. You don't need to worry about things like checking if the root is NULL or marking the start node as visited.\n\nLazy recursive functions have simpler preconditions. You can just pass anything to them, and they work.\n\nPros of eager algorithms\n\nFor a graph BFS, eager has a better space complexity. This is a case where eager is objectively better. (Eager Dijkstra is also better but it is not expected to be implemented in interviews. Your interviewer is probably expecting lazy Dijkstra.)\n\nEager algorithms do fewer recursive calls or iterations. In a binary tree, the number of NULL nodes is always one more than the number of internal nodes. This means that a lazy traversal does twice as many recursive calls/iterations as the eager counterpart. This could make a big difference if you want to debug the code manually. For instance, in this picture, you can see that adding NULLs to the queue makes visualizing the steps more painful:\n\nEager algorithm can 'feel safer'. A friend commented that, with a lazy algorithm, they feel like they are missing an edge case.\n\nMy preference\n\nHere are my personal preferences for coding interviews (not those of the other authors of 'Beyond Cracking the Coding Interview'):\n\nStrong preferences:\n\nFor BFS, use eager. This one is clear cut.\n\nFor memoization DP, use lazy. It is much cleaner to code.\n\nFor Dijkstra, use lazy Dijkstra (not super lazy Dijkstra). It is what is realistic to do in an interview and probably what the interviewer expects.\n\nWeak preferences:\n\nFor binary tree traversals (iterative or recursive), use lazy. It is a bit cleaner.\n\nFor graph DFS, use eager. It is a bit more standard, and aligned with a graph BFS.\n\nIn the book, we'll definitely mention that some algorithms can be implemented in a lazy or eager way (in way less detail than here), and that you should choose the one that feels easier to you. But, we still need to pick one to show in the problem solutions. One idea is trying to be consistent throughout (e.g., doing all tree and graph traversals in an eager way). If you have an opinion on which one is better, please reach out! I'd love to hear it.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/lazy-vs-eager?category=dsa",
      "author": "",
      "user_id": ""
    },
    {
      "title": "In Defense of Coding Interviews",
      "content": "In Defense of Coding Interviews\n\nThere is already a lot of discourse about everything wrong with coding interviews. Indeed, one of the first chapters in Beyond Cracking the Coding Interview is What's Broken About Coding Interviews? (it's one of the sneak peek free chapters in bctci.co/free-chapters).\n\nHere, I want to collect all the arguments for the contrary view: that there are no clear better alternatives to coding interviews at Big Tech companies.\n\nDisclaimers:\n\nI am one of the authors of Beyond Cracking the Coding Interview, a prep book for coding interviews. Thus, I am vested in coding interviews not going away.\n\nI love leetcoding and specialized in DS&A for my PhD, so I haven't personally experienced the dread that most people feel grinding it.\n\nI've been an interviewer at Google in the past, but I'm not currently working for Big Tech, and I don't have any inside knowledge. This is just my assessment.\n\nThis post is only about Big Tech. I don't think coding interviews are a good idea for startups.\n\nThis post contains \"Strong Opinions, Weakly Held\". I believe everything here, but I'm very receptive to pushback and opposing data.\n\nThe rationale for coding interviews\n\nI think Big Tech companies understand that being cracked at DS&A is not really necessary to be a good SWE. I don't think coding interviews are about that at all.\n\nImagine you are a Big Tech company, like Google. You receive a massive stream of applications, and you have to trim that down to a still large number of hires. Your hiring system needs to be scalable:\n\nyou need to quickly train many interviewers\n\nyou need a way to evaluate candidates that minimizes interviewer bias (not your bias, or a specific person's bias, but all the biases of a large, heterogeneous group)\n\nSo, the first thing you do to scale--in true engineering fashion--is decoupling hiring and team matching. But that means you cannot hire for specific tech or domain experience: You don't know in what team candidates will end up, and your teams use a bunch of different languages and tech stacks (and a lot of it is internal anyway, so you definitely can't hire for that).\n\nSo, you need a competence assessment that is independent of any particulars about the job, much like the role the SAT plays for college admissions. How do you do that?\n\nIf you are a Big Tech company, what you actually want is candidates who can take any complex software system (that's not part of the candidate's previous expertise) and answer hard questions about it, like what's the best way to add a feature, how to optimize it, or how it should be refactored. In other words, the competence you want to assess is general problem-solving skills, and that's what coding interviews are designed for: you are given a tough problem that you have ideally never seen before (more on this later), and asked to showcase your thought process on how you approach it. When working as intended, I believe it gives more signal about your problem-solving skills and is easier to evaluate impartially than other popular interview formats, like talking about previous experience or take-home assignments. And there's an impartial way to evaluate them, by looking at the optimality of the solution.\n\nYes, there's a lot more to being a SWE than problem-solving skills--and that's why Google also does system design and behavioral interviews, but you still want to hire for this trait.\n\nThe two crucial flaws: memorization and cheating\n\nHopefully, the rationale above covered one of the most common criticisms of coding interviews: that they do not reflect the day-to-day work of an engineer. Instead, I want to focus on what I think are the two biggest issues with coding interviews:\n\nMemorizing an absurd amount of leetcode problems gives you an edge. This is the classic reason why people hate coding interviews with a passion. It has led to an \"arms race\" where candidates have to memorize more and more problems to improve their odds, and interviewers keep asking about more niche topics. At the extreme, coding interviews end up feeling like a lottery, and candidates find prep a soul-sucking waste of time.\n\nMemorizing an absurd amount of leetcode problems gives you an edge. This is the classic reason why people hate coding interviews with a passion. It has led to an \"arms race\" where candidates have to memorize more and more problems to improve their odds, and interviewers keep asking about more niche topics. At the extreme, coding interviews end up feeling like a lottery, and candidates find prep a soul-sucking waste of time.\n\nCheating has become easy with AI. This is a newer issue that's becoming more prevalent due to the fact that LLMs are pretty good at leetcoding. In real time, a cheater can feed the problem statement to an LLM (without obvious tales like \"select all\"), get a solution, and even a script for what to say.\n\nCheating has become easy with AI. This is a newer issue that's becoming more prevalent due to the fact that LLMs are pretty good at leetcoding. In real time, a cheater can feed the problem statement to an LLM (without obvious tales like \"select all\"), get a solution, and even a script for what to say.\n\nFrom the company's side, Issue (1) is not much of an issue. It definitely undermines the \"problem-solving\" part of the interview if a candidate is just recalling the question, but, statistically, if they do enough rounds, it's unlikely to happen every round. Some people (not me) also argue that the memorization is even good for the companies because it rewards hard work and dedication.\n\nFor what it's worth, one thing we hoped to change about the interview prep discourse with BCtCI is that candidates should focus on improving their problem-solving skills rather than memorizing. See, for instance, how we teach binary search or how we approach hard problems. But yes, grinding is still necessary.\n\nIssue (1) also means that they'll lose a big chunk of candidates who are great SWEs but won't put up with grinding leetcode or that simply don't perform well under pressure (and, from personal experience, many great developers fall in this group). This sucks from the candidate's perspective, but if you are Google, you receive an overwhelming amount of applications from qualified candidates, so you are more OK with rejecting good candidates than accepting bad ones.\n\nIssue (2), on the other hand, has the potential to completely ruin coding interviews from the company's side. I'm seeing a quick rise of stories from frustrated interviewers who interviewed or even hired cheaters who could then not do the job (Exhibit A).\n\nI expect to see some kind of systematic response to this from Big Tech, but it's not clear what as of April 2025. This article includes some internal comments from Google execs:\n\n[Brian] Ong [Google’s vice president of recruiting] said candidates and Google employees have said they prefer virtual job interviews because scheduling a video call is easier than finding a time to meet in available conference rooms. The virtual interview process is about two weeks faster, he added. He said interviewers are instructed to probe candidates on their answers as a way to decipher whether they actually know what they’re talking about. “We definitely have more work to do to integrate how AI is now more prevalent in the interview process,” said Ong. He said his recruiting organization is working with Google’s software engineer steering committee to figure out how the company can refine its interviewing process. “Given we all work hybrid, I think it’s worth thinking about some fraction of the interviews being in person,” Pichai responded. “I think it’ll help both the candidates understand Google’s culture and I think it’s good for both sides.”\n\n[Brian] Ong [Google’s vice president of recruiting] said candidates and Google employees have said they prefer virtual job interviews because scheduling a video call is easier than finding a time to meet in available conference rooms. The virtual interview process is about two weeks faster, he added.\n\nHe said interviewers are instructed to probe candidates on their answers as a way to decipher whether they actually know what they’re talking about.\n\n“We definitely have more work to do to integrate how AI is now more prevalent in the interview process,” said Ong. He said his recruiting organization is working with Google’s software engineer steering committee to figure out how the company can refine its interviewing process.\n\n“Given we all work hybrid, I think it’s worth thinking about some fraction of the interviews being in person,” Pichai responded. “I think it’ll help both the candidates understand Google’s culture and I think it’s good for both sides.”\n\nI thought going back to in-person interviews would be a no-brainer for a company like Google, but my reading of these comments is that they don't seem too bothered for now. ~shrug~\n\nDisclaimer: I haven't worked for a Big Tech company since before AI cheating went viral, so I don't have internal insight into what people in charge of hiring are actually thinking.\n\nTwo related arguments that I don't subscribe to are (1) that leetcode-style interviews are no longer relevant because AI can solve them, and (2) that LLMs should be allowed during coding interviews because they are allowed on the job. The fact that AI can solve coding questions doesn't change that it still gives you the important signal that you want from humans: algorithmic thinking and general problem-solving skills. We just need humans to not cheat.\n\nI'll share my thoughts on how to improve coding interviews to address these issues. First, let's see why I think the alternatives are not better.\n\nThe problems with the alternatives\n\nTake-home assignments\n\nTake-home assignments are even more subject to cheating, so that can't be the answer to cheating. Never mind LLMs, you don't even know who did the assignment. But take-home assignments have other flaws:\n\nThey create an asymmetry between company and candidate, where the company asks for a ton of work from the candidate without putting any effort in. \"Oh, we have way too many candidates we need to filter down to a shortlist? Send all of them a complex task to do over the weekend.\" I prefer a model where both company and candidate have to put in time. I'm more OK with take-home assignments as the final stage of the process.\n\nThey favor people who are unemployed and/or have a lot of free time to polish the assignment.\n\nPrevious experience\n\nI find this too subjective to give signal about problem-solving skills, and it's more about being a good \"salesperson\". I also think it's more subject to bias: people with a similar background as yours are probably more likely to have similar interests, and thus you may find their side-projects more interesting.\n\nTrial periods\n\nThis makes sense to me in smaller companies, where you find a candidate with the perfect profile for the task at hand. It doesn't scale to Big Tech companies.\n\nOther alternatives\n\nIf there are other alternatives that fulfill the same purpose as coding interviews but don't suffer from the same issues, I'd love to hear about them.\n\nOne idea I liked is going through a code review during the interview, but it's not clear that (1) it offers as much signal about problem-solving skills, and (2) it is easy to evaluate impartially.\n\nHow to improve coding interviews\n\nRight now, FAANG interviewers focus too much on \"Did they solve the question or not?\" That's because they don't get much training on how to interview well (if at all), and it's the most straightforward way to pass on a hire/no hire recommendation to the hiring committee. This leads to many interviewers just pasting the prompt in and mostly sitting in silence. This is the ideal scenario for cheaters.\n\nThe obvious things\n\nThere are obvious ways to improve this situation:\n\nIn-person interviews. These have other benefits, like allowing the candidate to get a better sense of the company culture.\n\nNot using publicly available questions, and actively scanning for leaks.\n\nCheating detection software (privacy is a concern here -- would it be too crazy for a company to ship a laptop to the candidate just for the interview?).\n\nStop asking questions that require knowing some niche trick that a normal person wouldn't be able to figure out on the spot. Those reinforce a focus on memorization.\n\nLow effort ways of countering cheating\n\nI also think that measures designed to throw LLMs off could be effective (at least in the short term) and require minimal effort, such as:\n\nStating the question, or part of it, instead of writing the whole thing down\n\nIncluding a 'decoy' question and telling the candidate, \"Ignore that line, it is part of our anti-cheating measures.\"\n\nSee LinkedIn discussion.\n\nA fundamental tradeoff\n\nPerhaps the most effective way to counter both memorization and cheating is to make coding interviews more open ended and conversational. To use a chess analogy, a cheater may make a great move, but if you ask them to explain why they did it, they may not be able to.\n\nThe interviewer can use a coding question as a launching point, but then drill down on technical topics as they come up. So, e.g., if a candidate chooses to use a heap, the interviewer could go into:\n\nWhat made you think of using a heap? What properties are important for this problem?\n\nWhat are the tradeoffs of using a heap vs binary search trees?\n\nHow would you go about implementing a heap that supports arbitrary priorities?\n\nWhy is heapify faster than inserting one by one?\n\nIf interviewers did that, it wouldn't even be necessary to ask tricky questions. They could even ask Fibonacci.\n\nThe problem is that, the more open ended the interview is, the more difficult it is to evaluate candidates systematically. To start, you'd need better interviewers and better interviewer training. However, it seems to me that there is a fundamental tradeoff between how objective the evaluation is and how gameable the interview is by memorizing or cheating.\n\nI don't have a good solution to this--I would love to hear yours.\n\nMore good things about coding interviews\n\nOnly one thing to study\n\nAn underrated upside of leetcode interviews is that you only need to study one thing for all the big companies. I feel like if every company asked different things, interview prep time would decrease for any specific company but increase overall.\n\nIn fact, a likely outcome of the push for fewer leetcode-style interviews is an even worse compromise: coding interviews won't completely go away, so you'll still need to grind leetcode, but you'll also have to prep a bunch of specialized stuff for each company on top of that.\n\nSee LinkedIn discussion.\n\nThey are not based on pedigree\n\nCoding interviews act as a form of standardized testing, similar to the role of SAT for college admissions in the US. And, much like the SAT allows high-school students from all backgrounds to attend top colleges, coding interviews allow candidates from all backgrounds to get at the top companies. The leetcode grind is the same for everyone.\n\nIf we kill coding interviews without a good alternative, it seems inevitable that Big Tech companies will give more weight to resume and referrals. We all agree that's a bad thing.\n\nFinal thoughts\n\nThe best question we got in our Reddit AMA for BCtCI was whether we'd use coding interviews ourselves if we were in charge of hiring. You can see Gayle's, Mike's (mikemroczka.com), and my answers. We all said no in its current form, but yes with caveats/improvements.\n\nMy favorite answer was Mike's. He's less of a proponent of leetcode-style interviews than I am, but I think he strikes a thoughtful balance between DS&A and practical stuff:\n\nBest question so far. Yes, I would ask DS&A questions still, but not exclusively and not difficult ones. Many startups shouldn't ask them though, because most people are bad at discerning what a reasonable question is. I would do 4-5 rounds of interviews because less than that is hard to be significant, but more than that and you're wasting too much of a candidate's time (Netflix has a whopping 8 rounds!!). For a senior engineer role, I'd do something like this. Round 1: An online DS&A assessment to filter out people that can't do the simple things (easy & very simple medium questions only, not hard) Round 2: Live interview of DS&A (simple medium, not hard. essentially just making sure you didn't cheat on the previous round by asking you to explain your answers and code something new from scratch) Round 3: System design (no need for perfect answers, but I'd ask an uncommon question to ensure it was something they hadn't memorized) Round 4: Behavioral, with a focus on cross-team impact. This would just be a simple pass/fail and just a vibe check. It might also be skipped if the prior two rounds had good signal for emotional intelligence Round 5: Remote logging into a server and working on an actual bug that was fixed in our codebase before. There would be no time limit, but time on the server would be logged to weed people out who needed days to complete a simple task. This ends up testing a little bit of theory, practical knowledge, emotional intelligence, and the generalized SWE skillset. Full disclosure. This is my answer. Not the answer of every author. Again, I'd stress that the average startup wouldn't benefit from DS&A and shouldn't be asking them\n\nBest question so far. Yes, I would ask DS&A questions still, but not exclusively and not difficult ones. Many startups shouldn't ask them though, because most people are bad at discerning what a reasonable question is.\n\nI would do 4-5 rounds of interviews because less than that is hard to be significant, but more than that and you're wasting too much of a candidate's time (Netflix has a whopping 8 rounds!!). For a senior engineer role, I'd do something like this.\n\nRound 1: An online DS&A assessment to filter out people that can't do the simple things (easy & very simple medium questions only, not hard)\n\nRound 2: Live interview of DS&A (simple medium, not hard. essentially just making sure you didn't cheat on the previous round by asking you to explain your answers and code something new from scratch)\n\nRound 3: System design (no need for perfect answers, but I'd ask an uncommon question to ensure it was something they hadn't memorized)\n\nRound 4: Behavioral, with a focus on cross-team impact. This would just be a simple pass/fail and just a vibe check. It might also be skipped if the prior two rounds had good signal for emotional intelligence\n\nRound 5: Remote logging into a server and working on an actual bug that was fixed in our codebase before. There would be no time limit, but time on the server would be logged to weed people out who needed days to complete a simple task.\n\nThis ends up testing a little bit of theory, practical knowledge, emotional intelligence, and the generalized SWE skillset.\n\nFull disclosure. This is my answer. Not the answer of every author. Again, I'd stress that the average startup wouldn't benefit from DS&A and shouldn't be asking them\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/in-defense-of-coding-interviews?category=dsa",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Actually Implementing Dijkstra's Algorithm",
      "content": "Actually Implementing Dijkstra's Algorithm\n\nIntroduction\n\nDijkstra's algorithm for the shortest-path problem is one of the most important graph algorithms, so it is often covered in algorithm classes. However, going from the pseudocode to an actual implementation is made difficult by the fact that it relies on a priority queue with a \"decrease key\" operation. While most programming languages offer a priority queue data structure as part of their standard library, this operation is generally not supported (e.g., in C++, Java or Python). In this blog, we go over the different ways to implement Dijkstra's algorithm with and without this operation, and the implications of using each. All in all, we consider 5 versions of Dijkstra (names mostly made up by me):\n\nTextbook Dijkstra: the version commonly taught in textbooks where we assume that we have a priority queue with the \"decrease key\" operation. As we said, this often does not hold true in reality.\n\nLinear-search Dijkstra: the most naive implementation, but which is actually optimal for dense graphs.\n\nLazy Dijkstra: practical version which does not use the \"decrease key\" operation at all, at the cost of using some extra space.\n\nBST Dijkstra: version which uses a self-balancing binary search tree to implement the priority queue functionality, including the \"decrease key\" operation.\n\nTheoretical Dijkstra: version that uses a Fibonacci heap for the priority queue in order to achieve the fastest possible runtime in terms of big-O notation. This is actually impractical due to the complexity and high constant factors of the Fibonacci heap.\n\nRoughly, each of the 5 versions corresponds to a different data structure used to implement the priority queue. Throughout the post, let n be the number of nodes and m the number of edges. Here is summary of the resulting runtime and space complexities:\n\nTextbook Dijkstra: indexed binary heap. Runtime: O(m*log n); space: O(n).\n\nLinear-search Dijkstra: unordered array. Runtime: O(n²); space: O(n).\n\nLazy Dijkstra: binary heap. Runtime: O(m*log n); space: O(m).\n\nBST Dijkstra: self-balancing BST. Runtime: O(m*log n); space: O(n).\n\nTheoretical Dijkstra: Fibonacci heap. Runtime: O(m + n*log n); space: O(n).\n\nWe provide implementations in Python and C++. The initial sections are mostly background. If you are already familiar with Dijkstra's algorithm, you can skip to the code snippets.\n\nThe shortest-path problem\n\nThe input consists of a graph G and a special node s. The edges of G are directed and have non-negative weights. The edge weights represent the \"lengths\" of the edges. The goal is to find the distance from s to every other node in G. The distance from s to another node is the length of the shortest path from s to that node, and the length of a path is the sum of the lengths of its edges. If a node is unreachable from s, then we say that the distance is infinite.\n\nMore precisely, this is known as the \"single-source shortest-path\" (SSSP) problem, because we find the distance from one node to every other node. Related problems include the \"all-pairs shortest paths\" problem and the single-source single-destination problem. Dijkstra's algorithm is a really efficient algorithm for the SSSP problem when the edges are non-negative. Dijkstra's algorithm does not work in the presence of negative edges (zero-weight edges are fine). If G contains negative edges, we should use the Bellman-Ford algorithm instead.\n\nThe constraint that the edges are directed is not important: if G is undirected, we can simply replace every undirected edge {u,v} with a pair of directed edges (u,v) and (v,u) in opposite directions and with the weight of the original edge.\n\nTo simplify things, we make a couple of assumptions that do not make any actual difference:\n\nNodes not reachable by s play no role in the algorithm, so we assume that s can reach every node. This is so that, in the analysis, we can assume that n=O(m).\n\nWe assume that the distance from s to every node is unique. This allows us to talk about \"the\" shortest path to a node, when in general there could be many.\n\nThe graph's representation\n\nA graph is a mathematical concept. In the context of graph algorithms, we need to specify how the graph is represented as a data structure. For Dijkstra's algorithm, the most convenient representation is the adjacency list. The valuable thing about the adjacency list representation is that it allows us to iterate through the out-going edges of a node efficiently.\n\nIn the version of the adjacency list that we use, each node is identified with an index from 0 to n-1. The adjacency list contains one list for each node. For each node u between 0 and n-1, the list G[u] contains one entry for each neighbor of u. In a directed graph, if we have an edge (u,v) from u to v, we say that v is a neighbor of u, but u is not a neighbor of v. Since the graph is weighted, the entry for each neighbor v consists of a pair of values, (v, l): the destination node v, and the length l of the edge (u,v).\n\nDijkstra's algorithm idea\n\nOne of the data structures that we maintain is a list dist where dist[u] is the best distance known for u so far. At the beginning, dist[s] = 0, and for every other node dist[u] = infinity. These distances improve during the algorithm as we consider new paths. Our goal is to get to the point where dist contains the correct distance for every node.\n\nDuring the algorithm, the dist list is only updated through an operation called \"relaxing\" an edge.\n\nIn words, relaxing an edge (u,v) means checking if going to u first and then using the edge (u,v) is shorter than the best distance known for v. If it is shorter, then we update dist[v] to the new, better value.\n\nDijkstra's algorithm is based on the following observations:\n\nif dist[u] is correct and the shortest path from s to v ends in the edge (u,v), then if we relax the edge (u,v), we will find the correct distance to v. If either of the conditions are not satisfied, relaxing (u,v) may improve dist[v], but it will not be the correct distance.\n\nTo find the correct distance to v, we need to relax all the edges in the shortest path from s to v, in order. If we do it in order, each node in the path will have the correct distance when we relax the edge to the next node, satisfying the conditions.\n\nDijkstra's algorithm is efficient because every edge is relaxed only once (unlike other algorithms like Bellman-Ford, which relaxes the edges multiple times). To relax every edge only once, we must relax the out-going edges of each node only after we have found the correct distance for that node.\n\nAt the beginning, only s has the correct distance, so we relax its edges. This updates the entries in dist for its neighbors. The neighbor of s that is closest to s, say, x, has the correct distance at this point. This is because every other path from s to x starts with a longer edge, and, since the graph does not have negative-weight edges, additional edges can only increase the distance. Next, since x has the correct distance, we can relax its out-going edges. After that, the node y with the 3rd smallest distance in dist (after s and x) has the correct distance because the node before y in the shortest path from s to y must be either s or x. It cannot be any other node because simply reaching any node that is not s or x is already more expensive than the distance we have found for y. We continue relaxing the out-going edges of nodes, always taking the next node with the smallest found distance. By generalizing the argument above, when we relax the out-going edges of each node, that node already has the correct distance. We finish after we have gone through all the nodes. At that point, dist contains the correct distance for every node.\n\nIn order to implement Dijkstra's algorithm, we need to decide the data structures used to find the unvisited node with the smallest distance at each iteration.\n\nPriority queues\n\nPriority queues are data structures that are useful in many applications, including Dijkstra's algorithm.\n\nIn a normal queue, we can insert new elements and extract the oldest element. A priority queue is similar, but we can associate a priority with each element. Then, instead of extracting the oldest element, we extract the one with highest priority. Depending on the context, \"highest priority\" can mean the element with the smallest or largest priority value. In this context, we will consider that the highest priority is the element with the smallest priority value.\n\nA priority queue is an abstract data structure. That means that it only specifies which operations it supports, but not how they are implemented. There actually exist many ways to implement a priority queue. To make matters more confusing, different priority queues implementations support different sets of operations. The only agreed part is that they must support two basic operations:\n\ninsert(e, k): insert element e with priority k.\n\nextract_min(): remove and return the element with the smallest priority value.\n\nFor Dijkstra's algorithm, we can use a priority queue to maintain the nodes, using dist[u] as the priority for a node u. Then, at each iteration we can extract the unvisited node with the smallest distance. However, there is a problem: when we relax an edge, the value dist[u] may decrease. Thus, we need the priority queue to support a third operation which is not commonly supported:\n\nchange_priority(e, k): set the priority of e to k (assuming that e is in the priority queue).\n\nA related operation is removing elements that are not the most prioritary:\n\nremove(e): remove e (assuming that e is in the priority queue).\n\nIf a priority queue implements remove, we can use it to obtain the same functionality as change-priority(e, k): we can first call remove(e) and then reinsert the element with the new key by calling insert(e, k).\n\nPseudocode with a priority queue\n\nAssuming that we have a priority queue data structure that supports insert, extract-min, and change-priority, Dijkstra's pseudocode would be as follows.\n\nThe priority queue contains the unvisited nodes, prioritized by distance from s. At the beginning, the priority queue contains all the nodes, and they are removed as they are visited.\n\nA common variation is to add them to the priority queue when they are reached for the first time, instead of adding all the nodes at the beginning. The only change is how the priority queue is initialized and the if-else cases at the end:\n\nIt does not change the runtime or space complexity, but there is also no downside to deferring insertions to the PQ. On average, the PQ will contains fewer elements.\n\nAnalysis of Dijkstra's algorithm\n\nUsually, we analyze the algorithms after implementing them. However, in order to choose the best data structure for the priority queue, we need to analyze how much we use each type of operation. Thus, it is convenient to define the runtime in terms of the priority queue operations, without specifying yet how they are done. Let T_ins, T_min, and T_change be the time per insert, extract_min, and change_priority operation, respectively, on a priority queue containing n elements.\n\nThe main while loop has n iterations, and the total number of iterations of the inner for loop, across all n iterations, is m. This is because each edge is relaxed once.\n\nThe runtime is dominated by the priority queue operations, so it is O(n*T_ins + n*T_min + m*T_change). These operations dominate the runtime because everything else combined (like updating the dist list) takes O(n+m) time.\n\nLinear-search Dijkstra for dense graphs\n\nThe simplest way to simulate the extract_min functionality of a priority queue is to iterate through the entire dist list to find the smallest value among the non-visited entries. If we do this, we don't need a priority queue. We call this linear-search Dijkstra. We get T_ins = O(1), T_min = O(n), and T_change = O(1). Plugging those in, the total runtime of linear-search Dijkstra is O(n + n*n + m) = O(n²), where we simplify out the m term because n² > m in any graph. More precisely, a directed graph with n nodes has at most n*(n-1)=O(n²) edges.\n\nA graph with \"close to\" n*(n-1) edges is called dense. Linear-search Dijkstra is actually optimal for dense graphs. This is because Dijkstra's algorithm must take O(m) time just to relax all edges, so it cannot be faster than O(m), and, in dense graphs that is already proportional to O(n²).\n\nHere is a Python implementation:\n\nAnd C++. We omit the includes and \"using namespace std;\".\n\nPriority queues for sparse graphs\n\nThe O(n²) time from the implementation above is slow if the graph G is sparse, meaning that the number of edges is small relative to O(n²). Recall that the time is O(n*T_ins + n*T_min + m*T_change). If m is more similar to n than to n², then we would be happy to trade a slower change_priority time for a faster extract_min time.\n\nThe best possible answer in terms of big-O notation is to use a priority queue implementation based on a data structure known as a Fibonacci Heap. A Fibonacci heap containing at most n elements achieves the following times:\n\ninsert: O(log n) amortized time.\n\nextract_min: O(log n) amortized time.\n\nchange_priority: O(1) amortized time.\n\nAmortized time means that it could take more time, but, if we average out the times for that operation across the execution of an algorithm, each one takes that time on average.\n\nUsing a Fibonacci heap, we get a total time of O(n*log n + m) for Dijkstra's algorithm. This is really fast in terms of big-O notation, but Fibonacci heaps have larger constant factors than other data structures, making them slower in practice.\n\nThe most common way to implement a priority queue is with a binary heap. It is simple and fast in practice. Binary heaps support insert and extract_min in O(log n) like a Fibonacci heap. However, they do not support the change_priority operation.\n\nIt is possible to modify a binary heap to to support the change_priority operation in O(log n) time. The result is sometimes called an \"indexed priority queue\". Using an indexed priority queue, we would get a total runtime of O(n*log n + m*log n) = O(m*log n). This is slightly worse than with a Fibonacci heap, and faster in practice.\n\nIn any case, the priority queues provided by languages like C++, Python, and Java, do not support the change_priority operation. This creates a disconnect between the pseudocode taught in classrooms and the actual code that we can write.\n\nThe goal of this post is to illustrate the options to deal with this issue. There are 3:\n\nTextbook Dijkstra: find or implement our own indexed priority queue.\n\nLazy Dijkstra: we implement Dijkstra without using the change_priority operation at all.\n\nBST Dijkstra: we use a self-balancing binary search tree as the priority queue.\n\nWe will cover the latter two options. The first option is an interesting exercise in data structures (I implemented it once for a project), but it is more about the inner workings of binary heaps than it is about Dijkstra's algorithm.\n\nAll three options have a runtime of O(m*log n). Note that for dense graphs, this becomes O(n² log n) time, so they are all worse than the naive linear-search Dijkstra. In terms of space, lazy Dijkstra is worse than the others, as it needs O(m) space, as opposed to O(n) for the other options.\n\nLazy Dijkstra\n\nWe implement Dijkstra using a priority queue that does not support the change-priority operation. We need the following change: when we find a shorter distance to a node that is already in the priority-queue, instead of using the \"change-priority\" operation, we simply use an \"insert\" operation and add a copy of the node in the priority queue with the new distance. Then, when we extract a node from the priority queue, we ignore it if it is not the first time we extract that node. We call this version of Dijkstra \"lazy Dijkstra\" because we \"postpone\" the removal of the pre-existing copy of the node.\n\nHere is a Python version. The logical structure of a binary heap is a binary tree, but, internally the tree is represented as an array for efficiency reasons. Python is a bit whack because, instead of having a priority queue module that encapsulates the implementation, we have the heapq module, which provides priority queue operations that can be used directly on a list representing a binary heap. heapq offers functions heappop (equivalent to extract_min) and heappush (equivalent to insert). These functions receive a normal Python list as a parameter, and this list is assumed to represent a binary heap. In Python, if the priority queue contains tuples, then the first element in the tuple is the priority. Thus, in the implementation we insert tuples to the priority queue with the distance first and the node second.\n\nHere is a C++ version:\n\nAnalysis: since nodes can be added to the priority queue multiple times, in lazy Dijkstra the maximum number of elements in the priority queue increases from O(n) to O(m). As a result, we do O(m) extract_min and insert operations. The total runtime is O(m*log m). This can be simplified to O(m*log n), because log m < log (n²) = 2 log n = O(log n). Thus, in terms of big-O notation, lazy Dijkstra is equally fast as textbook Dijkstra (Dijkstra with an indexed priority queue). The only thing that got worse is the space used by the priority queue.\n\nBST Dijkstra\n\nSelf-balancing binary search trees, like red-black trees or AVL trees, are a type of data structure that maintains a set of elements ordered according to values associated with the elements, known as the elements' keys. They support a few operations, all in O(log n) time. For our use case, we are interested in the following ones:\n\nInsert an element with a given key.\n\nFind the element with the smallest/largest key.\n\nGiven a key, find if there is an element with that key, and optionally remove it.\n\nThese operations allow us to use a self-balancing BST to implement a priority queue. With the third operation, we can even implement the change_priority operation, as we mentioned.\n\nPython does not actually have a self-balancing binary search tree module (why?!), so we cannot implement this version of Dijkstra either without finding or implementing our own self-balancing BST.\n\nHere is a C++ version. In C++, the set data structure is implemented as a self-balancing BST:\n\nAnalysis: in a sense, BST Dijkstra combines the best of both worlds: it has the same runtime and space complexity as textbook Dijkstra, without needing the extra space of Lazy Dijkstra, but it uses a much more ubiquitous data structure, a self-balancing BST. However, in practice, self-balancing BSTs are slower than binary heaps. This has to do with the fact that heaps can be implemented on top of an array, while BSTs use recursive tree data structures with child pointers. The array has much better locality of reference. For sparse graphs, I'd expect the performance of the different versions to be ordered as follows:\n\nTextbook Dijkstra > Lazy Dijkstra > BST Dijkstra > Theoretical Dijkstra > Linear-search Dijkstra\n\nPractice problems\n\nHere are some problems on leetcode:\n\nNetwork Delay Time\n\nFind the City With the Smallest Number of Neighbors at a Threshold Distance\n\nReachable Nodes In Subdivided Graph\n\nPath with Maximum Minimum Value (Premium only)",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/implementing-dijkstra?category=dsa",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Get Binary Search Right Every Time, Explained Without Code",
      "content": "Get Binary Search Right Every Time, Explained Without Code\n\nOne of the things that makes binary search tricky to implement is that you usually need to tweak the pointer manipulation logic in subtle ways based on the specifics of the problem.\n\nE.g., an implementation that works for finding a target in a sorted array when the target is present, may not work if the target is missing. Or, it may not be clear how to tweak the code to find the last occurrence of the target instead of the first one. And of course, there are plenty of less conventional applications of binary search where the input is not an array, like catching bike thieves.\n\nIn Beyond Cracking the Coding Interview, we wanted to simplify this, so we went looking for a general binary search template. Going into it, I thought we might need at least two templates, but we ended up with just one, which we called the \"transition point recipe\", and which works for every problem we tried, including the 17 problems in the binary search chapter of the book. If you find one where it doesn't work, let me know!\n\nThe transition point problem\n\nHere is the thesis of the transition point recipe:\n\nEvery binary search problem can be reduced to the 'transition point problem'.\n\nIn the 'transition point problem', you are given an array with just two values, say 1 and 2, where all the 1s come before the 2s, and you need to point where it changes.\n\nE.g., in the array [1, 1, 1, 1, 1, 2, 2, 2], the last 1 is at index 4 and the first 2 is at index 5.\n\nKnowing how to solve this specific problem is key to our recipe. The specific binary search implementation is not important, but there is an invariant we can follow that makes it quite easy: ensure that the left pointer is always at a 1 and the right pointer is always at a 2.\n\nWe give code in the book, but remembering exact code in an interview is error prone. Instead, the four bullet points below are all I personally remember, and I feel confident that I can derive the rest easily.\n\nStart by handling some edge cases: The array is empty Every value is 1 Every value is 2\n\nThe array is empty\n\nEvery value is 1\n\nEvery value is 2\n\nInitialize two pointers, left and right, to the first and last indices, respectively.\n\nFor the main binary search loop, always maintain the invariant that the value at left is 1 and the value at right is 2. Let this invariant guide your pointer manipulation logic, so that you don't need to memorize any code.\n\nStop when the left and right pointers are next to each other (i.e., left + 1 == right).\n\nCombining the invariant with the stopping condition, we get that, at the end, left will be at the last 1 and right will be at the first 2.\n\nThese bullet points rely on two ideas to make binary search easier: (1) handling edge cases upfront, and (2) letting strong invariants guide the implementation. Notice how the invariant even guides the edge cases at the beginning, as they are the necessary ones to be able to initialize left and right in a way that satisfies it.\n\nThe reduction\n\nOk, so now, let's take for granted that we can solve the transition point problem. How does this help us solve other binary search problems?\n\nThe idea is to come up with a (problem-specific) predicate, like < target, >= target, or x % 2 == 0, which splits the search range into two regions, the \"before\" region and the \"after\" region.\n\nThis predicate is a function that takes an element of the search range and returns a boolean, and -- as you probably saw coming -- it is key that all the elements with true values come before the elements with false values (or the other way around).\n\nThen, we can use the solution to the transition point problem to find the transition point between the 'before' and 'after' regions. The only difference is that, instead of checking boolean values directly, we check the result of the predicate.\n\nYou can even wrap the predicate in a function, which we called is_before(x) in the book, which tells you whether a given element is in the 'before' region. Then, it's really obvious that we are just solving the transition point problem every time.\n\nThe only part that requires some thinking is choosing the right transition point. For example:\n\nif we want to find the first occurrence of target in a sorted array, we can use is_before(x) = x < target, which means that, if target is present, the first occurrence is the first element in the 'after' region (so, we can check/return the right pointer at the end).\n\nif we want to find the last occurrence of target in a sorted array, we can use is_before(x) = x <= target, which means that, if target is present, the last occurrence is the last element in the 'before' region (so, we can check/return the left pointer at the end).\n\nAnd so on for other problems.\n\nYou can try the transition-point recipe on all the problems from the binary search chapter of the book online at start.interviewing.io/beyond-ctci/part-vii-catalog/binary-search, even if you don't have the book. There, you can also find all our solutions using the recipe, in Python, JS, Java, and C++.\n\nBy the way, the binary search chapter of the book is free -- it's in bctci.co/free-chapters.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/binary-search?category=dsa",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Iterative Tree Traversals: A Practical Guide",
      "content": "Iterative Tree Traversals: A Practical Guide\n\nIntroduction\n\nI don't know how often tree traversals come up in actual software projects, but they are popular in coding interviews and competitive programming. In this article, I share an approach for implementing tree traversal algorithms iteratively that I found to be simple to remember and implement, while being flexible enough to do anything that a recursive algorithm can (I also didn't like most suggestions I saw online). The main technique is given in section \"Iterative Postorder and Inorder Traversal\", but first I give some context. I also link to practice problems on leetcode.com for the reader to play with. I provide some solutions, but I suggest trying the problems out first. The code snippets are in C++, but leetcode accepts most languages.\n\nWhat are Tree Traversals\n\nMathematically, trees are just connected acyclic graphs. However, in the context of tree traversals, we are usually working with rooted trees represented with a recursive structure such as the following (which is the default definition in Leetcode for binary trees). A leaf is a node with two null pointers as children:\n\nA tree traversal is an algorithm that visits every node in a tree in a specific order (and does some computation with them, depending on the problem). For binary trees specifically, there are three important orders:\n\nPreorder: root before children. As we will see, this is the simplest to implement.\n\nInorder: left child, then root, then right child. This traversal is most often used on binary search trees (BST). A BST is a rooted binary tree with the additional property that every node in the left subtree has a smaller value than the root, and every node in the right subtree has a larger value than the root. This traversal is called \"inorder\" because, when used on a BST, it will visit the nodes from smallest to largest.\n\nPostorder: children before root. It comes up in problems where we have to aggregate information about the entire subtree rooted at each node. Classic examples are computing the size, the height, or the sum of values of the tree.\n\nBecause rooted trees are recursive data structures, algorithms on trees are most naturally expressed recursively. Here are the three traversals. I use the function process(node) as a placeholder for whatever computation the problem calls for.\n\nSide-note: in C++, pointers are implicitly converted to booleans: a pointer evaluates to true if and only if it is not null. So, in the code above, \"if (!root)\" is equivalent to \"if (root == NULL)\".\n\nTraversal problems on leetcode\n\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/\n\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/\n\nWhy / When to Use an Iterative Traversal\n\nIf the recursive implementation is so simple, why bother with an iterative one? Of course, to avoid stack overflow. Most runtime engines/compilers set a limit on how many nested calls a program can make. For example, according to this article:\n\nDefault stack size varies between 320k and 1024k depending on the version of Java and the system used. For a 64 bits Java 8 program with minimal stack usage, the maximum number of nested method calls is about 7000.\n\nDefault stack size varies between 320k and 1024k depending on the version of Java and the system used. For a 64 bits Java 8 program with minimal stack usage, the maximum number of nested method calls is about 7000.\n\nIf the height of the tree is larger than this limit, the program will crash with a stack overflow error. A recursive implementation is safe to use if:\n\nSomehow we know that the input trees will be small enough.\n\nThe tree is balanced, which means that, for each node, the left and right subtrees have roughly the same height. In a balanced tree, the height is guaranteed to be logarithmic on the number of nodes (indeed, that is why balanced BSTs guarantee O(log n) search time), so any tree that fits in RAM (or even disk) will require a tiny number of recursive calls.\n\nHowever, if we are not in either of the cases above, an iterative solution is safer.\n\nRecursive and iterative traversals have the same runtime complexity, so this is not a concern when choosing either (all the problems shown in this article can be solved in linear time using either).\n\nThe main approach for converting recursive implementations to iterative ones is to \"simulate\" the call stack with an actual stack where we push and pop the nodes explicitly. This works great \"out-of-the-box\" with preorder traversal.\n\nIncidentally, when implementing tree traversals we need to make an implementation choice about how to handle NULL pointers. We can be eager and filter them out before adding them to the stack, or we can be lazy and detect them once we extract them from the stack. Both are fine—what matters is to be deliberate and consistent about which approach we are using. I prefer the latter as it yields slightly shorter code, so I will use it in all the following examples. For comparison, here is the iterative preorder traversal with both approaches:\n\nNote that the right child is pushed to the stack before the left one. This is because we want the left child to be above in the stack so that it is processed first.\n\nPreorder traversal practice problems\n\nhttps://leetcode.com/problems/invert-binary-tree/\n\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/\n\nThis problem asks to find the depth of a binary tree (follow the link for the description and examples). It requires passing information from each node to its children. We can do this by changing the stack to stack<pair<TreeNode*, int>>, so that we can pass an int to each child, as in the solution below:\n\nIn the code above, the {} notation is used to create pairs (e.g., {root, 0}). If one is not familiar with pairs in C++, or is using a language without the equivalent, a simple alternative is to use two separate stacks, one for the nodes and one for the info.\n\nThe next two problems are similar:\n\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/\n\nhttps://leetcode.com/problems/path-sum/\n\nhttps://leetcode.com/problems/symmetric-tree/\n\nA solution for the last one, this time using a stack with a pair of nodes:\n\nIterative Postorder and Inorder Traversal\n\nWhile iterative preorder traversal is straightforward, with postorder and inorder we run into a complication: we cannot simply swap the order of the lines as with the recursive implementation. In other words, the following does not yield a postorder traversal:\n\nThe node is still processed before its children, which is not what we want.\n\nThe workaround, once again emulating the recursive implementation, is to visit each node twice. We consider postorder traversal first. In the first visit, we only push the children onto the stack. In the second visit, we do the actual processing. The simplest way to do this is to enhance the stack with a \"visit number flag\". Implementation-wise, we change the stack to stack<pair<TreeNode*, int>> so that we can pass the flag along with each node. The iterative postorder looks like this:\n\nNote the order in which the nodes are added to the stack when visit == 0. The parent ends up under its children, with the left child on top. Since it is the first time that the children are added to the stack, their visit-number flag is 0. For the parent, it is 1. For simplicity, I also follow the convention to always immediately call pop after extracting the top element from the stack.\n\nThe same approach also works for inorder traversal (that's the point). Here is a version where we visit each node three times: one to push the left child, one to process the node, and one to push the right child.\n\nIn fact, the second and third visits can be merged together: processing the node does not modify the stack, so the two visits are followed one after the other anyway. Here is my preferred version:\n\nFor completeness, here is the version found in most of my top Google hits (see this for a nice explanation):\n\nWhile it is shorter, it cannot be easily converted to postorder traversal, so it is not as flexible. Also, I find it easier to follow the execution flow with the visit-number flag.\n\nInorder traversal practice problems\n\nhttps://leetcode.com/problems/kth-smallest-element-in-a-bst/\n\nA solution (follow the link for the statement and examples):\n\nhttps://leetcode.com/problems/validate-binary-search-tree/\n\nA solution:\n\nPostorder traversal practice problems\n\nhttps://leetcode.com/problems/balanced-binary-tree/\n\nThis problem asks to check if a binary tree is balanced. It requires passing information back from the children to the parent node in a postorder traversal. Passing information from the children to the parent is easy with recursion. It can be done both with return values or with parameters passed by reference. For this problem we need to pass two things: a bool indicating if the subtree is balanced, and an int indicating its height. I use a reference parameter for the latter (returning a pair<bool,int> would be cleaner).\n\nPassing information from the children to the parent in an iterative implementation is more intricate. There are three general approaches:\n\nUse a hash table mapping each node to the information.\n\nThis is the easiest way, but also the most expensive. While the asymptotic runtime is still linear, hash tables generally have significant constant factors.\n\nAdd a field to the definition of the node structure for the information needed.\n\nThen, we can read it from the parent node by traversing the children's pointers. In Leetcode we cannot modify the TreeNode data structure so, to illustrate this approach, I build a new tree first with a new struct:\n\nPass the information through an additional stack.\n\nThis is the most efficient, but one must be careful to keep both stacks in synch. When processing a node, that node first pops the information from its children, and then pushes its own info for its parent. Here is a solution (with eager NULL-pointer detection):\n\nhttps://leetcode.com/problems/diameter-of-binary-tree/\n\nThis problem also requires passing information from the children to the parent in a postorder traversal. Here is a solution using the third approach again, but this time with lazy NULL-pointer detection. Note that we push a 0 to the depths stack when we extract a NULL pointer from the main stack, and during processing we always do two pops regardless of the number of non-NULL children:\n\nhttps://leetcode.com/problems/binary-tree-tilt/\n\nhttps://leetcode.com/problems/most-frequent-subtree-sum/\n\nhttps://leetcode.com/problems/maximum-product-of-splitted-binary-tree/\n\nTraversals in n-ary Trees\n\nSo far, we have looked at binary trees. In an n-ary tree, each node has an arbitrary number of children.\n\nFor n-ary trees, preorder traversal is also straightforward, and inorder traversal is not defined.\n\nFor postorder traversal, we can use a visit-number flag again. Two visits suffice for each node: one to push all the children into the stack, and another to process the node itself. I do not include the code here because it is very similar to the binary tree case.\n\nConsider a more complicated setting where we need to compute something at the node after visiting each child. Let's call this \"interleaved traversal\". I use process(node, i) as placeholder for the computation done before visiting the i-th child. Here is the recursive implementation and the corresponding iterative one using visit-number flags.\n\nN-ary tree practice problems\n\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/\n\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/\n\nAn Alternative Way of Passing the Visit Flag\n\nThe common framework to all our solutions has been to pass a visit-number flag along with the nodes on the stack. User \"heiswyd\" on leetcode posted here an alternative way to pass the flag implicitly: initially, it pushes each node on the stack twice. Then, it can distinguish between the first visit and the second visit by checking whether the node that has just been extracted from the stack matches the node on top of the stack. This happens only when we extract the first of the two occurrences. Post-order traversal looks like this:\n\nIt is cool, but I prefer passing the flag explicitly for clarity.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/iterativetreetraversal?category=dsa",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Heapify Analysis Without Math",
      "content": "Heapify Analysis Without Math\n\nI'm writing about heaps for Beyond Cracking the Coding Interview (beyondctci.com), and the most technical part is the analysis of heapify. It's easy to show that it takes O(n log n) time, where n is the number of nodes in the heap, but it's not straightforward to show that this is not tight and the method actually takes O(n). time.\n\nEvery proof I have found online involves a summation over the levels of the heap that ends up looking something like the one in Wikipedia heap page:\n\nwhich is more math than I want to put in this book (the bulk of the audience consists of people trying to land a SWE job, not math enthusiasts).\n\nBelow is the proof \"without complicated math\" I came up with that heapify takes O(n) time. If you are familiar with the classic proof, let me know if you find it easier - I might use it for the book. Also, please let me know if you've seen someone else proving it in a similar way.\n\nIf you already know what heapify is, you can jump directly to the Proof.\n\nHeaps are binary trees with two special properties:\n\nThey are complete binary trees: all the levels except the last one have the maximum number of nodes; the last level may not be full, but all the nodes are aligned to the left. (In particular, this implies that heaps have logarithmic height, which is key to the big O analysis.)\n\nThe heap property: every node is smaller than its children (this is assuming a min-heap - it would be the opposite for a max-heap).\n\nI will focus on the heapify operation and its analysis, but if you want to learn heaps from scratch, the Algorithms with Attitude Youtube channel has a great video on it. He also covered the classic linear-time proof for heapify, if you want to compare it to mine.\n\nIn any case, I left a full Python heap implementation at the bottom of this post.\n\nWhat's Heapify?\n\nHeapify (invented by Robert W. Floyd) converts a binary tree which is already complete, but may not have the heap property, into a proper heap.\n\nHeapify uses the \"bubble-down\" procedure, which starts at a node that may not satisfy the heap property, and recursively swaps it with the smallest of its two children until the heap property is restored:\n\nHeapify works by \"bubbling down\" every non-leaf (internal) node, from bottom to top:\n\nThis figure shows the heapify steps for a min-heap. The first tree is the initial state, which doesn't yet have the min-heap property. Leaves are already at the bottom, so bubbling them down has no effect. The next 3 trees show the evolution after bubbling down the two nodes at depth 1 and then the node at depth 0.\n\nIn the array-based heap implementation, heapify() looks like this:\n\nThe reason why we start bubbling down from the middle of the heap is that, in a complete tree, at least half the nodes are leaves, and we don't need to bubble those down.\n\nHere, we won't prove that it works, only that its analysis is O(n).\n\nI'll start with a definition and a fact we'll use later:\n\nA perfect binary tree is a complete tree where the last level is full:\n\nFact 1: In a perfect tree, the number of leaves is 1 more than the number of internal nodes.\n\nFor instance:\n\nFact 1 is true because the number of nodes at each level is a power of 2, so:\n\nthe number of leaves is a power of 2, and\n\nthe number of internal nodes is the sum of all the previous powers of 2.\n\nThe sum of the first few powers of 2 add up to one less than the next power of 2. You can see that if you line them up like this:\n\nIt's a bit like Zeno's paradox, where each power of 2 in the sum halves the remaining distance, but never quite gets to 64.\n\nWith that out of the way, back to heapify:\n\nIn the worst case, each node will get bubbled down all the way to a leaf. Thus, each node needs to move down O(log n) levels, so one might reasonably expect heapify to take O(n log n) time. This is correct in the 'upper bound' sense, but not tight: the total time is actually O(n). The intuition for why that is the case is that most nodes are in the deeper levels of the tree, where they don't need to travel a lot to get to the bottom.\n\nWe'll actually prove a stronger claim:\n\nMain Claim: If you heapify a perfect tree, the number of 'bubble-down' swaps is smaller than n, the number of nodes.\n\nWe'll assume the worst case, in which every node is bubbled down to a leaf position.\n\nIf the claim is true and heapify does <n swaps, then it takes O(n) time, since most bubble-down iterations involve a swap.\n\nWe make the claim about perfect trees (rather than complete trees in general) to keep things simple.\n\nThe proof goes like this:\n\nWhen the height is 1, the claim is true because the tree has 1 node and requires 0 swaps to heapify.\n\nEvery time we add a new level, the number of nodes increases more than the number of swaps (by one, to be exact).\n\nIf we can prove (2), together with (1) it implies the Main Claim because, as we add levels, the number of swaps can never catch up to the number of nodes.\n\nTo see why (2) is true, imagine we add a new level to a perfect tree:\n\nEvery preexisting node needs to bubble down one additional level, while the new leaves do not need to do to be bubbled down. Thus, the number of swaps increases by the number of preexisting nodes. But, another way of saying Fact 1 is that if you take a perfect tree and add a new level, the number of new/leaf nodes is 1 more than the number of preexisting/internal nodes.\n\nAnd that's the proof!\n\nAppendix: The Proof in Numbers\n\nWe can compute the actual number of swaps needed, in the worst case, for concrete heights:\n\nWe can see that the number of swaps never catches up with the root, per the Main Claim.\n\nWe can also show how the number of nodes grows vs the number of swaps:\n\nAppendix: Full heap implementation",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/heapify-analysis?category=dsa",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Breaking Down Dynamic Programming",
      "content": "Breaking Down Dynamic Programming\n\nNote: the approach in this guide later became the foundation for the dynamic programming chapter in Beyond Cracking the Coding Interview.\n\nIntroduction\n\nWhen I was a TA for \"Algorithm Design and Analysis\", the students struggled with dynamic programming. To simplify/demystify it, I tried to break it down into a logical sequence of steps, each of which should not feel too intimidating on its own. This is explained in detail here. To complement the explanations, there are links to problems on leetcode.com, in case the reader wants to practice. The code snippets are in Python, but Leetcode accepts most popular languages.\n\nOverview: Recursive vs Iterative DP\n\nIn short, dynamic programming (DP) is a technique for problems that seem hard to solve as a whole, but become easy if we know the solution to smaller subproblems. More technically, we can use it in problems where the (value of the) solution can be expressed as an equation which is a function of the input, and is expressed in terms of itself with smaller inputs. This is called a recurrence equation. The classic example is the Fibonacci recurrence: Fib(n) = Fib(n-1) + Fib(n-2).\n\nhttps://leetcode.com/problems/fibonacci-number/\n\nA recurrence equation can be translated into code:\n\nHowever, the above function has an exponential runtime. A recursive function becomes exponential when it is possible to reach the same subcall through different execution paths. In the Fibonacci case, we have the following nested calls: Fib(n) -> Fib(n-1) -> Fib(n-2), and Fib(n) -> Fib(n-2). Since Fib(n-2) is called twice all the work from this call is duplicated, which in turn means that subcalls made from Fib(n-2) will start to duplicate and grow exponentially.\n\nDynamic programming is simply a workaround to this duplication issue. Instead of recomputing the solutions of the subproblems, we store them and then we recall them as needed. This guarantees that each subproblem is computed only once.\n\nThere are two main approaches for DP.\n\nRecursive / Top-down DP\n\nWe start with the code which is a literal translation of the recurrence equation, but then we add a dictionary / hash table to store results.\n\nThere are three changes in the code above:\n\ndeclaring our dictionary for storing results, memo outside the recursive function (memo comes \"memorization\" or \"memoization\", a name used in the literature).\n\nbefore computing the result, we check if the solution has already been computed. This check can be done before or after the base case.\n\nbefore returning, we save the result in the memo table.\n\nUsing a memoization table in this way solves the inefficiency (we will go deeper into the analysis part later).\n\nIterative / Bottom-up DP\n\nInstead of starting from the largest input and recursively reaching smaller subproblems, we can directly compute the subproblems from smallest to largest. This way, we already have the solutions to the subproblems when we need them. For this approach, we change the dictionary for an array/vector, and we change recursive calls for a for loop.\n\nMost problems can be solved with both recursive and iterative DP. Here are some considerations for how to choose:\n\nRecursive DP matches the recurrence equation more directly, so it can be easier to implement.\n\nBoth have the same runtime complexity, but the recursive version will generally have larger constant factors due to all the recursive function calling and due to using a hash table instead of an array.\n\nIterative DP often allows for an optimization to reduce the space complexity (discussed later).\n\nRecursive DP in 5 Steps\n\nChoose what your subproblems are.\n\nFind the recurrence equation.\n\nTranslate the recurrence equation into recursive code.\n\nAdd memoization.\n\n(Optional) Reconstruct the solution.\n\nWe already saw steps 1–4 with the Fibonacci example. Now, we will walk through all the steps in more detail using a more complicated example, the longest common subsequence problem:\n\nGiven two strings s1 and s2, find the length of the longest string which is a subsequence of both s1 and s2. A string t is a subsequence of a string s if every char in t appears in order in s, but are not necessarily contiguous. For example, abc is a subsequence of axbyz, but ba is not (do not confuse subsequence with substring or subset).\n\nhttps://leetcode.com/problems/longest-common-subsequence/\n\nStep 1: choose our subproblems. This varies from problem to problem, but when the input to the problem is a string, a natural way to obtain smaller problems is to look at shorter strings. Here we can use as a subproblem a prefix of s1 and a prefix of s2.\n\nSome notation: let n be the length of s1 and m the length of s2. Let LCS(i,j) be the solution for the LCS problem for the prefix of s1 of length n (s1[0..i-1]) and the prefix of s2 of length m (s2[0..j-1]). Then, our goal is to find LCS(n, m).\n\nStep 2: find the recurrence equation. Now we need to come up with an expression for LCS(i,j) as a function of LCS with smaller indices (as well as a base case). This is the hardest step of DP, and often it is here that we realize that we chose bad subproblems in Step 1. If that happens, hopefully we will discover some hint for what our subproblems should be.\n\nIn order to derive the recurrence equation for LCS, we need the following observation: if the two strings end with the same character c, then, to maximize the length of the subsequence, it is \"safe\" to add c to the subsequence. In contrast, if both strings end with different characters, then at least one of them cannot appear in the subsequence. The complication is that we do not know which one. Thus, instead of guessing, we can simply consider both options.\n\nThis observation yields the recurrence equation (excluding base case):\n\nThis step is not intuitive at first, and requires practice. After having done a few problems, one starts to recognize the typical patterns in DP. For instance, using max among a set of options of which we do not know which one is the best is easily the most common pattern in DP.\n\nStep 3. Translate the recurrence equation into recursive code. This step is a very simple programming task. Pay attention to the base case.\n\nIf we draw the few first steps of the call graph, we will see that the same subproblem is reached twice. Thus, call graph blows up, leading to an exponential runtime.\n\nStep 4. Add memo table. This step should be automatic: one does not even need to understand the previous code in order to add the memo table.\n\nThe base case corresponds to when one of the strings is empty. The LCS of an empty string with another string is clearly an empty string.\n\nIncidentally, if we flip the check on the memo table, the code becomes a bit more streamlined (fewer lines + merging the two returns). I prefer this form (it does the same):\n\nWe have eliminated the exponential blowup. In general, DP algorithms can be analyzed as follows: # of distinct subproblems times time per subproblem excluding recursive calls. For LCS, we get O(nm)*O(1)=O(nm).\n\nStep 5. Reconstruct the solution.\n\nWe used DP to compute the length of the LCS. What if we want to find the LCS itself? A naive way to do it would be to store the entire result of each subproblem in the memoization table instead of just its length. While this works, it is clear that it will require a lot of memory to store O(nm) strings of length O(min(n,m)) each. We can do better.\n\nStep 5, \"Reconstruct the solution\", is how to reuse the table that we constructed in Step 4 to find the actual solution instead of just its length. I said that this step is optional because sometimes we just need the value of the solution, so there is no reconstruction needed.\n\nThe good news is that we do not need to modify the code that we already wrote in Step 4. The reconstruction is a separate step that comes after. In addition, the reconstruction step is very similar (follows the same set of cases) as the step of building the memo table. In short, we use the memo table as an \"oracle\" to guide us in our choices. Based on the values in the memo table, we know which option is better, so we know how to reconstruct the solution.\n\nIn the code above, first we run LCS(n,m) to fill the memo table. Then, we use it in the reconstruction. The condition memo[(i-1,j)] >= memo[(i,j-1)] tells us that we can obtain a longer or equal LCS by discarding a char from s1 instead of from s2.\n\nNote that there is a single recursive call in the reconstruction function, so the complexity is just O(n+m).\n\nIterative DP in 6 Steps\n\nChoose what your subproblems are.\n\nFind the recurrence equation.\n\nDesign the memo table.\n\nFill the memo table.\n\n(Optional) Reconstruct the solution.\n\n(Optional) Space optimization.\n\nThe new/different steps are highlighted. Step 3. is to design the layout of the table/matrix where we are going to store the subproblem solutions. There is no coding in this step. By \"design\", I mean making the following choices:\n\nwhat are the dimensions of the table, and what does each index mean. Generally speaking, the table should have one dimension for each parameter of the recurrence equation. In the case of LCS, it will be a 2-dimensional table.\n\nwhere are the base cases.\n\nwhere is the cell with the final solution.\n\nwhat is the ``dependence relationship'' between cells (which cells do you need in order to compute each cell).\n\nwhich cells do not need to be filled (in the case of LCS, we need them all).\n\nHere is how I would lay out the table for LCS (you can find a different layout in the problems below):\n\nNext (Step 4), we fill the memo table with a nested for loop. If the layout is good, this should be easy. Before the main loop, we fill the base case entries. Then, we must make sure to iterate through the table in an order that respects the dependencies between cells. In the case of LCS, we can iterate both by rows or by columns.\n\nWe obtain the following algorithm:\n\nIn the code above, the base case entries are filled implicitly when we initialize the table with zeros everywhere.\n\nIf we need to reconstruct the solution, we can do it in the same way as for the recursive DP. The only difference is that memo is a matrix instead of dictionary.\n\nSpace optimization\n\nClearly, the space complexity of iterative DP is the size of the DP table. Often, we can do better. The idea is to only store the already-computed table entries that we will use to compute future entries. For instance, in the case of Fibonacci, we do not need to create an entire array -- keeping the last two numbers suffice. In the case of a 2-dimensional DP table, if we are filling the DP table by rows and each cell only depends on the previous row, we only need to keep the last row (and similarly if we iterated by columns). Here is the final version for LCS where we improve the space complexity from O(nm) to O(n+m):\n\nNote: this optimization is incompatible with reconstructing the solution, because that uses the entire table as an \"oracle\".\n\nDP Patterns\n\nHere are some typical patterns:\n\nFor Step 1. The subproblems.\n\nIf the input is a string or a list, the subproblems are usually prefixes or substrings/sublists, which can be specified as a pair of indices.\n\nIf the input is a number, the subproblems are usually smaller numbers.\n\nGenerally speaking, the number of subproblems will be linear or quadratic on the input size.\n\nFor Step 2. The recurrence equation.\n\nOften, we use max or min to choose between options, or sum to aggregate subsolutions.\n\nThe number of subproblems is most often constant, but sometimes it is linear on the subproblem size. In the latter case, we use an inner loop to aggregate/choose the best solution.\n\nSometimes, the recurrence equation is not exactly for the original problem, but for a related but more constrained problem. See an example below, \"Longest Increasing Subsequence\".\n\nPractice Problems\n\nHere are some practice problems showcasing the patterns mentioned above. Follow the Leetcode links for the statements and example inputs. I jump directly to the solutions. I'd recommend trying to solve the problems before checking them.\n\nhttps://leetcode.com/problems/palindromic-substrings/\n\nHere, the goal is to count the number of substrings of a string s which are palindromic. There is a trivial O(n³) time solution without DP:\n\nWe can improve this to O(n²) with DP. The subproblems are all the substrings of s. Let Pal(i, j) be true iff s[i..j] is a palindrome. We have the following recurrence equation (excluding base cases):\n\nBased on this recurrence equation, we can design the following DP table:\n\nThis type of \"diagonal\" DP tables are very common when the subproblems are substrings/sublists. In this case, the base cases are substrings of length 1 or 2. The goal is Pal(0,n-1).\n\nGiven the dependency, the table can be filled by rows (starting from the last row), by columns (starting each column from the bottom), or by diagonals (i.e., from shortest to longest substrings). In the code below, I illustrate how to fill the table by diagonals.\n\nhttps://leetcode.com/problems/minimum-path-sum/\n\nHere, a subproblem can be a grid with reduced width and height. Let T[i][j] be the cheapest cost to reach cell (i,j). The goal is to find T[n-1][m-1], where n and m are the dimensions of the grid. The base case is when either i or j are zero, in which case we do not have any choices for how to get there. In the general case, we have the recurrence equation T[i][j] = grid[i][j] + min(T[i-1][j], T[i][j-1]): to get to (i,j), we first need to get to either (i-1,j) or to (i,j-1). We use min to choose the best of the two. We convert this into an iterative solution:\n\nhttps://leetcode.com/problems/unique-paths-ii/\n\nThis is similar to the previous problem, but we need to accumulate the solutions to the subproblems, instead of choosing between them. Problems about counting solutions can often be solved with DP.\n\nhttps://leetcode.com/problems/longest-increasing-subsequence/\n\nThis problem will illustrate a new trick: if you cannot find a recurrence equation for the original problem, try to find one for a more restricted version of the problem which nevertheless you enough information to compute the original problem.\n\nHere, the input is a list L of numbers, and we need to find the length of the longest increasing subsequence (a subsequence does not need to be contiguous). Again, the subproblems correspond to prefixes of the list. Let LIS(i) be the solution for the prefix of length i (L[0..i]). The goal is to find LIS(n-1), where n is the length of L. However, it is not easy to give a recurrence equation for LIS(i) as a function of smaller prefixes. In particular, the following is wrong (I will let the reader think why):\n\nThus, we actually give a recurrence equation for a slightly modified type of subproblems: let LIS2(i) be the length of the LIS ending at index i. This constraint makes it easier to give a recurrence equation:\n\nIn short, since we know that the LIS ends at L[i], we consider all candidate predecessors, which are the numbers smaller than it, and get the best one by using max. Crucially, this recurrence works for LIS2(i) but not for LIS(i). Here is a full solution:\n\nAt the end, we do not simply return T[n-1] because T is the table for LCS2, not LCS. We return max(T) because the LCS must end somewhere, so LCS(n-1) = LCS2(j) for some j < n.\n\nNote that the runtime is O(n²) even though the table has linear size. This is because we take linear time per subproblem.\n\nhttps://leetcode.com/problems/number-of-longest-increasing-subsequence/\n\nA harder version of the previous problem. A similar approach works. First solve the LIS problem as before, and then do a second pass to count the solutions.\n\nhttps://leetcode.com/problems/shortest-common-supersequence/\n\nThis problem is similar to LCS, and it requires reconstruction.\n\nI should mention that not every problem that can be solved with DP fits into the mold discussed above. Despite that, it should be a useful starting framework. Here are many more practice problems:\n\nhttps://leetcode.com/tag/dynamic-programming/",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/breaking-down-dynamic-programming?category=dsa",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Problem Solving BCtCI Style",
      "content": "Problem Solving BCtCI Style\n\nHere's a thought: You don't want the first time you think about the question \"What should I do if I get stuck in a coding interview?\" to be when you are stuck in a coding interview.\n\nIn a way, getting stuck in a coding interview is an opportunity. The main goal of the interview is to see your problem-solving thought process, and being stuck is the ideal time to showcase it.\n\nBut you want to be prepared. It's valuable to have a plan for this exact scenario. We all dread blanking out in an interview, but having a plan makes it easy to simply focus on executing it. So, let's talk about what such a plan could look like in this blog post.\n\nIn Beyond Cracking the Coding Interview, we go over all the steps in an interview, and our best tips to do well in each of them:\n\nIn this blog post, I'll zoom in on the problem-solving step, \"Design the Algorithm,\" and illustrate the thought process with a problem.\n\nAs you can see, we break it down into four steps:\n\nMinimally sketch the naive solution to establish a baseline.\n\nIdentify upper and lower bounds using big O analysis to narrow down the range of possible solutions.\n\nLook for triggers (Keywords) that point to a specific approach.\n\nEmploy boosters: problem-solving strategies that give you the \"boost\" you need when you are stuck.\n\nThese are not revolutionary ideas -- it's what good problem solvers do and think about instinctively. One of the main goals of the book, and of this blog post, is to spell out the thought process of people who are really good at this in a relatable way so that anyone can reproduce it.\n\nWe playfully call this the MIKE template (Minimally sketch brute force, Identify bounds, Keywords (triggers), Employ boosters) after Mike Mroczka, one of the authors of BCtCI.\n\nRather than expanding on these now, we'll see them in action with the following problem.\n\nProblem Statement\n\nThe problem is based on LeetCode 3458, which appeared in a recent contest. You can go and give it a try before reading on (it's labeled as medium, but I think it's on the harder end of medium). The thought process I'll walk through here is based on how I solved it during the contest.\n\nGiven a string s, a substring of s is special if any character in it does not appear outside it.\n\nFor example, if s is \"abcba\":\n\n\"bcb\" is a special substring because 'b' and 'c' do not appear in s outside \"bcb\".\n\n\"abc\" is not a special substring because 'a' appears in s outside \"abc\".\n\nGiven a string s consisting of n lowercase English letters, determine the maximum number of disjoint special substrings. Two substrings are disjoint if they do not overlap.\n\nConstraints:\n\n2 <= n <= 10^5\n\ns consists only of lowercase English letters.\n\nDigesting the problem\n\nFirst, we need to digest what the problem is asking. This problem follows a common pattern: it introduces a kind of esoteric definition, \"special substring\", and then asks us to do something with it.\n\nTo make sure we understand what a special substring is, it's good to look at a few examples, starting with the provided ones. For instance, in \"abcba\", do you understand why \"a\" is not special but \"c\" is?\n\nTake some time to come up with your own examples. Rushing to solving a problem before understanding it well is a common but often costly mistake.\n\nSometimes, it helps to tackle just one part of the problem first, so we can start making progress.\n\nWe can think of an algorithm with 2 parts:\n\nPart A: Find all the special substrings.\n\nPart B: Find the most non-overlapping special substrings.\n\nLet's start with part A.\n\nPart A: Find all the special substrings\n\nWe'll walk through the MIKE template.\n\nM: Minimally sketch brute force\n\nThe key here is to not overthink it. We just want to get the ball rolling and have a baseline we can improve upon.\n\nSince we don't want to spend too much time in an interview, you could even just describe the idea in a sentence and move on. But we prefer to briefly sketch it in very high-level pseudocode. We call it 'intended English': it's written like English, but with indentation to show the code structure:\n\nInterviews often involve considering trade offs between algorithms, so it's a good habit to give them names and list their time/space complexity.\n\nIn this case, the space complexity depends on how many special substrings we might find, which is not clear yet, so we'll leave it out for now.\n\nSketching the brute force solution helps us ensure we understand the problem (and if we are solving for the wrong thing, we give the interviewer a chance to let us know).\n\nI: Identify upper and lower bounds\n\nWe can use big O analysis to narrow down the range of possible solutions. An upper bound means \"we don't have to consider any solution that takes longer than this\", and a lower bound means the opposite: \"we don't have to consider any solution that takes less time than this\". In the book, we go over two ways of establishing an upper bound and two ways of establishing a lower bound:\n\nUpper bounds:\n\nBrute force upper bound: we just saw that we can find all special substrings in O(n^4) time, so we don't have to consider any solution that takes longer than that.\n\nTLE (Time Limit Exceeded) upper bound: here is where we use the problem constraints to establish an upper bound. The problem says that n <= 10^5, which usually means that O(n^2) solutions are too slow, but O(n log n) or faster solutions are fine.\n\nLower bounds:\n\nOutput-size lower bound: the space taken by the output is a lower bound for the time complexity, because that's how long it takes just to write the output. In our case, the output of the overall problem is just a number, so this lower bound is trivial: O(1). Bounds are not always useful!\n\nTask-based lower bound: some problems involve an inherent task that any solution must fulfill. The runtime of this task is a lower bound. In this case, we know we at least need to read every letter in the input, so we have a lower bound of O(n). In other words, we can rule out solutions that take O(log n) or O(1) time.\n\nCombining our findings, we can narrow down our search range to O(n log n) or O(n) algorithms (something like O(n log^2 n) would also be fine, it's just less common).\n\nK: Keywords (triggers)\n\nThere are certain properties of problems that point to a specific approach. Here are some triggers we can identify for this problem:\n\nfinding substrings -> sliding windows\n\nO(n log n) possible target complexity -> sorting or heaps\n\nUnfortunately, triggers are not a guarantee, and these triggers don't seem to help for this problem:\n\nIn sliding windows, once you move past a character, you don't later go back. So, in Example 1, it would be impossible to find both \"abcba\" and \"bcb\": if you find \"abcba\" first, the right pointer would have to go back to find \"bcb\". But if you find \"bcb\" first, the left pointer would have to go back to find \"abcba\".\n\nSorting doesn't seem like a good fit because the input order is important.\n\nDo you think I missed any other triggers?\n\nE: Employ boosters\n\nSo, triggers didn't help, and brute force is still far from the target complexity. It's time to employ boosters.\n\nHere's an overview:\n\nThe boosters are roughly ordered, but we don't always have to use them in order. In fact, here's a plot twist: what we did at the beginning, splitting the problem into two parts, is the third booster: Decrease the Difficulty -> Break Down the Problem.\n\nBooster 1: Brute force optimization\n\nThe first booster is straightforward: take the brute force pseudocode we already have and try to optimize it.\n\nIn the boosters diagram, we list three ways to go about it. One of them is the Data structure pattern. Many bottlenecks come from having to do some calculation inside a loop. In those situations, ask yourself,\n\n\"Do I know of any data structure which makes this type of operation faster?\"\n\nFor this problem, we can use a hash set to optimize the innermost loop:\n\nIf you have working code or pseudocode but think of an optimization or better approach, do NOT edit your code. Copy-paste it and work on a separate copy. This way, if you don't have time to finish or realize it's wrong, you'll still have the previous working version.\n\nBooster 2: Hunting for properties\n\nWe got down to O(n^3) time, but we know we still need to bring this down to the target complexity.\n\nLet's say we don't know how to optimize the code further. Often, the breakthrough comes from uncovering some \"hidden\" observation or property not explicitly mentioned in the statement. Our second booster is to go hunting for those.\n\nIn the book, we discuss a bunch of ways of doing this, but the most basic and effective one is to try to solve the problem manually with a non-trivial example. By non-trivial, we mean that is is not some weird edge case, which would not be helpful for figuring out a general algorithm.\n\nLet's actually do that: take s = \"mississippi\" and manually try to find all the special substrings.\n\nDon't overthink it. Don't think about algorithms yet. Just write them down.\n\nDone? Ok, now try to reverse-engineer what shortcuts your brain took. This is one property you may have noticed:\n\nProperty 1: a special substring must start at the first occurrence of a letter.\n\nYou may have noticed this property when your brain skipped over the second, third, or fourth 'i's in mississippi and intuitively realized that there is no special substring starting at those. Writing down the property formalizes this instinct and ropes in the interviewer.\n\nNow that we have a property, we have to find a way to use it. Property 1 allows us to optimize the outer loop: it means we only have 26 = O(1) possible starts to check (problems where the input consists of only lowercase letters often have optimizations like this).\n\nAs we iterate through the possible starts, we can track letters seen so far (e.g., in a hash set):\n\nWe like to write down the big O simplification (O(26 * n^2) = O(n^2)), so the interviewer doesn't think we missed steps.\n\nWe haven't hit our target time complexity yet, so let's keep hunting for properties. Here is another one:\n\nProperty 2: of all the special substrings that start at a given letter, we only care about the shortest one.\n\nOur ultimate goal is to find the most non-overlapping special substrings. If we can choose between two special substrings, one of which contains the other, it is always \"optimal\" or, at least, \"safe\" to pick the smaller one.\n\nFor instance, if s is \"baa\", we have two choices for special substrings starting at 'b': \"baa\" and \"b\". We should pick \"b\" so that the \"aa\" part can be in another disjoint special substring.\n\nAgain, when we find a property, we need to think of how to apply it. Property 2 means that, for each starting point i, we can grow a substring one letter at a time, and stop as we find the first special substring.\n\nLet's break this down a bit more: say you start at index i.\n\nIf you find a letter c that appears at some later point, we need to grow the substring up to that index.\n\nIf you find a letter c that appears before i, we can stop the search. No substring starting at i can be special.\n\nFor example, imagine i starts at the first 'b' in the following string:\n\nThat means we need to grow the substring at least up to the last 'b' in the string:\n\nAs we grow the substring, we hit an 'a', which appears before i, and we realize that no substring starting at i can be special.\n\nWe can now add this logic to our algorithm. We can start the algorithm by computing the first and last index of each letter (this is an example of the preprocessing pattern in the boosters diagram -- it's common for properties from Booster 2 to enable optimizations from Booster 1).\n\nThen, as we grow each substring, we keep track of the farthest index we need to reach. (This is actually a common pattern in sliding window algorithms, where we maintain information about the window as it 'slides', rather than computing it from scratch every time the window moves. So, the 'sliding windows' trigger wasn't completely off).\n\nWe got the time down to O(n). Since we hit the lower bound, we can be confident Part A is as good as it can be, and we can move on to Part B.\n\nPart B: Find the most non-overlapping special substrings\n\nLet's be honest: even if in the book we really emphasize developing your problem-solving skills by using the MIKE template and the boosters, knowing a bunch of leetcode questions DOES give you an edge in coding interviews. So, I'll tell you how I actually solved this problem in the contest. I realized that Part B is just a variation of a classic greedy problem: most non-overlapping intervals. Indeed, a substring can be seen as an interval of the string.\n\nThe \"most non-overlapping intervals\" problem is in BCtCI, so I already knew that it can be solved with a greedy algorithm that sorts the intervals by their end time and then iterates through them, picking the ones that don't overlap with the previous one (here is a similar problem on leetcode). This algorithm fits within our target time complexity, so I didn't have to think beyond that.\n\nIf I didn't already know the solution, I would have walked through the MIKE template again for Part B.\n\nFull implementation\n\nHere is a full implementation:\n\nYou may think that the bottleneck is the sorting, but it's not. Recall that there are only up to 26 special substrings (by Property 1). Sorting 26 intervals takes O(26 log 26) = O(1) time.\n\nI wanted to give an overview of all the high-level ideas for problem-solving in leetcode-style interviews. We could dive a lot deeper into any of those ideas, so this blog post may feel a bit rushed, but the meta-point is that you should have a plan for when you are stuck in an interview (and you should be following it during your practice sessions so it becomes second nature). It's not important that you use the MIKE template -- your plan should work for you. But the ideas covered in this post should probably be part of it.\n\nIf you have any comments, let me know on linkedin or X.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/problem-solving-bctci-style?category=dsa",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Get Binary Search Right Every Time, Explained Without Code",
      "content": "Get Binary Search Right Every Time, Explained Without Code\n\nOne of the things that makes binary search tricky to implement is that you usually need to tweak the pointer manipulation logic in subtle ways based on the specifics of the problem.\n\nE.g., an implementation that works for finding a target in a sorted array when the target is present, may not work if the target is missing. Or, it may not be clear how to tweak the code to find the last occurrence of the target instead of the first one. And of course, there are plenty of less conventional applications of binary search where the input is not an array, like catching bike thieves.\n\nIn Beyond Cracking the Coding Interview, we wanted to simplify this, so we went looking for a general binary search template. Going into it, I thought we might need at least two templates, but we ended up with just one, which we called the \"transition point recipe\", and which works for every problem we tried, including the 17 problems in the binary search chapter of the book. If you find one where it doesn't work, let me know!\n\nThe transition point problem\n\nHere is the thesis of the transition point recipe:\n\nEvery binary search problem can be reduced to the 'transition point problem'.\n\nIn the 'transition point problem', you are given an array with just two values, say 1 and 2, where all the 1s come before the 2s, and you need to point where it changes.\n\nE.g., in the array [1, 1, 1, 1, 1, 2, 2, 2], the last 1 is at index 4 and the first 2 is at index 5.\n\nKnowing how to solve this specific problem is key to our recipe. The specific binary search implementation is not important, but there is an invariant we can follow that makes it quite easy: ensure that the left pointer is always at a 1 and the right pointer is always at a 2.\n\nWe give code in the book, but remembering exact code in an interview is error prone. Instead, the four bullet points below are all I personally remember, and I feel confident that I can derive the rest easily.\n\nStart by handling some edge cases: The array is empty Every value is 1 Every value is 2\n\nThe array is empty\n\nEvery value is 1\n\nEvery value is 2\n\nInitialize two pointers, left and right, to the first and last indices, respectively.\n\nFor the main binary search loop, always maintain the invariant that the value at left is 1 and the value at right is 2. Let this invariant guide your pointer manipulation logic, so that you don't need to memorize any code.\n\nStop when the left and right pointers are next to each other (i.e., left + 1 == right).\n\nCombining the invariant with the stopping condition, we get that, at the end, left will be at the last 1 and right will be at the first 2.\n\nThese bullet points rely on two ideas to make binary search easier: (1) handling edge cases upfront, and (2) letting strong invariants guide the implementation. Notice how the invariant even guides the edge cases at the beginning, as they are the necessary ones to be able to initialize left and right in a way that satisfies it.\n\nThe reduction\n\nOk, so now, let's take for granted that we can solve the transition point problem. How does this help us solve other binary search problems?\n\nThe idea is to come up with a (problem-specific) predicate, like < target, >= target, or x % 2 == 0, which splits the search range into two regions, the \"before\" region and the \"after\" region.\n\nThis predicate is a function that takes an element of the search range and returns a boolean, and -- as you probably saw coming -- it is key that all the elements with true values come before the elements with false values (or the other way around).\n\nThen, we can use the solution to the transition point problem to find the transition point between the 'before' and 'after' regions. The only difference is that, instead of checking boolean values directly, we check the result of the predicate.\n\nYou can even wrap the predicate in a function, which we called is_before(x) in the book, which tells you whether a given element is in the 'before' region. Then, it's really obvious that we are just solving the transition point problem every time.\n\nThe only part that requires some thinking is choosing the right transition point. For example:\n\nif we want to find the first occurrence of target in a sorted array, we can use is_before(x) = x < target, which means that, if target is present, the first occurrence is the first element in the 'after' region (so, we can check/return the right pointer at the end).\n\nif we want to find the last occurrence of target in a sorted array, we can use is_before(x) = x <= target, which means that, if target is present, the last occurrence is the last element in the 'before' region (so, we can check/return the left pointer at the end).\n\nAnd so on for other problems.\n\nYou can try the transition-point recipe on all the problems from the binary search chapter of the book online at start.interviewing.io/beyond-ctci/part-vii-catalog/binary-search, even if you don't have the book. There, you can also find all our solutions using the recipe, in Python, JS, Java, and C++.\n\nBy the way, the binary search chapter of the book is free -- it's in bctci.co/free-chapters.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/binary-search",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Problem Solving BCtCI Style",
      "content": "Problem Solving BCtCI Style\n\nHere's a thought: You don't want the first time you think about the question \"What should I do if I get stuck in a coding interview?\" to be when you are stuck in a coding interview.\n\nIn a way, getting stuck in a coding interview is an opportunity. The main goal of the interview is to see your problem-solving thought process, and being stuck is the ideal time to showcase it.\n\nBut you want to be prepared. It's valuable to have a plan for this exact scenario. We all dread blanking out in an interview, but having a plan makes it easy to simply focus on executing it. So, let's talk about what such a plan could look like in this blog post.\n\nIn Beyond Cracking the Coding Interview, we go over all the steps in an interview, and our best tips to do well in each of them:\n\nIn this blog post, I'll zoom in on the problem-solving step, \"Design the Algorithm,\" and illustrate the thought process with a problem.\n\nAs you can see, we break it down into four steps:\n\nMinimally sketch the naive solution to establish a baseline.\n\nIdentify upper and lower bounds using big O analysis to narrow down the range of possible solutions.\n\nLook for triggers (Keywords) that point to a specific approach.\n\nEmploy boosters: problem-solving strategies that give you the \"boost\" you need when you are stuck.\n\nThese are not revolutionary ideas -- it's what good problem solvers do and think about instinctively. One of the main goals of the book, and of this blog post, is to spell out the thought process of people who are really good at this in a relatable way so that anyone can reproduce it.\n\nWe playfully call this the MIKE template (Minimally sketch brute force, Identify bounds, Keywords (triggers), Employ boosters) after Mike Mroczka, one of the authors of BCtCI.\n\nRather than expanding on these now, we'll see them in action with the following problem.\n\nProblem Statement\n\nThe problem is based on LeetCode 3458, which appeared in a recent contest. You can go and give it a try before reading on (it's labeled as medium, but I think it's on the harder end of medium). The thought process I'll walk through here is based on how I solved it during the contest.\n\nGiven a string s, a substring of s is special if any character in it does not appear outside it.\n\nFor example, if s is \"abcba\":\n\n\"bcb\" is a special substring because 'b' and 'c' do not appear in s outside \"bcb\".\n\n\"abc\" is not a special substring because 'a' appears in s outside \"abc\".\n\nGiven a string s consisting of n lowercase English letters, determine the maximum number of disjoint special substrings. Two substrings are disjoint if they do not overlap.\n\nConstraints:\n\n2 <= n <= 10^5\n\ns consists only of lowercase English letters.\n\nDigesting the problem\n\nFirst, we need to digest what the problem is asking. This problem follows a common pattern: it introduces a kind of esoteric definition, \"special substring\", and then asks us to do something with it.\n\nTo make sure we understand what a special substring is, it's good to look at a few examples, starting with the provided ones. For instance, in \"abcba\", do you understand why \"a\" is not special but \"c\" is?\n\nTake some time to come up with your own examples. Rushing to solving a problem before understanding it well is a common but often costly mistake.\n\nSometimes, it helps to tackle just one part of the problem first, so we can start making progress.\n\nWe can think of an algorithm with 2 parts:\n\nPart A: Find all the special substrings.\n\nPart B: Find the most non-overlapping special substrings.\n\nLet's start with part A.\n\nPart A: Find all the special substrings\n\nWe'll walk through the MIKE template.\n\nM: Minimally sketch brute force\n\nThe key here is to not overthink it. We just want to get the ball rolling and have a baseline we can improve upon.\n\nSince we don't want to spend too much time in an interview, you could even just describe the idea in a sentence and move on. But we prefer to briefly sketch it in very high-level pseudocode. We call it 'intended English': it's written like English, but with indentation to show the code structure:\n\nInterviews often involve considering trade offs between algorithms, so it's a good habit to give them names and list their time/space complexity.\n\nIn this case, the space complexity depends on how many special substrings we might find, which is not clear yet, so we'll leave it out for now.\n\nSketching the brute force solution helps us ensure we understand the problem (and if we are solving for the wrong thing, we give the interviewer a chance to let us know).\n\nI: Identify upper and lower bounds\n\nWe can use big O analysis to narrow down the range of possible solutions. An upper bound means \"we don't have to consider any solution that takes longer than this\", and a lower bound means the opposite: \"we don't have to consider any solution that takes less time than this\". In the book, we go over two ways of establishing an upper bound and two ways of establishing a lower bound:\n\nUpper bounds:\n\nBrute force upper bound: we just saw that we can find all special substrings in O(n^4) time, so we don't have to consider any solution that takes longer than that.\n\nTLE (Time Limit Exceeded) upper bound: here is where we use the problem constraints to establish an upper bound. The problem says that n <= 10^5, which usually means that O(n^2) solutions are too slow, but O(n log n) or faster solutions are fine.\n\nLower bounds:\n\nOutput-size lower bound: the space taken by the output is a lower bound for the time complexity, because that's how long it takes just to write the output. In our case, the output of the overall problem is just a number, so this lower bound is trivial: O(1). Bounds are not always useful!\n\nTask-based lower bound: some problems involve an inherent task that any solution must fulfill. The runtime of this task is a lower bound. In this case, we know we at least need to read every letter in the input, so we have a lower bound of O(n). In other words, we can rule out solutions that take O(log n) or O(1) time.\n\nCombining our findings, we can narrow down our search range to O(n log n) or O(n) algorithms (something like O(n log^2 n) would also be fine, it's just less common).\n\nK: Keywords (triggers)\n\nThere are certain properties of problems that point to a specific approach. Here are some triggers we can identify for this problem:\n\nfinding substrings -> sliding windows\n\nO(n log n) possible target complexity -> sorting or heaps\n\nUnfortunately, triggers are not a guarantee, and these triggers don't seem to help for this problem:\n\nIn sliding windows, once you move past a character, you don't later go back. So, in Example 1, it would be impossible to find both \"abcba\" and \"bcb\": if you find \"abcba\" first, the right pointer would have to go back to find \"bcb\". But if you find \"bcb\" first, the left pointer would have to go back to find \"abcba\".\n\nSorting doesn't seem like a good fit because the input order is important.\n\nDo you think I missed any other triggers?\n\nE: Employ boosters\n\nSo, triggers didn't help, and brute force is still far from the target complexity. It's time to employ boosters.\n\nHere's an overview:\n\nThe boosters are roughly ordered, but we don't always have to use them in order. In fact, here's a plot twist: what we did at the beginning, splitting the problem into two parts, is the third booster: Decrease the Difficulty -> Break Down the Problem.\n\nBooster 1: Brute force optimization\n\nThe first booster is straightforward: take the brute force pseudocode we already have and try to optimize it.\n\nIn the boosters diagram, we list three ways to go about it. One of them is the Data structure pattern. Many bottlenecks come from having to do some calculation inside a loop. In those situations, ask yourself,\n\n\"Do I know of any data structure which makes this type of operation faster?\"\n\nFor this problem, we can use a hash set to optimize the innermost loop:\n\nIf you have working code or pseudocode but think of an optimization or better approach, do NOT edit your code. Copy-paste it and work on a separate copy. This way, if you don't have time to finish or realize it's wrong, you'll still have the previous working version.\n\nBooster 2: Hunting for properties\n\nWe got down to O(n^3) time, but we know we still need to bring this down to the target complexity.\n\nLet's say we don't know how to optimize the code further. Often, the breakthrough comes from uncovering some \"hidden\" observation or property not explicitly mentioned in the statement. Our second booster is to go hunting for those.\n\nIn the book, we discuss a bunch of ways of doing this, but the most basic and effective one is to try to solve the problem manually with a non-trivial example. By non-trivial, we mean that is is not some weird edge case, which would not be helpful for figuring out a general algorithm.\n\nLet's actually do that: take s = \"mississippi\" and manually try to find all the special substrings.\n\nDon't overthink it. Don't think about algorithms yet. Just write them down.\n\nDone? Ok, now try to reverse-engineer what shortcuts your brain took. This is one property you may have noticed:\n\nProperty 1: a special substring must start at the first occurrence of a letter.\n\nYou may have noticed this property when your brain skipped over the second, third, or fourth 'i's in mississippi and intuitively realized that there is no special substring starting at those. Writing down the property formalizes this instinct and ropes in the interviewer.\n\nNow that we have a property, we have to find a way to use it. Property 1 allows us to optimize the outer loop: it means we only have 26 = O(1) possible starts to check (problems where the input consists of only lowercase letters often have optimizations like this).\n\nAs we iterate through the possible starts, we can track letters seen so far (e.g., in a hash set):\n\nWe like to write down the big O simplification (O(26 * n^2) = O(n^2)), so the interviewer doesn't think we missed steps.\n\nWe haven't hit our target time complexity yet, so let's keep hunting for properties. Here is another one:\n\nProperty 2: of all the special substrings that start at a given letter, we only care about the shortest one.\n\nOur ultimate goal is to find the most non-overlapping special substrings. If we can choose between two special substrings, one of which contains the other, it is always \"optimal\" or, at least, \"safe\" to pick the smaller one.\n\nFor instance, if s is \"baa\", we have two choices for special substrings starting at 'b': \"baa\" and \"b\". We should pick \"b\" so that the \"aa\" part can be in another disjoint special substring.\n\nAgain, when we find a property, we need to think of how to apply it. Property 2 means that, for each starting point i, we can grow a substring one letter at a time, and stop as we find the first special substring.\n\nLet's break this down a bit more: say you start at index i.\n\nIf you find a letter c that appears at some later point, we need to grow the substring up to that index.\n\nIf you find a letter c that appears before i, we can stop the search. No substring starting at i can be special.\n\nFor example, imagine i starts at the first 'b' in the following string:\n\nThat means we need to grow the substring at least up to the last 'b' in the string:\n\nAs we grow the substring, we hit an 'a', which appears before i, and we realize that no substring starting at i can be special.\n\nWe can now add this logic to our algorithm. We can start the algorithm by computing the first and last index of each letter (this is an example of the preprocessing pattern in the boosters diagram -- it's common for properties from Booster 2 to enable optimizations from Booster 1).\n\nThen, as we grow each substring, we keep track of the farthest index we need to reach. (This is actually a common pattern in sliding window algorithms, where we maintain information about the window as it 'slides', rather than computing it from scratch every time the window moves. So, the 'sliding windows' trigger wasn't completely off).\n\nWe got the time down to O(n). Since we hit the lower bound, we can be confident Part A is as good as it can be, and we can move on to Part B.\n\nPart B: Find the most non-overlapping special substrings\n\nLet's be honest: even if in the book we really emphasize developing your problem-solving skills by using the MIKE template and the boosters, knowing a bunch of leetcode questions DOES give you an edge in coding interviews. So, I'll tell you how I actually solved this problem in the contest. I realized that Part B is just a variation of a classic greedy problem: most non-overlapping intervals. Indeed, a substring can be seen as an interval of the string.\n\nThe \"most non-overlapping intervals\" problem is in BCtCI, so I already knew that it can be solved with a greedy algorithm that sorts the intervals by their end time and then iterates through them, picking the ones that don't overlap with the previous one (here is a similar problem on leetcode). This algorithm fits within our target time complexity, so I didn't have to think beyond that.\n\nIf I didn't already know the solution, I would have walked through the MIKE template again for Part B.\n\nFull implementation\n\nHere is a full implementation:\n\nYou may think that the bottleneck is the sorting, but it's not. Recall that there are only up to 26 special substrings (by Property 1). Sorting 26 intervals takes O(26 log 26) = O(1) time.\n\nI wanted to give an overview of all the high-level ideas for problem-solving in leetcode-style interviews. We could dive a lot deeper into any of those ideas, so this blog post may feel a bit rushed, but the meta-point is that you should have a plan for when you are stuck in an interview (and you should be following it during your practice sessions so it becomes second nature). It's not important that you use the MIKE template -- your plan should work for you. But the ideas covered in this post should probably be part of it.\n\nIf you have any comments, let me know on linkedin or X.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/problem-solving-bctci-style",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Heapify Analysis Without Math",
      "content": "Heapify Analysis Without Math\n\nI'm writing about heaps for Beyond Cracking the Coding Interview (beyondctci.com), and the most technical part is the analysis of heapify. It's easy to show that it takes O(n log n) time, where n is the number of nodes in the heap, but it's not straightforward to show that this is not tight and the method actually takes O(n). time.\n\nEvery proof I have found online involves a summation over the levels of the heap that ends up looking something like the one in Wikipedia heap page:\n\nwhich is more math than I want to put in this book (the bulk of the audience consists of people trying to land a SWE job, not math enthusiasts).\n\nBelow is the proof \"without complicated math\" I came up with that heapify takes O(n) time. If you are familiar with the classic proof, let me know if you find it easier - I might use it for the book. Also, please let me know if you've seen someone else proving it in a similar way.\n\nIf you already know what heapify is, you can jump directly to the Proof.\n\nHeaps are binary trees with two special properties:\n\nThey are complete binary trees: all the levels except the last one have the maximum number of nodes; the last level may not be full, but all the nodes are aligned to the left. (In particular, this implies that heaps have logarithmic height, which is key to the big O analysis.)\n\nThe heap property: every node is smaller than its children (this is assuming a min-heap - it would be the opposite for a max-heap).\n\nI will focus on the heapify operation and its analysis, but if you want to learn heaps from scratch, the Algorithms with Attitude Youtube channel has a great video on it. He also covered the classic linear-time proof for heapify, if you want to compare it to mine.\n\nIn any case, I left a full Python heap implementation at the bottom of this post.\n\nWhat's Heapify?\n\nHeapify (invented by Robert W. Floyd) converts a binary tree which is already complete, but may not have the heap property, into a proper heap.\n\nHeapify uses the \"bubble-down\" procedure, which starts at a node that may not satisfy the heap property, and recursively swaps it with the smallest of its two children until the heap property is restored:\n\nHeapify works by \"bubbling down\" every non-leaf (internal) node, from bottom to top:\n\nThis figure shows the heapify steps for a min-heap. The first tree is the initial state, which doesn't yet have the min-heap property. Leaves are already at the bottom, so bubbling them down has no effect. The next 3 trees show the evolution after bubbling down the two nodes at depth 1 and then the node at depth 0.\n\nIn the array-based heap implementation, heapify() looks like this:\n\nThe reason why we start bubbling down from the middle of the heap is that, in a complete tree, at least half the nodes are leaves, and we don't need to bubble those down.\n\nHere, we won't prove that it works, only that its analysis is O(n).\n\nI'll start with a definition and a fact we'll use later:\n\nA perfect binary tree is a complete tree where the last level is full:\n\nFact 1: In a perfect tree, the number of leaves is 1 more than the number of internal nodes.\n\nFor instance:\n\nFact 1 is true because the number of nodes at each level is a power of 2, so:\n\nthe number of leaves is a power of 2, and\n\nthe number of internal nodes is the sum of all the previous powers of 2.\n\nThe sum of the first few powers of 2 add up to one less than the next power of 2. You can see that if you line them up like this:\n\nIt's a bit like Zeno's paradox, where each power of 2 in the sum halves the remaining distance, but never quite gets to 64.\n\nWith that out of the way, back to heapify:\n\nIn the worst case, each node will get bubbled down all the way to a leaf. Thus, each node needs to move down O(log n) levels, so one might reasonably expect heapify to take O(n log n) time. This is correct in the 'upper bound' sense, but not tight: the total time is actually O(n). The intuition for why that is the case is that most nodes are in the deeper levels of the tree, where they don't need to travel a lot to get to the bottom.\n\nWe'll actually prove a stronger claim:\n\nMain Claim: If you heapify a perfect tree, the number of 'bubble-down' swaps is smaller than n, the number of nodes.\n\nWe'll assume the worst case, in which every node is bubbled down to a leaf position.\n\nIf the claim is true and heapify does <n swaps, then it takes O(n) time, since most bubble-down iterations involve a swap.\n\nWe make the claim about perfect trees (rather than complete trees in general) to keep things simple.\n\nThe proof goes like this:\n\nWhen the height is 1, the claim is true because the tree has 1 node and requires 0 swaps to heapify.\n\nEvery time we add a new level, the number of nodes increases more than the number of swaps (by one, to be exact).\n\nIf we can prove (2), together with (1) it implies the Main Claim because, as we add levels, the number of swaps can never catch up to the number of nodes.\n\nTo see why (2) is true, imagine we add a new level to a perfect tree:\n\nEvery preexisting node needs to bubble down one additional level, while the new leaves do not need to do to be bubbled down. Thus, the number of swaps increases by the number of preexisting nodes. But, another way of saying Fact 1 is that if you take a perfect tree and add a new level, the number of new/leaf nodes is 1 more than the number of preexisting/internal nodes.\n\nAnd that's the proof!\n\nAppendix: The Proof in Numbers\n\nWe can compute the actual number of swaps needed, in the worst case, for concrete heights:\n\nWe can see that the number of swaps never catches up with the root, per the Main Claim.\n\nWe can also show how the number of nodes grows vs the number of swaps:\n\nAppendix: Full heap implementation",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/heapify-analysis",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Iterative Tree Traversals: A Practical Guide",
      "content": "Iterative Tree Traversals: A Practical Guide\n\nIntroduction\n\nI don't know how often tree traversals come up in actual software projects, but they are popular in coding interviews and competitive programming. In this article, I share an approach for implementing tree traversal algorithms iteratively that I found to be simple to remember and implement, while being flexible enough to do anything that a recursive algorithm can (I also didn't like most suggestions I saw online). The main technique is given in section \"Iterative Postorder and Inorder Traversal\", but first I give some context. I also link to practice problems on leetcode.com for the reader to play with. I provide some solutions, but I suggest trying the problems out first. The code snippets are in C++, but leetcode accepts most languages.\n\nWhat are Tree Traversals\n\nMathematically, trees are just connected acyclic graphs. However, in the context of tree traversals, we are usually working with rooted trees represented with a recursive structure such as the following (which is the default definition in Leetcode for binary trees). A leaf is a node with two null pointers as children:\n\nA tree traversal is an algorithm that visits every node in a tree in a specific order (and does some computation with them, depending on the problem). For binary trees specifically, there are three important orders:\n\nPreorder: root before children. As we will see, this is the simplest to implement.\n\nInorder: left child, then root, then right child. This traversal is most often used on binary search trees (BST). A BST is a rooted binary tree with the additional property that every node in the left subtree has a smaller value than the root, and every node in the right subtree has a larger value than the root. This traversal is called \"inorder\" because, when used on a BST, it will visit the nodes from smallest to largest.\n\nPostorder: children before root. It comes up in problems where we have to aggregate information about the entire subtree rooted at each node. Classic examples are computing the size, the height, or the sum of values of the tree.\n\nBecause rooted trees are recursive data structures, algorithms on trees are most naturally expressed recursively. Here are the three traversals. I use the function process(node) as a placeholder for whatever computation the problem calls for.\n\nSide-note: in C++, pointers are implicitly converted to booleans: a pointer evaluates to true if and only if it is not null. So, in the code above, \"if (!root)\" is equivalent to \"if (root == NULL)\".\n\nTraversal problems on leetcode\n\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/\n\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/\n\nWhy / When to Use an Iterative Traversal\n\nIf the recursive implementation is so simple, why bother with an iterative one? Of course, to avoid stack overflow. Most runtime engines/compilers set a limit on how many nested calls a program can make. For example, according to this article:\n\nDefault stack size varies between 320k and 1024k depending on the version of Java and the system used. For a 64 bits Java 8 program with minimal stack usage, the maximum number of nested method calls is about 7000.\n\nDefault stack size varies between 320k and 1024k depending on the version of Java and the system used. For a 64 bits Java 8 program with minimal stack usage, the maximum number of nested method calls is about 7000.\n\nIf the height of the tree is larger than this limit, the program will crash with a stack overflow error. A recursive implementation is safe to use if:\n\nSomehow we know that the input trees will be small enough.\n\nThe tree is balanced, which means that, for each node, the left and right subtrees have roughly the same height. In a balanced tree, the height is guaranteed to be logarithmic on the number of nodes (indeed, that is why balanced BSTs guarantee O(log n) search time), so any tree that fits in RAM (or even disk) will require a tiny number of recursive calls.\n\nHowever, if we are not in either of the cases above, an iterative solution is safer.\n\nRecursive and iterative traversals have the same runtime complexity, so this is not a concern when choosing either (all the problems shown in this article can be solved in linear time using either).\n\nThe main approach for converting recursive implementations to iterative ones is to \"simulate\" the call stack with an actual stack where we push and pop the nodes explicitly. This works great \"out-of-the-box\" with preorder traversal.\n\nIncidentally, when implementing tree traversals we need to make an implementation choice about how to handle NULL pointers. We can be eager and filter them out before adding them to the stack, or we can be lazy and detect them once we extract them from the stack. Both are fine—what matters is to be deliberate and consistent about which approach we are using. I prefer the latter as it yields slightly shorter code, so I will use it in all the following examples. For comparison, here is the iterative preorder traversal with both approaches:\n\nNote that the right child is pushed to the stack before the left one. This is because we want the left child to be above in the stack so that it is processed first.\n\nPreorder traversal practice problems\n\nhttps://leetcode.com/problems/invert-binary-tree/\n\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/\n\nThis problem asks to find the depth of a binary tree (follow the link for the description and examples). It requires passing information from each node to its children. We can do this by changing the stack to stack<pair<TreeNode*, int>>, so that we can pass an int to each child, as in the solution below:\n\nIn the code above, the {} notation is used to create pairs (e.g., {root, 0}). If one is not familiar with pairs in C++, or is using a language without the equivalent, a simple alternative is to use two separate stacks, one for the nodes and one for the info.\n\nThe next two problems are similar:\n\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/\n\nhttps://leetcode.com/problems/path-sum/\n\nhttps://leetcode.com/problems/symmetric-tree/\n\nA solution for the last one, this time using a stack with a pair of nodes:\n\nIterative Postorder and Inorder Traversal\n\nWhile iterative preorder traversal is straightforward, with postorder and inorder we run into a complication: we cannot simply swap the order of the lines as with the recursive implementation. In other words, the following does not yield a postorder traversal:\n\nThe node is still processed before its children, which is not what we want.\n\nThe workaround, once again emulating the recursive implementation, is to visit each node twice. We consider postorder traversal first. In the first visit, we only push the children onto the stack. In the second visit, we do the actual processing. The simplest way to do this is to enhance the stack with a \"visit number flag\". Implementation-wise, we change the stack to stack<pair<TreeNode*, int>> so that we can pass the flag along with each node. The iterative postorder looks like this:\n\nNote the order in which the nodes are added to the stack when visit == 0. The parent ends up under its children, with the left child on top. Since it is the first time that the children are added to the stack, their visit-number flag is 0. For the parent, it is 1. For simplicity, I also follow the convention to always immediately call pop after extracting the top element from the stack.\n\nThe same approach also works for inorder traversal (that's the point). Here is a version where we visit each node three times: one to push the left child, one to process the node, and one to push the right child.\n\nIn fact, the second and third visits can be merged together: processing the node does not modify the stack, so the two visits are followed one after the other anyway. Here is my preferred version:\n\nFor completeness, here is the version found in most of my top Google hits (see this for a nice explanation):\n\nWhile it is shorter, it cannot be easily converted to postorder traversal, so it is not as flexible. Also, I find it easier to follow the execution flow with the visit-number flag.\n\nInorder traversal practice problems\n\nhttps://leetcode.com/problems/kth-smallest-element-in-a-bst/\n\nA solution (follow the link for the statement and examples):\n\nhttps://leetcode.com/problems/validate-binary-search-tree/\n\nA solution:\n\nPostorder traversal practice problems\n\nhttps://leetcode.com/problems/balanced-binary-tree/\n\nThis problem asks to check if a binary tree is balanced. It requires passing information back from the children to the parent node in a postorder traversal. Passing information from the children to the parent is easy with recursion. It can be done both with return values or with parameters passed by reference. For this problem we need to pass two things: a bool indicating if the subtree is balanced, and an int indicating its height. I use a reference parameter for the latter (returning a pair<bool,int> would be cleaner).\n\nPassing information from the children to the parent in an iterative implementation is more intricate. There are three general approaches:\n\nUse a hash table mapping each node to the information.\n\nThis is the easiest way, but also the most expensive. While the asymptotic runtime is still linear, hash tables generally have significant constant factors.\n\nAdd a field to the definition of the node structure for the information needed.\n\nThen, we can read it from the parent node by traversing the children's pointers. In Leetcode we cannot modify the TreeNode data structure so, to illustrate this approach, I build a new tree first with a new struct:\n\nPass the information through an additional stack.\n\nThis is the most efficient, but one must be careful to keep both stacks in synch. When processing a node, that node first pops the information from its children, and then pushes its own info for its parent. Here is a solution (with eager NULL-pointer detection):\n\nhttps://leetcode.com/problems/diameter-of-binary-tree/\n\nThis problem also requires passing information from the children to the parent in a postorder traversal. Here is a solution using the third approach again, but this time with lazy NULL-pointer detection. Note that we push a 0 to the depths stack when we extract a NULL pointer from the main stack, and during processing we always do two pops regardless of the number of non-NULL children:\n\nhttps://leetcode.com/problems/binary-tree-tilt/\n\nhttps://leetcode.com/problems/most-frequent-subtree-sum/\n\nhttps://leetcode.com/problems/maximum-product-of-splitted-binary-tree/\n\nTraversals in n-ary Trees\n\nSo far, we have looked at binary trees. In an n-ary tree, each node has an arbitrary number of children.\n\nFor n-ary trees, preorder traversal is also straightforward, and inorder traversal is not defined.\n\nFor postorder traversal, we can use a visit-number flag again. Two visits suffice for each node: one to push all the children into the stack, and another to process the node itself. I do not include the code here because it is very similar to the binary tree case.\n\nConsider a more complicated setting where we need to compute something at the node after visiting each child. Let's call this \"interleaved traversal\". I use process(node, i) as placeholder for the computation done before visiting the i-th child. Here is the recursive implementation and the corresponding iterative one using visit-number flags.\n\nN-ary tree practice problems\n\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/\n\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/\n\nAn Alternative Way of Passing the Visit Flag\n\nThe common framework to all our solutions has been to pass a visit-number flag along with the nodes on the stack. User \"heiswyd\" on leetcode posted here an alternative way to pass the flag implicitly: initially, it pushes each node on the stack twice. Then, it can distinguish between the first visit and the second visit by checking whether the node that has just been extracted from the stack matches the node on top of the stack. This happens only when we extract the first of the two occurrences. Post-order traversal looks like this:\n\nIt is cool, but I prefer passing the flag explicitly for clarity.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/iterativetreetraversal?category=dsa#iterative-postorder-and-inorder-traversal",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Heapify Analysis Without Math",
      "content": "Heapify Analysis Without Math\n\nI'm writing about heaps for Beyond Cracking the Coding Interview (beyondctci.com), and the most technical part is the analysis of heapify. It's easy to show that it takes O(n log n) time, where n is the number of nodes in the heap, but it's not straightforward to show that this is not tight and the method actually takes O(n). time.\n\nEvery proof I have found online involves a summation over the levels of the heap that ends up looking something like the one in Wikipedia heap page:\n\nwhich is more math than I want to put in this book (the bulk of the audience consists of people trying to land a SWE job, not math enthusiasts).\n\nBelow is the proof \"without complicated math\" I came up with that heapify takes O(n) time. If you are familiar with the classic proof, let me know if you find it easier - I might use it for the book. Also, please let me know if you've seen someone else proving it in a similar way.\n\nIf you already know what heapify is, you can jump directly to the Proof.\n\nHeaps are binary trees with two special properties:\n\nThey are complete binary trees: all the levels except the last one have the maximum number of nodes; the last level may not be full, but all the nodes are aligned to the left. (In particular, this implies that heaps have logarithmic height, which is key to the big O analysis.)\n\nThe heap property: every node is smaller than its children (this is assuming a min-heap - it would be the opposite for a max-heap).\n\nI will focus on the heapify operation and its analysis, but if you want to learn heaps from scratch, the Algorithms with Attitude Youtube channel has a great video on it. He also covered the classic linear-time proof for heapify, if you want to compare it to mine.\n\nIn any case, I left a full Python heap implementation at the bottom of this post.\n\nWhat's Heapify?\n\nHeapify (invented by Robert W. Floyd) converts a binary tree which is already complete, but may not have the heap property, into a proper heap.\n\nHeapify uses the \"bubble-down\" procedure, which starts at a node that may not satisfy the heap property, and recursively swaps it with the smallest of its two children until the heap property is restored:\n\nHeapify works by \"bubbling down\" every non-leaf (internal) node, from bottom to top:\n\nThis figure shows the heapify steps for a min-heap. The first tree is the initial state, which doesn't yet have the min-heap property. Leaves are already at the bottom, so bubbling them down has no effect. The next 3 trees show the evolution after bubbling down the two nodes at depth 1 and then the node at depth 0.\n\nIn the array-based heap implementation, heapify() looks like this:\n\nThe reason why we start bubbling down from the middle of the heap is that, in a complete tree, at least half the nodes are leaves, and we don't need to bubble those down.\n\nHere, we won't prove that it works, only that its analysis is O(n).\n\nI'll start with a definition and a fact we'll use later:\n\nA perfect binary tree is a complete tree where the last level is full:\n\nFact 1: In a perfect tree, the number of leaves is 1 more than the number of internal nodes.\n\nFor instance:\n\nFact 1 is true because the number of nodes at each level is a power of 2, so:\n\nthe number of leaves is a power of 2, and\n\nthe number of internal nodes is the sum of all the previous powers of 2.\n\nThe sum of the first few powers of 2 add up to one less than the next power of 2. You can see that if you line them up like this:\n\nIt's a bit like Zeno's paradox, where each power of 2 in the sum halves the remaining distance, but never quite gets to 64.\n\nWith that out of the way, back to heapify:\n\nIn the worst case, each node will get bubbled down all the way to a leaf. Thus, each node needs to move down O(log n) levels, so one might reasonably expect heapify to take O(n log n) time. This is correct in the 'upper bound' sense, but not tight: the total time is actually O(n). The intuition for why that is the case is that most nodes are in the deeper levels of the tree, where they don't need to travel a lot to get to the bottom.\n\nWe'll actually prove a stronger claim:\n\nMain Claim: If you heapify a perfect tree, the number of 'bubble-down' swaps is smaller than n, the number of nodes.\n\nWe'll assume the worst case, in which every node is bubbled down to a leaf position.\n\nIf the claim is true and heapify does <n swaps, then it takes O(n) time, since most bubble-down iterations involve a swap.\n\nWe make the claim about perfect trees (rather than complete trees in general) to keep things simple.\n\nThe proof goes like this:\n\nWhen the height is 1, the claim is true because the tree has 1 node and requires 0 swaps to heapify.\n\nEvery time we add a new level, the number of nodes increases more than the number of swaps (by one, to be exact).\n\nIf we can prove (2), together with (1) it implies the Main Claim because, as we add levels, the number of swaps can never catch up to the number of nodes.\n\nTo see why (2) is true, imagine we add a new level to a perfect tree:\n\nEvery preexisting node needs to bubble down one additional level, while the new leaves do not need to do to be bubbled down. Thus, the number of swaps increases by the number of preexisting nodes. But, another way of saying Fact 1 is that if you take a perfect tree and add a new level, the number of new/leaf nodes is 1 more than the number of preexisting/internal nodes.\n\nAnd that's the proof!\n\nAppendix: The Proof in Numbers\n\nWe can compute the actual number of swaps needed, in the worst case, for concrete heights:\n\nWe can see that the number of swaps never catches up with the root, per the Main Claim.\n\nWe can also show how the number of nodes grows vs the number of swaps:\n\nAppendix: Full heap implementation",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/heapify-analysis?category=dsa#proof",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Nil's Blog",
      "content": "Teaching DS&A · research highlights · SWE thoughts · building in public\n\nStay in the loop\n\nI'd love to tell you when I publish a new post.\n\nGet notified when I write about DS&A or software engineering. Unsubscribe anytime if it's not your vibe.\n\nDouble-Edge Cut Problem\n\nAn optimal solution for a graph problem that comes up in the Wall Game.\n\nSingle-Edge Cut Problem\n\nA linear-time algorithm for a graph problem that comes up in the Wall Game.\n\nThe Wall Game Project\n\nAn introduction to the Wall Game, my new project.\n\nWall Game DB Design\n\nDesigning the DB for the Wall Game.\n\nChoosing a tech stack in 2025\n\nHow would you build a Lichess clone in 2025? My process for picking a tech stack.\n\nWall Game UI Design (+ Frontend Generators)\n\nThe specs of the UI for the Wall Game and renders from frontend generators.\n\nLifecycle of a CS research paper: my knight's tour paper\n\nThe backstory and thought process behind a fun paper from my PhD.\n\nMy family during the Spanish Civil War\n\nMy grandparents' story during the Spanish Civil War.\n\nIn Defense of Coding Interviews\n\nA collection of arguments in favor of coding interviews.\n\nGet Binary Search Right Every Time, Explained Without Code\n\nA binary search recipe that works for every problem, explained without code.\n\nWhat Vibe Coding Actually Looks Like (prompts included)\n\nThe exact prompts used to create an interactive 3D torus visualization app with vibe coding.\n\nA topology/geometry puzzle\n\nExploring the geometry of merging faces.\n\nProblem Solving BCtCI Style\n\nA problem walkthrough using the concepts from Beyond Cracking the Coding Interview.\n\nHeapify Analysis Without Math\n\nA proof that heapify takes linear time without using complex equations.\n\nNegative Binary Search and Choir Rehearsal\n\nA curious application of binary search.\n\nLazy vs Eager Algorithms\n\nExploring the tradeoffs between lazy and eager implementations of common algorithms.\n\nActually Implementing Dijkstra's Algorithm\n\nA comprehensive guide to different implementations of Dijkstra's algorithm, with code.\n\nReachability Problems and DFS\n\nAn extensive list of questions that can be solved with DFS.\n\nWhy Many Greedy Algorithms Are Pickier Than They Need To Be\n\nMany greedy algorithms can be modified to make local rather than global choices while still producing the same solutions.\n\nBreaking Down Dynamic Programming\n\nA step-by-step guide to understanding and implementing dynamic programming algorithms with practical examples.\n\nIterative Tree Traversals: A Practical Guide\n\nA guide to implementing preorder, inorder, and postorder tree traversals iteratively.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Heapify Analysis Without Math",
      "content": "Heapify Analysis Without Math\n\nI'm writing about heaps for Beyond Cracking the Coding Interview (beyondctci.com), and the most technical part is the analysis of heapify. It's easy to show that it takes O(n log n) time, where n is the number of nodes in the heap, but it's not straightforward to show that this is not tight and the method actually takes O(n). time.\n\nEvery proof I have found online involves a summation over the levels of the heap that ends up looking something like the one in Wikipedia heap page:\n\nwhich is more math than I want to put in this book (the bulk of the audience consists of people trying to land a SWE job, not math enthusiasts).\n\nBelow is the proof \"without complicated math\" I came up with that heapify takes O(n) time. If you are familiar with the classic proof, let me know if you find it easier - I might use it for the book. Also, please let me know if you've seen someone else proving it in a similar way.\n\nIf you already know what heapify is, you can jump directly to the Proof.\n\nHeaps are binary trees with two special properties:\n\nThey are complete binary trees: all the levels except the last one have the maximum number of nodes; the last level may not be full, but all the nodes are aligned to the left. (In particular, this implies that heaps have logarithmic height, which is key to the big O analysis.)\n\nThe heap property: every node is smaller than its children (this is assuming a min-heap - it would be the opposite for a max-heap).\n\nI will focus on the heapify operation and its analysis, but if you want to learn heaps from scratch, the Algorithms with Attitude Youtube channel has a great video on it. He also covered the classic linear-time proof for heapify, if you want to compare it to mine.\n\nIn any case, I left a full Python heap implementation at the bottom of this post.\n\nWhat's Heapify?\n\nHeapify (invented by Robert W. Floyd) converts a binary tree which is already complete, but may not have the heap property, into a proper heap.\n\nHeapify uses the \"bubble-down\" procedure, which starts at a node that may not satisfy the heap property, and recursively swaps it with the smallest of its two children until the heap property is restored:\n\nHeapify works by \"bubbling down\" every non-leaf (internal) node, from bottom to top:\n\nThis figure shows the heapify steps for a min-heap. The first tree is the initial state, which doesn't yet have the min-heap property. Leaves are already at the bottom, so bubbling them down has no effect. The next 3 trees show the evolution after bubbling down the two nodes at depth 1 and then the node at depth 0.\n\nIn the array-based heap implementation, heapify() looks like this:\n\nThe reason why we start bubbling down from the middle of the heap is that, in a complete tree, at least half the nodes are leaves, and we don't need to bubble those down.\n\nHere, we won't prove that it works, only that its analysis is O(n).\n\nI'll start with a definition and a fact we'll use later:\n\nA perfect binary tree is a complete tree where the last level is full:\n\nFact 1: In a perfect tree, the number of leaves is 1 more than the number of internal nodes.\n\nFor instance:\n\nFact 1 is true because the number of nodes at each level is a power of 2, so:\n\nthe number of leaves is a power of 2, and\n\nthe number of internal nodes is the sum of all the previous powers of 2.\n\nThe sum of the first few powers of 2 add up to one less than the next power of 2. You can see that if you line them up like this:\n\nIt's a bit like Zeno's paradox, where each power of 2 in the sum halves the remaining distance, but never quite gets to 64.\n\nWith that out of the way, back to heapify:\n\nIn the worst case, each node will get bubbled down all the way to a leaf. Thus, each node needs to move down O(log n) levels, so one might reasonably expect heapify to take O(n log n) time. This is correct in the 'upper bound' sense, but not tight: the total time is actually O(n). The intuition for why that is the case is that most nodes are in the deeper levels of the tree, where they don't need to travel a lot to get to the bottom.\n\nWe'll actually prove a stronger claim:\n\nMain Claim: If you heapify a perfect tree, the number of 'bubble-down' swaps is smaller than n, the number of nodes.\n\nWe'll assume the worst case, in which every node is bubbled down to a leaf position.\n\nIf the claim is true and heapify does <n swaps, then it takes O(n) time, since most bubble-down iterations involve a swap.\n\nWe make the claim about perfect trees (rather than complete trees in general) to keep things simple.\n\nThe proof goes like this:\n\nWhen the height is 1, the claim is true because the tree has 1 node and requires 0 swaps to heapify.\n\nEvery time we add a new level, the number of nodes increases more than the number of swaps (by one, to be exact).\n\nIf we can prove (2), together with (1) it implies the Main Claim because, as we add levels, the number of swaps can never catch up to the number of nodes.\n\nTo see why (2) is true, imagine we add a new level to a perfect tree:\n\nEvery preexisting node needs to bubble down one additional level, while the new leaves do not need to do to be bubbled down. Thus, the number of swaps increases by the number of preexisting nodes. But, another way of saying Fact 1 is that if you take a perfect tree and add a new level, the number of new/leaf nodes is 1 more than the number of preexisting/internal nodes.\n\nAnd that's the proof!\n\nAppendix: The Proof in Numbers\n\nWe can compute the actual number of swaps needed, in the worst case, for concrete heights:\n\nWe can see that the number of swaps never catches up with the root, per the Main Claim.\n\nWe can also show how the number of nodes grows vs the number of swaps:\n\nAppendix: Full heap implementation",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/heapify-analysis#proof",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Reachability Problems and DFS",
      "content": "Reachability Problems and DFS\n\nIntroduction\n\nDepth-first search, or DFS, is a fundamental graph algorithm that can be used to solve reachability problems. This post shows how to adapt the basic DFS template to solve several problems of this kind. Reachability problems are often easier in undirected graphs. Below, we specify if the algorithm works for undirected graphs, directed graphs, or both.\n\nPrerequisites\n\nWe assume that the reader is already familiar with the concept of DFS. Here is an excellent video introducing DFS with step-by-step animations. We also assume that the reader is familiar with the adjacency list representation of a graph, and we use big-O notation in the analysis.\n\nCoding conventions\n\nThe algorithms below are in Python. n denotes the number of nodes. Nodes are identified with integers in the range 0..n-1. The graph G is a graph stored as an adjacency list: G is a list of n lists. For each v between 0 and n-1, G[v] is the list of neighbors of G.\n\nIf the graph is given as an edge list instead, we can initialize it as follows:\n\nIf the graph is given as an adjacency matrix, we can iterate through the rows of the adjacency matrix instead of through the adjacency lists. To iterate through the neighbors of a node v, instead of\n\nNote that using an adjacency matrix affects the runtime analysis of DFS: O(n²) instead of O(m).\n\nWhich nodes can be reached from node s?\n\nThis is the simplest question that can be answered with DFS. The primary data structure in DFS is a list of booleans to keep track of already visited nodes (we call it vis). If we start a DFS search from a node s, the reachable nodes will be the ones for which vis is true.\n\nFor this, G can be directed or undirected. We make use of a nested function in Python so that we do not need to pass G and vis as parameters (in Python nested functions have visibility over the variables in the scope where they are defined).\n\nDFS runs in O(m) time and O(n) space, where m is the number of edges. This is because each edge is considered twice, once from each endpoint, if the endpoints end up being visited, or zero times if the endpoints are not visited.\n\nIterative version\n\nThe iterative version takes O(m) space instead of O(n) because nodes can be inserted into the stack multiple times (up to one time for each incident edge). Alternatively, we can mark the nodes as visited when we add them to the stack instead of when we remove them. This change reduces the space usage to the usual O(n). However, with this change, the algorithm is no longer DFS. It still works for answering reachability questions because the set visited nodes is the same, but the order in which they are visited is no longer consistent with a depth-first search order (it is closer to a BFS (breath-first search) order, but also not exactly a BFS order).\n\nThe difference between marking nodes when they added vs removed from the stack is discussed in detail here. Since the recursive version is shorter and optimal in terms of space, we favor it from now on. That said, it should be easy to adapt the iterative version above to the problems below.\n\nCan node s reach node t?\n\nWe use the same code from before, but we add early termination as soon as we see t. Now, the recursive function has a return value.\n\nAdding the early termination can make the DFS faster, but in the worst-case the time/space complexity is the same.\n\nPractice problems\n\nhttps://leetcode.com/problems/the-maze/\n\nThe hardest part on this problem is constructing the graph in the first place.\n\nFind a path from s to t\n\nThe edges \"traversed\" in a DFS search form a tree called the \"DFS tree\". The DFS tree changes depending on where we start the search. The starting node is called the root. We can construct the DFS tree by keeping track of the predecessor of each node in the search (the root has no predecessor). If we construct the DFS tree rooted at s, we can follow the sequence of predecessors from t to s to find a path from s to t in reverse order.\n\nInstead of using the list vis to keep track of visited nodes, we know a node is unvisited if it has no predecessor yet. We indicate that a node has no predecessor with the special value -1.\n\nNote that DFS does not find the shortest path form s to t. For that, we can use BFS (breath-first search). It just returns any path without repeated nodes.\n\nIs the graph connected?\n\nFor undirected graphs, this is almost the same question as the first question (\"which nodes can be reached by s?\") because of the following property:\n\nAn undirected graph is connected if and only if every node can be reached from s, where s is any of the nodes.\n\nThus, the code is exactly the same as for the first question, with two differences: 1) we choose s to be 0 (could be anything), and 2) we change the last line to check if every entry in vis is true.\n\nFor directed graphs, we need to take into account the direction of the edges. A directed graph is strongly connected if every node can reach every other node. We can use the following property:\n\nA directed graph is strongly connected if and only if s can reach every node and every node can reach s, where s is any of the nodes.\n\nWe already know how to use DFS to check if s can reach every node. To check if every node can reach s, we can do a DFS starting from s, but in the reverse graph of G. The reverse graph of G is like G but reversing the directions of all the edges.\n\nThe runtime is still O(m), but the space is now O(m) because we need to create and store the reverse graph. There are alternative algorithms (like Tarjan's algorithm) which can do this in O(n) space.\n\nHow many connected components are there?\n\nWe can use the typical DFS to answer this question for undirected graphs. We use a common pattern in DFS algorithms: an outer loop through all the nodes where we launch a search for every yet-unvisited node.\n\nThe runtime is now O(n+m) because, if m < n, we still spend O(n) time iterating through the loop at the end.\n\nFor directed graphs, instead of connected components, we talk about strongly connected components. A strongly connected component is a maximal subset of nodes where every node can reach every other node.\n\nIf we want to find the number of strongly connected components, we can use something like Tarjan's algorithm, a DFS-based algorithm that requires some additional data structures.\n\nPractice problems\n\nhttps://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/ (Premium only)\n\nhttps://leetcode.com/problems/number-of-islands/\n\nhttps://leetcode.com/problems/friend-circles/\n\nWhich nodes are in the same connected components?\n\nThis question is more general than the previous two. We label each node v with a number CC[v] so that nodes with the same number belong to the same CC. Instead of having a list CC in addition to vis, we use the CC number -1 to indicate unvisited nodes. This way, we do not need vis\n\nFor directed graphs, again we need Tarjan's algorithm or an equivalent algorithm.\n\nPractice problems\n\nhttps://leetcode.com/problems/max-area-of-island/\n\nhttps://leetcode.com/problems/sentence-similarity-ii/\n\nIn the second problem, nodes are given by names, not indices, so they need to be converted.\n\nIs the graph acyclic?\n\nFor undirected graphs, this question is simple. First, we consider the problem in each CC independently. This is very common pattern in graph problems. We do this with an outer loop through all the nodes where we launch a search for every yet-unvisited node.\n\nDuring the DFS search in each CC, if we find an edge to an already visited node that is not the predecessor in the search (the node we just came from), there is a cycle. Such edges in a DFS search are called back edges. We add one parameter to the recursive function visit to know the predecessor node.\n\nFor directed graphs, it is not as simple: the fact that a neighbor nbr is already visited during the DFS search does not mean that nbr can reach the current node. To check if a directed graph is acyclic, we can use the linear-time peel-off algorithm for finding a topological ordering. This algorithm detects if the graph is acyclic and finds a topological ordering if so, though we are only interested in the first part.\n\nPractice problems\n\nhttps://leetcode.com/problems/redundant-connection/\n\nThis problem is easier to solve using union-find, but it can be done with DFS.\n\nIs the graph a tree?\n\nUsually, we ask this question for undirected graphs. We can use this characterization of trees:\n\nAn undirected graph is a tree if and only if it is connected and has exactly n-1 edges.\n\nWe already saw how to check if the graph is connected with DFS, and counting the number of edges is straightforward:\n\nPractice problems\n\nhttps://leetcode.com/problems/graph-valid-tree/\n\nIs the graph bipartite?\n\nThis is exactly the same question as whether the graph can be two-colored, so see the next section.\n\nCan the graph be two-colored?\n\nTwo-coloring a graph means assigning colors to the nodes such that no two adjacent nodes have the same color, using only two colors. Usually, we consider coloring question for undirected graphs.\n\nWe consider whether each CC can be colored independently from the others. We can color each CC using DFS. We use values 0 and 1 for the colors. The color of the start node can be anything, so we set it to 0. For the remaining nodes, the color has to be different from the parent, so we only have one option.\n\nInstead of having a vis array, we use the special color -1 to denote unvisited nodes.\n\nWith 3 or more colors, the problem becomes a lot harder.\n\nPractice problems\n\nhttps://leetcode.com/problems/is-graph-bipartite/\n\nWhat is the distance from a node s to every other node in a tree?\n\nWe cannot use DFS to find the distance between nodes in a graph which can have cycles, because DFS is not guaranteed to follow the shortest path from the root to the other nodes. For that, BFS is more suitable (if the graph is unweighted). However, since trees are acyclic, there is a unique path between any two nodes, so DFS must use the unique path, which, by necessity, is the shortest path. Thus, we can use DFS to find distances in a tree.\n\nPractice problems\n\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/\n\nFind a spanning tree\n\nA spanning tree of a connected, undirected graph G is a subgraph which has the same nodes as G that is a tree. The edges traversed by a DFS search on a connected graph form a spanning tree (sometimes called a DFS tree). Thus, we do DFS and add the traversed edges to the resulting tree.\n\nConclusions\n\nDFS has many uses. We showed how to make minor modifications to the DFS template to answer reachability and connectivity questions.\n\nAfter DFS, the next algorithm to learn would be BFS (breath-first search). Like DFS, it can answer reachability questions. On top of that, it can also answer questions about distance in undirected graphs.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/reachability-problems-and-dfs",
      "author": "",
      "user_id": ""
    },
    {
      "title": "The Wall Game Project",
      "content": "The Wall Game Project\n\nWelcome to the Wall Game project! The Wall Game is a multiplayer board game I invented, and which I'm building in public in 2025.\n\nIn this post, I'll go over how to play, my approach to building in public, and the backstory of the game. Once finished, it will be available at wallgame.io.\n\n\"Why are you building this?\"\n\nFirst of all, because I think it's a great game. I've shown it to many people over the years, and the reaction is always that (1) it's fun; and (2) it's super easy to pick up (it passes the subway-legibility test).\n\nOn a more personal note, my goal for 2025 is to get better at building things, and I believe that working on things you find fun is key for consistency.\n\nRules of the game\n\nThe Wall Game is simple to understand.\n\nInitial setup: In the \"standard\" 2-player version of the Wall Game, the board setup looks like this:\n\nGoal: The red player controls the red cat and mouse, and the blue player controls the blue cat and mouse. The red player wins by having their cat catch the blue mouse before the blue cat catches the red mouse.\n\nHow to move: the game is turn-based. On each turn, you can make 2 actions. Each action can be either moving your cat, moving your mouse, or placing a wall. Cats and mice move to adjacent cells, but walls can be placed anywhere between two cells on the board. The only restriction is that you cannot completely block the opponent's cat from reaching your mouse.\n\nThat's it! That's all the rules. It's simple enough that you can play it with just pen and paper.\n\nTo preempt the two most common questions:\n\nMoving diagonally counts as 2 actions.\n\nYou cannot move through your own walls.\n\nExample game\n\nHere is an example of a full game that was played on wallwars.net (the first version of the site, which I'm currently rebuilding).\n\nBuilding in public\n\nI love the concept of building in public, sharing my learnings, and getting feedback. If nothing else, writing down my thought process helps future-me reference what I learned.\n\nSo, as I build it, I'm making a series of blog posts about the game. You can find them all at nilmamano.com/blog/category/wallgame.\n\nSo far, I've written about:\n\nChoosing a tech stack\n\nDesigning the UI\n\nDesigning the DB\n\nThe graph algorithms behind invalid move detection (Part 1, Part 2)\n\nNext, I'll write about Deep Wallwars, an alpha-zero-like AI made by a friend, as well as other interesting aspects of the app's implementation, like automatic puzzle generation.\n\nUltimately, this collection of posts should provide a playbook for building any multiplayer online game, not just the Wall Game.\n\nThe game dates back to my high school days, circa 2006, when my friends and I entertained ourselves with pen-and-paper games. Around that time, I played Quoridor once at a friend's house, and that inspired me to make a pen-and-paper game with similar ideas but with my own rules, like having two actions per move and unlimited walls. After some experimentation, we settled on a 10x12 board, with players starting at the top corners and having to move to their opposite corners (there was no \"mouse\" yet).\n\nThe game was a hit among my high-school friends, and I've basically been playing it and showing it to people ever since. For example, the name WallWars, which I used until the recent rebranding to the Wall Game, was coined by a PhD colleague in 2016 (let me know which name you like more).\n\nIn 2012, during college, I implemented a version of the game in Python (it's on GitHub):\n\nHowever, that version was not online, so, in 2020, I reimplemented it as a full-stack app to play with my friends during the Covid-19 lockdowns. It's currently live at wallwars.net. According to the DB, 421 online games have been played as of May 2025 (I'm the most active player by far).\n\nIn 2021, I started building a C++ minimax-based engine for the game, which you can play against on wallwars.net thanks to WebAssembly. Optimizing it was a challenge, as the branching factor is much higher than, e.g., in chess. Eventually, I got it to work well for small boards, but it was still not good enough for the exponential explosion that comes from bigger boards. That's when Thorben came to the rescue with the Deep Wallwars project, an alpha-zero-like engine that scales a lot better to bigger boards. This is not integrated on the site yet, but it's planned for the rebuild.\n\nIn 2023, I built a physical board to play in person:\n\nWe started experimenting with different variants, in part to accommodate 4 players, but also because we realized that exploring variants of the rule increased the game's replayability. As long as the same strategic and tactical patterns are present, variants are really fun, like playing a new level of a video game. This is also when I adopted the \"cat and mouse\" variant as the default.\n\nTwo of the main reasons I want to rebuild the site are to integrate Deep Wallwars and to support variants, as each of these would require a major overhaul.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-intro",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Iterative Tree Traversals: A Practical Guide",
      "content": "Iterative Tree Traversals: A Practical Guide\n\nIntroduction\n\nI don't know how often tree traversals come up in actual software projects, but they are popular in coding interviews and competitive programming. In this article, I share an approach for implementing tree traversal algorithms iteratively that I found to be simple to remember and implement, while being flexible enough to do anything that a recursive algorithm can (I also didn't like most suggestions I saw online). The main technique is given in section \"Iterative Postorder and Inorder Traversal\", but first I give some context. I also link to practice problems on leetcode.com for the reader to play with. I provide some solutions, but I suggest trying the problems out first. The code snippets are in C++, but leetcode accepts most languages.\n\nWhat are Tree Traversals\n\nMathematically, trees are just connected acyclic graphs. However, in the context of tree traversals, we are usually working with rooted trees represented with a recursive structure such as the following (which is the default definition in Leetcode for binary trees). A leaf is a node with two null pointers as children:\n\nA tree traversal is an algorithm that visits every node in a tree in a specific order (and does some computation with them, depending on the problem). For binary trees specifically, there are three important orders:\n\nPreorder: root before children. As we will see, this is the simplest to implement.\n\nInorder: left child, then root, then right child. This traversal is most often used on binary search trees (BST). A BST is a rooted binary tree with the additional property that every node in the left subtree has a smaller value than the root, and every node in the right subtree has a larger value than the root. This traversal is called \"inorder\" because, when used on a BST, it will visit the nodes from smallest to largest.\n\nPostorder: children before root. It comes up in problems where we have to aggregate information about the entire subtree rooted at each node. Classic examples are computing the size, the height, or the sum of values of the tree.\n\nBecause rooted trees are recursive data structures, algorithms on trees are most naturally expressed recursively. Here are the three traversals. I use the function process(node) as a placeholder for whatever computation the problem calls for.\n\nSide-note: in C++, pointers are implicitly converted to booleans: a pointer evaluates to true if and only if it is not null. So, in the code above, \"if (!root)\" is equivalent to \"if (root == NULL)\".\n\nTraversal problems on leetcode\n\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/\n\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/\n\nWhy / When to Use an Iterative Traversal\n\nIf the recursive implementation is so simple, why bother with an iterative one? Of course, to avoid stack overflow. Most runtime engines/compilers set a limit on how many nested calls a program can make. For example, according to this article:\n\nDefault stack size varies between 320k and 1024k depending on the version of Java and the system used. For a 64 bits Java 8 program with minimal stack usage, the maximum number of nested method calls is about 7000.\n\nDefault stack size varies between 320k and 1024k depending on the version of Java and the system used. For a 64 bits Java 8 program with minimal stack usage, the maximum number of nested method calls is about 7000.\n\nIf the height of the tree is larger than this limit, the program will crash with a stack overflow error. A recursive implementation is safe to use if:\n\nSomehow we know that the input trees will be small enough.\n\nThe tree is balanced, which means that, for each node, the left and right subtrees have roughly the same height. In a balanced tree, the height is guaranteed to be logarithmic on the number of nodes (indeed, that is why balanced BSTs guarantee O(log n) search time), so any tree that fits in RAM (or even disk) will require a tiny number of recursive calls.\n\nHowever, if we are not in either of the cases above, an iterative solution is safer.\n\nRecursive and iterative traversals have the same runtime complexity, so this is not a concern when choosing either (all the problems shown in this article can be solved in linear time using either).\n\nThe main approach for converting recursive implementations to iterative ones is to \"simulate\" the call stack with an actual stack where we push and pop the nodes explicitly. This works great \"out-of-the-box\" with preorder traversal.\n\nIncidentally, when implementing tree traversals we need to make an implementation choice about how to handle NULL pointers. We can be eager and filter them out before adding them to the stack, or we can be lazy and detect them once we extract them from the stack. Both are fine—what matters is to be deliberate and consistent about which approach we are using. I prefer the latter as it yields slightly shorter code, so I will use it in all the following examples. For comparison, here is the iterative preorder traversal with both approaches:\n\nNote that the right child is pushed to the stack before the left one. This is because we want the left child to be above in the stack so that it is processed first.\n\nPreorder traversal practice problems\n\nhttps://leetcode.com/problems/invert-binary-tree/\n\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/\n\nThis problem asks to find the depth of a binary tree (follow the link for the description and examples). It requires passing information from each node to its children. We can do this by changing the stack to stack<pair<TreeNode*, int>>, so that we can pass an int to each child, as in the solution below:\n\nIn the code above, the {} notation is used to create pairs (e.g., {root, 0}). If one is not familiar with pairs in C++, or is using a language without the equivalent, a simple alternative is to use two separate stacks, one for the nodes and one for the info.\n\nThe next two problems are similar:\n\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/\n\nhttps://leetcode.com/problems/path-sum/\n\nhttps://leetcode.com/problems/symmetric-tree/\n\nA solution for the last one, this time using a stack with a pair of nodes:\n\nIterative Postorder and Inorder Traversal\n\nWhile iterative preorder traversal is straightforward, with postorder and inorder we run into a complication: we cannot simply swap the order of the lines as with the recursive implementation. In other words, the following does not yield a postorder traversal:\n\nThe node is still processed before its children, which is not what we want.\n\nThe workaround, once again emulating the recursive implementation, is to visit each node twice. We consider postorder traversal first. In the first visit, we only push the children onto the stack. In the second visit, we do the actual processing. The simplest way to do this is to enhance the stack with a \"visit number flag\". Implementation-wise, we change the stack to stack<pair<TreeNode*, int>> so that we can pass the flag along with each node. The iterative postorder looks like this:\n\nNote the order in which the nodes are added to the stack when visit == 0. The parent ends up under its children, with the left child on top. Since it is the first time that the children are added to the stack, their visit-number flag is 0. For the parent, it is 1. For simplicity, I also follow the convention to always immediately call pop after extracting the top element from the stack.\n\nThe same approach also works for inorder traversal (that's the point). Here is a version where we visit each node three times: one to push the left child, one to process the node, and one to push the right child.\n\nIn fact, the second and third visits can be merged together: processing the node does not modify the stack, so the two visits are followed one after the other anyway. Here is my preferred version:\n\nFor completeness, here is the version found in most of my top Google hits (see this for a nice explanation):\n\nWhile it is shorter, it cannot be easily converted to postorder traversal, so it is not as flexible. Also, I find it easier to follow the execution flow with the visit-number flag.\n\nInorder traversal practice problems\n\nhttps://leetcode.com/problems/kth-smallest-element-in-a-bst/\n\nA solution (follow the link for the statement and examples):\n\nhttps://leetcode.com/problems/validate-binary-search-tree/\n\nA solution:\n\nPostorder traversal practice problems\n\nhttps://leetcode.com/problems/balanced-binary-tree/\n\nThis problem asks to check if a binary tree is balanced. It requires passing information back from the children to the parent node in a postorder traversal. Passing information from the children to the parent is easy with recursion. It can be done both with return values or with parameters passed by reference. For this problem we need to pass two things: a bool indicating if the subtree is balanced, and an int indicating its height. I use a reference parameter for the latter (returning a pair<bool,int> would be cleaner).\n\nPassing information from the children to the parent in an iterative implementation is more intricate. There are three general approaches:\n\nUse a hash table mapping each node to the information.\n\nThis is the easiest way, but also the most expensive. While the asymptotic runtime is still linear, hash tables generally have significant constant factors.\n\nAdd a field to the definition of the node structure for the information needed.\n\nThen, we can read it from the parent node by traversing the children's pointers. In Leetcode we cannot modify the TreeNode data structure so, to illustrate this approach, I build a new tree first with a new struct:\n\nPass the information through an additional stack.\n\nThis is the most efficient, but one must be careful to keep both stacks in synch. When processing a node, that node first pops the information from its children, and then pushes its own info for its parent. Here is a solution (with eager NULL-pointer detection):\n\nhttps://leetcode.com/problems/diameter-of-binary-tree/\n\nThis problem also requires passing information from the children to the parent in a postorder traversal. Here is a solution using the third approach again, but this time with lazy NULL-pointer detection. Note that we push a 0 to the depths stack when we extract a NULL pointer from the main stack, and during processing we always do two pops regardless of the number of non-NULL children:\n\nhttps://leetcode.com/problems/binary-tree-tilt/\n\nhttps://leetcode.com/problems/most-frequent-subtree-sum/\n\nhttps://leetcode.com/problems/maximum-product-of-splitted-binary-tree/\n\nTraversals in n-ary Trees\n\nSo far, we have looked at binary trees. In an n-ary tree, each node has an arbitrary number of children.\n\nFor n-ary trees, preorder traversal is also straightforward, and inorder traversal is not defined.\n\nFor postorder traversal, we can use a visit-number flag again. Two visits suffice for each node: one to push all the children into the stack, and another to process the node itself. I do not include the code here because it is very similar to the binary tree case.\n\nConsider a more complicated setting where we need to compute something at the node after visiting each child. Let's call this \"interleaved traversal\". I use process(node, i) as placeholder for the computation done before visiting the i-th child. Here is the recursive implementation and the corresponding iterative one using visit-number flags.\n\nN-ary tree practice problems\n\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/\n\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/\n\nAn Alternative Way of Passing the Visit Flag\n\nThe common framework to all our solutions has been to pass a visit-number flag along with the nodes on the stack. User \"heiswyd\" on leetcode posted here an alternative way to pass the flag implicitly: initially, it pushes each node on the stack twice. Then, it can distinguish between the first visit and the second visit by checking whether the node that has just been extracted from the stack matches the node on top of the stack. This happens only when we extract the first of the two occurrences. Post-order traversal looks like this:\n\nIt is cool, but I prefer passing the flag explicitly for clarity.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/iterativetreetraversal",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Single-Edge Cut Problem",
      "content": "Single-Edge Cut Problem\n\nIn this post, we'll solve a graph problem that comes up in the Wall Game.\n\nSee also the related, but harder, Double-Edge Cut Problem.\n\nThe single-edge cut problem\n\nYou are given an undirected, unweighted, connected graph G with V nodes and E edges, where each node is identified by an integer from 0 to V-1. You are also given a list, bonded_pairs, of k pairs of nodes.\n\nWe say an edge is essential if removing it from G disconnects a bonded pair.\n\nReturn a list of the essential edges.\n\nGiven this graph and the list bonded_pairs = [[0, 1], [1, 5], [5, 7]], the essential edges would be [[0, 1], [2, 4]]:\n\nremoving the edge [0, 1] disconnects the bonded pair [0, 1]\n\nremoving the edge [2, 4] disconnects the bonded pair [1, 5]\n\nthere is no way to disconnect the bonded pair [5, 7]\n\nThis is the key problem behind whether a wall can be added or not in the Wall Game. The board of the Wall Game may look something like the picture on the left:\n\nThe right picture is the board modeled as a graph. The cells become nodes and two adjacent nodes are connected if there is no wall between them.\n\nPlayers can build walls anywhere, which is like removing an edge. The only constraint is that they cannot fully block the opponent's path to their goal (or their own). Thus, each player and its goal form a bonded pair, and the essential edges are the walls that cannot be placed.\n\nIn the picture, the bonded pairs are [u, v] and [w, x], and the essential edges are shown in red.\n\nImagine that we want to implement a feature in the Wall Game website where, when you hover over a wall slot, it is highlighted in red if the move is invalid. To do this, we need to solve the single-edge cut problem. Beyond that, it could also be useful to program an engine, which needs to consider lots of moves.\n\nNote: the graph from the Wall Game may not be connected (see, e.g., the isolated connected component in the top-left corner)--all we are guaranteed is that each bonded pair is in the same connected component. In this blog post, we assume the graph is connected for simplicity, but it is not hard to extend the algorithm to the disconnected case. We just do an initial pass to find all the connected components, and then process each one separately.\n\nWhy do we frame the problem in terms of k pairs, and not just two? There are variants of the Wall Game with more than two players:\n\nIn this 4-player variant, Player 1 needs to catch Player 2 before they themselves are caught by Player 4, Player 2 needs to catch Player 3 before they are caught by Player 1, and so on. We can think of it as having four bonded pairs.\n\nBrute force solution\n\nThe naive solution is to consider each edge individually. For each edge e in E, we:\n\nRemove it from G (we denote the resulting graph as G - {e}).\n\nFind the connected components in G - {e}.\n\nIf two bonded nodes are in different connected components, e is essential.\n\nStep (1) takes O(1) time, Step (2) takes O(E) time (it can be done with a DFS or a BFS), and Step (3) takes O(k) time. The total runtime is O(E * (E+k)).\n\nEfficient solution\n\nIn this section, we'll solve the problem in O(E * k) time. In the next section, we'll see a more complicated but optimal O(E + k) algorithm.\n\nWe'll build up to it with a series of definitions and intermediate steps.\n\nDefinition: In a connected graph, a bridge is an edge which, if removed, disconnects the graph.\n\nIn the example above, the bridges are [0, 1], [2, 4], and [7, 8].\n\nDefinition: Given a pair of nodes in a connected graph, s and t, an st-bridge is an edge which, if removed, disconnects s and t.\n\nIn the context of our problem, an edge is essential if it is an st-bridge for some bonded pair [s, t].\n\nObservation 1: Every st-bridge is a bridge, but not necessarily the other way around.\n\nObservation 2: Given two nodes, s and t, take any path between them, P. Every st-bridge must be in P.\n\nObservation 2 is because if we remove any edge not in P, s and t will still be connected via P.\n\nMain result: Let P be any path between s and t. An edge is an st-bridge if and only if it is both a bridge and in P.\n\nWe can now formulate an algorithm based on this property:\n\nWe can find all the bridges in O(E) time using Tarjan's algorithm. We can find each path using DFS or BFS in O(E) time (interestingly, it doesn't matter how you find the path, as it can be any path). The total runtime is O(E + k * E) = O(E * k).\n\nHere's a TypeScript implementation.\n\nOptimal algorithm\n\nIf k is small, as in the Wall Game, the above algorithm is the most practical. In this section, we'll see a linear-time (O(E + k)) algorithm, which is asymptotically optimal for any k.\n\nThe bottleneck of the previous algorithm is finding the k paths between bonded pairs. To achieve linear time, we need to do this in a single pass.\n\nThe key property we'll use is that, in Observation 2 above, we can choose any path between each bonded pair. We can start by finding a spanning tree T of G, and focus only on the paths connecting the bonded pairs through T. We can find a spanning tree in O(E) time using a DFS or a BFS (it doesn't matter).\n\nIt will be convenient to think of T as a rooted tree, so that we can talk about node depths and lowest common ancestors. We can root it at any node.\n\nThe root is at depth 0, its children are at depth 1, and so on. The lowest common ancestor of a pair of nodes u and v in T, denoted LCA(u, v), is the node in T that is an ancestor of both nodes and has maximum depth.\n\nRecall that we want to identify all the edges in T that form paths between pairs of bonded nodes. Between any pair of nodes u and v, there is a unique path in T: the path that goes from u up to LCA(u, v) and from there down to v (note that LCA(u, v) could be u or v itself).\n\nWe can start by finding the LCA of each bonded pair in T. We can do this in linear time using Tarjan's off-line lowest common ancestors algorithm.\n\nHere is a tree for the example graph from above, rooted at 7:\n\nHenceforth, we say that a node u is bonded if it is bonded to at least one other node.\n\nFor each bonded node u, we define min_lca(u) as follows: among the LCA's of all bonded pairs involving u, min_lca(u) is the one with minimum depth.\n\nFor example, imagine that, in the tree above, node 1 is involved in 3 bonded pairs: [1, 3], [1, 0], and [1, 4]. The corresponding LCA's are 2 (at depth 2), 1 (at depth 3), and 4 (at depth 1). Of those, the one with minimum depth is 4, so min_lca(1) = 4.\n\nThe following observation characterizes the essential edges in terms of T:\n\nObservation 3: A bridge of G is essential if and only if it is between a bonded node u and min_lca(u).\n\nOn the one hand, if we removed a bridge between u and min_lca(u), the bonded pair consisting of u and the node v such that LCA(u, v) = min_lca(u) will become disconnected. On the other hand, if a bridge is not between any bonded node u and min_lca(u), every bonded pair has a path that doesn't go through it, so it is not essential.\n\nThe idea behind our linear-time algorithm is to do a traversal through T. At each node u, we want to find the LCA with minimum depth among all the bonded pairs with one node in subtree(u) (the subtree rooted at u), if any. That is, we want to find the minimum-depth node in T that is the min_lca(v) for some node v in subtree(u). We actually only care about its depth, which we call subtree_min_lca_depth(u). We can compute subtree_min_lca_depth(u) recursively, aggregating the results from each child as well as the depth of min_lca(u) itself if u is bonded:\n\nFinally, we can write a simple check for whether an edge in T is essential:\n\nObservation 4: If [w, u] is an edge in T, where w is the parent of u, [w, u] is essential if and only if (1) [w, u] is a bridge in G and (2) subtree_min_lca_depth(u) < depth(u).\n\nCondition (2) says that there is some node in the subtree rooted at u that is bonded to a node somewhere above u.\n\nHere is the full pseudocode:\n\nAs mentioned, finding bridges takes O(E) time, building a spanning tree takes O(E) time, and finding all k LCA's takes O(V + k) time; the remaining steps, including the main tree traversal, take O(V) time. Considering that the graph is connected, and thus V <= E, the total runtime is O(E + k).\n\nWant to leave a comment? You can post under the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/single-edge-cut-problem",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Actually Implementing Dijkstra's Algorithm",
      "content": "Actually Implementing Dijkstra's Algorithm\n\nIntroduction\n\nDijkstra's algorithm for the shortest-path problem is one of the most important graph algorithms, so it is often covered in algorithm classes. However, going from the pseudocode to an actual implementation is made difficult by the fact that it relies on a priority queue with a \"decrease key\" operation. While most programming languages offer a priority queue data structure as part of their standard library, this operation is generally not supported (e.g., in C++, Java or Python). In this blog, we go over the different ways to implement Dijkstra's algorithm with and without this operation, and the implications of using each. All in all, we consider 5 versions of Dijkstra (names mostly made up by me):\n\nTextbook Dijkstra: the version commonly taught in textbooks where we assume that we have a priority queue with the \"decrease key\" operation. As we said, this often does not hold true in reality.\n\nLinear-search Dijkstra: the most naive implementation, but which is actually optimal for dense graphs.\n\nLazy Dijkstra: practical version which does not use the \"decrease key\" operation at all, at the cost of using some extra space.\n\nBST Dijkstra: version which uses a self-balancing binary search tree to implement the priority queue functionality, including the \"decrease key\" operation.\n\nTheoretical Dijkstra: version that uses a Fibonacci heap for the priority queue in order to achieve the fastest possible runtime in terms of big-O notation. This is actually impractical due to the complexity and high constant factors of the Fibonacci heap.\n\nRoughly, each of the 5 versions corresponds to a different data structure used to implement the priority queue. Throughout the post, let n be the number of nodes and m the number of edges. Here is summary of the resulting runtime and space complexities:\n\nTextbook Dijkstra: indexed binary heap. Runtime: O(m*log n); space: O(n).\n\nLinear-search Dijkstra: unordered array. Runtime: O(n²); space: O(n).\n\nLazy Dijkstra: binary heap. Runtime: O(m*log n); space: O(m).\n\nBST Dijkstra: self-balancing BST. Runtime: O(m*log n); space: O(n).\n\nTheoretical Dijkstra: Fibonacci heap. Runtime: O(m + n*log n); space: O(n).\n\nWe provide implementations in Python and C++. The initial sections are mostly background. If you are already familiar with Dijkstra's algorithm, you can skip to the code snippets.\n\nThe shortest-path problem\n\nThe input consists of a graph G and a special node s. The edges of G are directed and have non-negative weights. The edge weights represent the \"lengths\" of the edges. The goal is to find the distance from s to every other node in G. The distance from s to another node is the length of the shortest path from s to that node, and the length of a path is the sum of the lengths of its edges. If a node is unreachable from s, then we say that the distance is infinite.\n\nMore precisely, this is known as the \"single-source shortest-path\" (SSSP) problem, because we find the distance from one node to every other node. Related problems include the \"all-pairs shortest paths\" problem and the single-source single-destination problem. Dijkstra's algorithm is a really efficient algorithm for the SSSP problem when the edges are non-negative. Dijkstra's algorithm does not work in the presence of negative edges (zero-weight edges are fine). If G contains negative edges, we should use the Bellman-Ford algorithm instead.\n\nThe constraint that the edges are directed is not important: if G is undirected, we can simply replace every undirected edge {u,v} with a pair of directed edges (u,v) and (v,u) in opposite directions and with the weight of the original edge.\n\nTo simplify things, we make a couple of assumptions that do not make any actual difference:\n\nNodes not reachable by s play no role in the algorithm, so we assume that s can reach every node. This is so that, in the analysis, we can assume that n=O(m).\n\nWe assume that the distance from s to every node is unique. This allows us to talk about \"the\" shortest path to a node, when in general there could be many.\n\nThe graph's representation\n\nA graph is a mathematical concept. In the context of graph algorithms, we need to specify how the graph is represented as a data structure. For Dijkstra's algorithm, the most convenient representation is the adjacency list. The valuable thing about the adjacency list representation is that it allows us to iterate through the out-going edges of a node efficiently.\n\nIn the version of the adjacency list that we use, each node is identified with an index from 0 to n-1. The adjacency list contains one list for each node. For each node u between 0 and n-1, the list G[u] contains one entry for each neighbor of u. In a directed graph, if we have an edge (u,v) from u to v, we say that v is a neighbor of u, but u is not a neighbor of v. Since the graph is weighted, the entry for each neighbor v consists of a pair of values, (v, l): the destination node v, and the length l of the edge (u,v).\n\nDijkstra's algorithm idea\n\nOne of the data structures that we maintain is a list dist where dist[u] is the best distance known for u so far. At the beginning, dist[s] = 0, and for every other node dist[u] = infinity. These distances improve during the algorithm as we consider new paths. Our goal is to get to the point where dist contains the correct distance for every node.\n\nDuring the algorithm, the dist list is only updated through an operation called \"relaxing\" an edge.\n\nIn words, relaxing an edge (u,v) means checking if going to u first and then using the edge (u,v) is shorter than the best distance known for v. If it is shorter, then we update dist[v] to the new, better value.\n\nDijkstra's algorithm is based on the following observations:\n\nif dist[u] is correct and the shortest path from s to v ends in the edge (u,v), then if we relax the edge (u,v), we will find the correct distance to v. If either of the conditions are not satisfied, relaxing (u,v) may improve dist[v], but it will not be the correct distance.\n\nTo find the correct distance to v, we need to relax all the edges in the shortest path from s to v, in order. If we do it in order, each node in the path will have the correct distance when we relax the edge to the next node, satisfying the conditions.\n\nDijkstra's algorithm is efficient because every edge is relaxed only once (unlike other algorithms like Bellman-Ford, which relaxes the edges multiple times). To relax every edge only once, we must relax the out-going edges of each node only after we have found the correct distance for that node.\n\nAt the beginning, only s has the correct distance, so we relax its edges. This updates the entries in dist for its neighbors. The neighbor of s that is closest to s, say, x, has the correct distance at this point. This is because every other path from s to x starts with a longer edge, and, since the graph does not have negative-weight edges, additional edges can only increase the distance. Next, since x has the correct distance, we can relax its out-going edges. After that, the node y with the 3rd smallest distance in dist (after s and x) has the correct distance because the node before y in the shortest path from s to y must be either s or x. It cannot be any other node because simply reaching any node that is not s or x is already more expensive than the distance we have found for y. We continue relaxing the out-going edges of nodes, always taking the next node with the smallest found distance. By generalizing the argument above, when we relax the out-going edges of each node, that node already has the correct distance. We finish after we have gone through all the nodes. At that point, dist contains the correct distance for every node.\n\nIn order to implement Dijkstra's algorithm, we need to decide the data structures used to find the unvisited node with the smallest distance at each iteration.\n\nPriority queues\n\nPriority queues are data structures that are useful in many applications, including Dijkstra's algorithm.\n\nIn a normal queue, we can insert new elements and extract the oldest element. A priority queue is similar, but we can associate a priority with each element. Then, instead of extracting the oldest element, we extract the one with highest priority. Depending on the context, \"highest priority\" can mean the element with the smallest or largest priority value. In this context, we will consider that the highest priority is the element with the smallest priority value.\n\nA priority queue is an abstract data structure. That means that it only specifies which operations it supports, but not how they are implemented. There actually exist many ways to implement a priority queue. To make matters more confusing, different priority queues implementations support different sets of operations. The only agreed part is that they must support two basic operations:\n\ninsert(e, k): insert element e with priority k.\n\nextract_min(): remove and return the element with the smallest priority value.\n\nFor Dijkstra's algorithm, we can use a priority queue to maintain the nodes, using dist[u] as the priority for a node u. Then, at each iteration we can extract the unvisited node with the smallest distance. However, there is a problem: when we relax an edge, the value dist[u] may decrease. Thus, we need the priority queue to support a third operation which is not commonly supported:\n\nchange_priority(e, k): set the priority of e to k (assuming that e is in the priority queue).\n\nA related operation is removing elements that are not the most prioritary:\n\nremove(e): remove e (assuming that e is in the priority queue).\n\nIf a priority queue implements remove, we can use it to obtain the same functionality as change-priority(e, k): we can first call remove(e) and then reinsert the element with the new key by calling insert(e, k).\n\nPseudocode with a priority queue\n\nAssuming that we have a priority queue data structure that supports insert, extract-min, and change-priority, Dijkstra's pseudocode would be as follows.\n\nThe priority queue contains the unvisited nodes, prioritized by distance from s. At the beginning, the priority queue contains all the nodes, and they are removed as they are visited.\n\nA common variation is to add them to the priority queue when they are reached for the first time, instead of adding all the nodes at the beginning. The only change is how the priority queue is initialized and the if-else cases at the end:\n\nIt does not change the runtime or space complexity, but there is also no downside to deferring insertions to the PQ. On average, the PQ will contains fewer elements.\n\nAnalysis of Dijkstra's algorithm\n\nUsually, we analyze the algorithms after implementing them. However, in order to choose the best data structure for the priority queue, we need to analyze how much we use each type of operation. Thus, it is convenient to define the runtime in terms of the priority queue operations, without specifying yet how they are done. Let T_ins, T_min, and T_change be the time per insert, extract_min, and change_priority operation, respectively, on a priority queue containing n elements.\n\nThe main while loop has n iterations, and the total number of iterations of the inner for loop, across all n iterations, is m. This is because each edge is relaxed once.\n\nThe runtime is dominated by the priority queue operations, so it is O(n*T_ins + n*T_min + m*T_change). These operations dominate the runtime because everything else combined (like updating the dist list) takes O(n+m) time.\n\nLinear-search Dijkstra for dense graphs\n\nThe simplest way to simulate the extract_min functionality of a priority queue is to iterate through the entire dist list to find the smallest value among the non-visited entries. If we do this, we don't need a priority queue. We call this linear-search Dijkstra. We get T_ins = O(1), T_min = O(n), and T_change = O(1). Plugging those in, the total runtime of linear-search Dijkstra is O(n + n*n + m) = O(n²), where we simplify out the m term because n² > m in any graph. More precisely, a directed graph with n nodes has at most n*(n-1)=O(n²) edges.\n\nA graph with \"close to\" n*(n-1) edges is called dense. Linear-search Dijkstra is actually optimal for dense graphs. This is because Dijkstra's algorithm must take O(m) time just to relax all edges, so it cannot be faster than O(m), and, in dense graphs that is already proportional to O(n²).\n\nHere is a Python implementation:\n\nAnd C++. We omit the includes and \"using namespace std;\".\n\nPriority queues for sparse graphs\n\nThe O(n²) time from the implementation above is slow if the graph G is sparse, meaning that the number of edges is small relative to O(n²). Recall that the time is O(n*T_ins + n*T_min + m*T_change). If m is more similar to n than to n², then we would be happy to trade a slower change_priority time for a faster extract_min time.\n\nThe best possible answer in terms of big-O notation is to use a priority queue implementation based on a data structure known as a Fibonacci Heap. A Fibonacci heap containing at most n elements achieves the following times:\n\ninsert: O(log n) amortized time.\n\nextract_min: O(log n) amortized time.\n\nchange_priority: O(1) amortized time.\n\nAmortized time means that it could take more time, but, if we average out the times for that operation across the execution of an algorithm, each one takes that time on average.\n\nUsing a Fibonacci heap, we get a total time of O(n*log n + m) for Dijkstra's algorithm. This is really fast in terms of big-O notation, but Fibonacci heaps have larger constant factors than other data structures, making them slower in practice.\n\nThe most common way to implement a priority queue is with a binary heap. It is simple and fast in practice. Binary heaps support insert and extract_min in O(log n) like a Fibonacci heap. However, they do not support the change_priority operation.\n\nIt is possible to modify a binary heap to to support the change_priority operation in O(log n) time. The result is sometimes called an \"indexed priority queue\". Using an indexed priority queue, we would get a total runtime of O(n*log n + m*log n) = O(m*log n). This is slightly worse than with a Fibonacci heap, and faster in practice.\n\nIn any case, the priority queues provided by languages like C++, Python, and Java, do not support the change_priority operation. This creates a disconnect between the pseudocode taught in classrooms and the actual code that we can write.\n\nThe goal of this post is to illustrate the options to deal with this issue. There are 3:\n\nTextbook Dijkstra: find or implement our own indexed priority queue.\n\nLazy Dijkstra: we implement Dijkstra without using the change_priority operation at all.\n\nBST Dijkstra: we use a self-balancing binary search tree as the priority queue.\n\nWe will cover the latter two options. The first option is an interesting exercise in data structures (I implemented it once for a project), but it is more about the inner workings of binary heaps than it is about Dijkstra's algorithm.\n\nAll three options have a runtime of O(m*log n). Note that for dense graphs, this becomes O(n² log n) time, so they are all worse than the naive linear-search Dijkstra. In terms of space, lazy Dijkstra is worse than the others, as it needs O(m) space, as opposed to O(n) for the other options.\n\nLazy Dijkstra\n\nWe implement Dijkstra using a priority queue that does not support the change-priority operation. We need the following change: when we find a shorter distance to a node that is already in the priority-queue, instead of using the \"change-priority\" operation, we simply use an \"insert\" operation and add a copy of the node in the priority queue with the new distance. Then, when we extract a node from the priority queue, we ignore it if it is not the first time we extract that node. We call this version of Dijkstra \"lazy Dijkstra\" because we \"postpone\" the removal of the pre-existing copy of the node.\n\nHere is a Python version. The logical structure of a binary heap is a binary tree, but, internally the tree is represented as an array for efficiency reasons. Python is a bit whack because, instead of having a priority queue module that encapsulates the implementation, we have the heapq module, which provides priority queue operations that can be used directly on a list representing a binary heap. heapq offers functions heappop (equivalent to extract_min) and heappush (equivalent to insert). These functions receive a normal Python list as a parameter, and this list is assumed to represent a binary heap. In Python, if the priority queue contains tuples, then the first element in the tuple is the priority. Thus, in the implementation we insert tuples to the priority queue with the distance first and the node second.\n\nHere is a C++ version:\n\nAnalysis: since nodes can be added to the priority queue multiple times, in lazy Dijkstra the maximum number of elements in the priority queue increases from O(n) to O(m). As a result, we do O(m) extract_min and insert operations. The total runtime is O(m*log m). This can be simplified to O(m*log n), because log m < log (n²) = 2 log n = O(log n). Thus, in terms of big-O notation, lazy Dijkstra is equally fast as textbook Dijkstra (Dijkstra with an indexed priority queue). The only thing that got worse is the space used by the priority queue.\n\nBST Dijkstra\n\nSelf-balancing binary search trees, like red-black trees or AVL trees, are a type of data structure that maintains a set of elements ordered according to values associated with the elements, known as the elements' keys. They support a few operations, all in O(log n) time. For our use case, we are interested in the following ones:\n\nInsert an element with a given key.\n\nFind the element with the smallest/largest key.\n\nGiven a key, find if there is an element with that key, and optionally remove it.\n\nThese operations allow us to use a self-balancing BST to implement a priority queue. With the third operation, we can even implement the change_priority operation, as we mentioned.\n\nPython does not actually have a self-balancing binary search tree module (why?!), so we cannot implement this version of Dijkstra either without finding or implementing our own self-balancing BST.\n\nHere is a C++ version. In C++, the set data structure is implemented as a self-balancing BST:\n\nAnalysis: in a sense, BST Dijkstra combines the best of both worlds: it has the same runtime and space complexity as textbook Dijkstra, without needing the extra space of Lazy Dijkstra, but it uses a much more ubiquitous data structure, a self-balancing BST. However, in practice, self-balancing BSTs are slower than binary heaps. This has to do with the fact that heaps can be implemented on top of an array, while BSTs use recursive tree data structures with child pointers. The array has much better locality of reference. For sparse graphs, I'd expect the performance of the different versions to be ordered as follows:\n\nTextbook Dijkstra > Lazy Dijkstra > BST Dijkstra > Theoretical Dijkstra > Linear-search Dijkstra\n\nPractice problems\n\nHere are some problems on leetcode:\n\nNetwork Delay Time\n\nFind the City With the Smallest Number of Neighbors at a Threshold Distance\n\nReachable Nodes In Subdivided Graph\n\nPath with Maximum Minimum Value (Premium only)",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/implementing-dijkstra",
      "author": "",
      "user_id": ""
    },
    {
      "title": "A topology/geometry puzzle",
      "content": "A topology/geometry puzzle\n\nIn this post, we'll study what kind of solids (3D shapes) we can get by taking a solid and merging two of its faces.\n\nThe goal of this project is to characterize every solid that can be created starting from a platonic solid (what that means, precisely, will be clear later). I'm ~40% of the way there.\n\nDisclaimer: I have not done any literature review for this post (I did enough of that in grad school!) so it is very likely that this space has already been explored. This is just for fun. If you happen to know of any related work, please let me know!\n\nLet's formalize what operations are valid. I'll start with (filled) 2D shapes, which are easier to visualize.\n\nIn topology, a cube, a sphere, and a sock are all the same thing because they can be deformed into one another without cutting or gluing. We say they are homeomorphic.\n\nWe have a similar concept here, but we also account for vertices and edges. These three 2D shapes are homeomorphic because they all have a face with 4 vertices and edges:\n\nIn contrast, a square is not homeomorphic with a triangle, because, even though both can be deformed into the same 'shape', the vertices and edges do not match.\n\nThe same applies to 3D solids, where two solids are homeomorphic if they can be deformed into one another without cutting or gluing, with matching faces, edges, and vertices. These two shapes are homeomorphic:\n\nThis is the only operation we can do which transforms a 2D shape (or 3D solid) into another shape/solid that is not homeomorphic to the original one. I'll start with 2D.\n\nIn 2D, we can merge pairs of edges. First, it must be possible to wiggle the shape until the two edges line up without anything in between them. Then, we 'merge' them by lining up the edges and removing the edges and the lined up vertices. The two faces of the edges become one if they weren't already.\n\nThis should be intuitive with an image. Given a square, we can merge opposite edges or adjacent edges:\n\nWhen we merge adjacent edges of a square, we can get a vertex that connects an edge to itself. We call this shape a 'pointy circle'.\n\nNote the requirement of \"without anything in between them\". This means that, for instance, we cannot merge the inner and outer edges of a 2D torus, because the torus itself is in between.\n\nMerging two faces of a triangle results in a circle.\n\nThere are some edge cases to address.\n\nEdge Case 1: Dangling Edge\n\nWhen merging two edges, we may end up with an edge that ends in the middle of a face. We call this a 'dangling edge'. By convention, we remove dangling edges as part of the merging operation, like e in the image below.\n\nThe remaining vertex, p, was not adjacent to either of the merged edges, so it stays.\n\nEdge Case 2: Surviving vertex\n\nWhen merging two edges, the aligned vertices usually disappear. However, if a vertex is also connected to another edge which is not merged (or dangling), it will stay, like p in the image below. Edges a and b are not merged, so p stays.\n\nMerging in 3D is the same as in 2D, but we merge faces instead of edges.\n\nIn order for two faces to be mergeable, they must be homeomorphic (same number of vertices and edges, same holes, etc) and it must be possible to wiggle them so they line up without anything in between them.\n\nTetrahedron\n\nCharacterizing the tetrahedron is trivial.\n\nI'll use gifs to show 3D solids. The gifs show the solid from the front (left) and the back (right). They were made with this Python app I vibe coded.\n\nMerging any two faces of a tetrahedron gives us an 'edged sphere' (a sphere with two faces, a single circular edge, and no vertices).\n\nWhen I say \"characterize the tetrahedron\", I mean constructing a directed acyclic graph (DAG) of all the possible solids we can get by merging faces starting from a tetrahedron.\n\nThe tetrahedron DAG just has two nodes:\n\nWe say a solid is irreducible if it cannot go through any more merging operations. Irreducible solids correspond to leaves in the DAG.\n\nThe cube is where things get interesting. For one, the cube DAG is infinite.\n\nCube branch 1: merging opposite faces\n\nAnalogously to how merging opposite edges of a square gives us a 2D torus, merging opposite faces of a cube results in a 3D torus with a square cross-section, which we call a 'square torus'.\n\nHowever, when we wiggle the cube, we can twist it before lining up the faces. This still results in a torus with a square cross-section, but one which is not homeomorphic to the non-twisted torus. In fact, the number of faces changes depending on how much we twist it.\n\nIf we twist it 90 degrees, we get a single face:\n\nIf we twist it 180 degrees, we get two faces:\n\nIf we twist it 270 degrees, we get a single face again:\n\nFrom that point on, the number of faces repeats. For instance, if we twist it 360 degrees, we get four faces again.\n\nIf we keep twisting it more, the number of faces repeats 4 -> 1 -> 2 -> 1 -> 4 -> 1 -> 2 -> 1 -> ..., but none of those solids are homeomorphic. So, by twisting, we can get an infinite number of different solids.\n\nIf we take the square torus without any twisting and merge adjacent faces, we get a torus where the cross-section is a pointy circle.\n\nIf we merge opposite faces instead, we get a torus with a torus cavity, i.e., a torus with a 2D-torus cross-section.\n\nThe square toruses that have 1 or 2 faces after twisting (e.g., with a 90 degree or 180 degree twist) are irreducible because there are not enough faces.\n\nThe square toruses that have 4 faces after twisting (e.g., with a 360 degree twist) are not irreducible, regardless of how much we twisted them:\n\nIf we merge opposite faces, we get the a torus with a hole again. Surprisingly, this merge \"undoes\" the twisting.\n\nIf we merge adjacent faces instead, we get a pointy-circle torus again, but this time the edge twists around the cross-section. The amount of twisting depends on how much we twisted the cube, so we can get an infinite number of different pointy-circle toruses. Here is the pointy-circle torus with 360 degree of twisting:\n\nThis covers every solid we can get from a cube by merging opposite faces.\n\nCube branch 2: merging adjacent faces\n\nStarting from a cube, if we merge adjacent faces, we get a cylinder with a pointy-circle cross-section.\n\nFrom there, we can merge the top and bottom faces of the cylinder to get a pointy-circle torus. When we do that, we can twist it to get all the same infinitely many pointy-circle toruses with twisting that we got from the square toruses.\n\nWe can now complete the cube DAG:\n\nPersonally, what I find interesting about the cube DAG is how it is possible to reach the solids that require two steps in multiple ways.\n\nCounting faces by cross-section sides and twists\n\nBefore getting to the other platonic solids, I'll go on a tangent to show a cute result:\n\nA torus with a k-gon cross-section and n 'face twists' has GCD(k, n) faces.\n\nGCD is the greatest common divisor\n\nA k-gon is a polygon with k sides\n\nA face twist is a twist of 360/k degrees. For instance, 1 face twist means that, in one full rotation of the torus, each face ends up one face over.\n\nWe already saw some examples with the square torus (a 4-gon torus):\n\n0 face twists (0 degrees): GCD(4, 0) = 4 faces\n\n1 face twist (90 degrees): GCD(4, 1) = 1 face\n\n2 face twists (180 degrees): GCD(4, 2) = 2 faces\n\n3 face twists (270 degrees): GCD(4, 3) = 1 face\n\n4 face twists (360 degrees): GCD(4, 4) = 4 faces\n\nThis result also explains why the number of faces repeats as we twist the square torus further.\n\nHere are some examples with a different k-gon, a 12-gon:\n\nIf you want to play with different k-gons and number of face twists, the source code for the Python app is here.\n\nThe argument for why the number of faces is GCD(k, n) is as follows:\n\nProof: Pick any cross-section of the torus, C. C is a k-gon, so we can label its edges with 0, 1, 2, ..., k-1 along the twist direction.\n\nIf we walk along a face of the torus, starting from C, edge 0, by the time we get back to C, we'll have moved n edges over in the twist direction. Since there are only k edges, that means we'll end up at edge n % k.\n\nIf we keep walking along the torus, we'll reach, edges 0, n % k, 2*n % k, 3*n % k, and so on, until we reach a number i*n that is a multiple of k and we get back to edge 0. All these edges belong to the same face of the torus. Thus, each face of the torus covers i edges of C, making the total number of faces k / i. Now we just need to see that k / i = GCD(k, n).\n\nThe number i*n is the first multiple of n that is also a multiple of k. In other words, i*n = LCM(k, n), where LCM is the least common multiple.\n\nRecall the GCD-LCM identity: GCD(a, b) * LCM(a, b) = a * b.\n\nUsing that LCM(k, n) = i*n, we get that GCD(k, n) * (i*n) = k * n, so k / i = GCD(k, n). ∎\n\nOctahedron (work in progress)\n\nAs of March 2025, I haven't finished the octahedron DAG yet.\n\nOctahedron branch 1: merging edge-adjacent faces\n\nIf we merge two faces sharing an edge, we get this shape with two triangle faces and two 2-gon or 'digon' faces (a closed shape with two edges) which I'll be calling 'eye' shapes:\n\nCan anyone suggest a good name for this shape? I'll go with 'Dorito' for now.\n\nIf we merge the two 'eye' faces of the 'dorito', we get a kind of torus with a single point in the center instead of a hole, and an edge along the outside of the torus. Since the two eyes share a vertex, no twisting is possible.\n\nUnfortunately, as I mentioned, I vibe coded the Python app to draw the 3D solids, and this is the limit of what I've managed to get Claude to draw. So, for the remaining faces I only have sketches or nothing at all.\n\nIf we merge the two triangle faces, it's hard to visualize what happens, but (I think) one of the eyes becomes an inner face and the other an outer face. The 'dorito' shape has a vertex shared by all four faces, so, since it is adjacent to the two 'eyes', which are not merged, it stays after the merge (see edge case 2 in merging). That means that the outer and inner face share a vertex.\n\nThe final shape looks like a 3D 'teardrop' solid with a 'teardrop' cavity, where both teardrops share the top vertex.\n\n~Insert joke here about how the eyes turned into teardrops.~\n\nThat's all we can do in the first branch of the octahedron DAG.\n\nOctahedron branch 2: merging vertex-adjacent faces\n\nIf we merge two faces sharing a vertex, we get this shape, which I'll call the 'petal'.\n\nThe only thing we can do with the petal is merging the two pointy-circle faces sharing a vertex, which results in a torus with a single vertex in the center instead of a hole.\n\nThat ends this branch.\n\nOctahedron branch 3: merging opposite faces\n\nThis is the most interesting branch. Anytime we merge two faces that don't share any edges or vertices, we form some kind of torus. In this case, I think it's a torus with a hexagonal cross-section, except for a single point in which three of the edges 'collapse' into vertices and the cross-section is a triangle (at least, that's one way to draw it -- it's not the only way). Here is my best attempt at sketching the 'collapse point':\n\nIf I counted correctly, this solid has 3 faces, 6 edges, and 3 vertices regardless of how much twisting we do. I'm not sure whether it is irreducible, and whether that depends on the amount of twisting.\n\nOctahedron DAG\n\nThis is what I have so far:\n\nUnlike the cube, we don't get any shared solids between the branches.\n\nWhat's next?\n\nI don't know much about the dodecahedron and icosahedron yet. What's clear is that I pushed the limit of both vibe coding and of the 2D drawing editor (the amazing Ipe). I think Blender is the right tool for this, and I'm actually curious enough about what these shapes look like that I started messing around with it. So far, I managed to make this (scuffed) two-faced solid, which I incorrectly thought could be obtained from the octahedron:\n\nThis project started from seeing this gif:\n\nThe concept of a solid mobius strip was new to me, and I started thinking about variations and how to construct them. That led me to the idea of starting with a cube and merging two faces. Then, I did something very common in math: I started thinking about possible generalizations.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/merging-geometry",
      "author": "",
      "user_id": ""
    },
    {
      "title": "What Vibe Coding Actually Looks Like (prompts included)",
      "content": "What Vibe Coding Actually Looks Like (prompts included)\n\nOne afternoon, I was lying in bed with a case of malaise. I was thinking about this gif I had seen on X earlier and how it would be cool to have an interactive visualization for shapes like this:\n\nI wasn't in the mood to start coding a 3D graphics app, but vibe coding is fun, and chill, and lazy, so I thought, \"I'm not doing it, but I'll ask Claude and see what happens.\"\n\nThe term vibe coding went viral from an Andrej Karpathy tweet. However, a lot of people still don't know what it is or how it works.\n\nVibe coding is when you code a project by repeatedly prompting an LLM to add features and make changes, without looking at the code. The LLM proposes a code change, and rather than reviewing it, you click \"accept\" and check if it does what you want. If it doesn't, you prompt it to fix it or undo the change and refine your prompt.\n\nFor me, it has made side projects a lot more fun and productive (the entire website you are reading this post on was vibe coded), so I want to share how it works and make it concrete by showing the exact prompts used to create a project.\n\nThe project\n\nI'll show the first 17 prompts I used for github.com/nmamano/mobiustorus, an interactive python app for visualizing 3D toruses with different polygonal cross sections and 'twists'.\n\nThis was the final result after the 17 prompts, including failed ones:\n\nI used Claude-3.5-Sonnet via the Cursor IDE. The two popular choices for vibe coding right now seem to be Cursor and Windsurf. I've only tried Cursor so I don't have an opinion on which is better.\n\nI wasn't trying to be fast or efficient, but I clocked the whole thing at 35 minutes, so about 2 minutes per prompt. The LLM is fast, so the main bottleneck was writing the prompts.\n\nTo be fair, this was probably a lucky/happy run, and it could have taken longer. However, LLMs keep getting better (we now have thinking mode for Claude 3.7 in Cursor), so the trend will be the opposite.\n\nThe resulting code was 180 LoC.\n\nThe prompts\n\nwrite a python script that draws a 3d torus. make it interactive if possible\n\nwrite a python script that draws a 3d torus. make it interactive if possible\n\nNotice how I don't start by asking for the final state. Part of vibe coding is chuncking what you want to do into a series of conceivable steps.\n\ncan you make the torus more like a doughnut? make the cross section a circle\n\ncan you make the torus more like a doughnut? make the cross section a circle\n\nThe AI pushed back saying it was already a circle.\n\nthe problem is in the visualization then. the axises don't all have the same scaling\n\nthe problem is in the visualization then. the axises don't all have the same scaling\n\nIt's good to fix issues (like the distorted scaling) before trying to add more features.\n\ncan you hide the axes and planes so there's only the torus left\n\ncan you hide the axes and planes so there's only the torus left\n\nnow the challenging part. Add a parameter k, which you can initialize to 4 by default. Then, instead of a circle, the cross section should be a regular polygon with k sides. like a square for k = 4\n\nnow the challenging part. Add a parameter k, which you can initialize to 4 by default. Then, instead of a circle, the cross section should be a regular polygon with k sides. like a square for k = 4\n\nit didn't work. it looks more like a lamp\n\nit didn't work. it looks more like a lamp\n\nthat's almost correct, but thre's a weird gap where some of the sides don't touch\n\nthat's almost correct, but thre's a weird gap where some of the sides don't touch\n\nThe AI made some changes that didn't fix it.\n\nstill happening (with attachment: a screenshot of the shape)\n\nstill happening (with attachment: a screenshot of the shape)\n\nThis finally fixed it.\n\nTip: I didn't do it here but it's often easier to roll back a bad change and refine your prompt than to try to fix it.\n\ncolor each face of the torus with a different color\n\ncolor each face of the torus with a different color\n\nI ran into some compilation errors.\n\nhelp (with attachment: the error from the terminal)\n\nhelp (with attachment: the error from the terminal)\n\nadd a way to change the k parameter in the interaction\n\nadd a way to change the k parameter in the interaction\n\nNotice how I didn't specify what the UI for changing the parameter should look like. Often, the LLM does a better job when it has fewer constraints.\n\ncan you add an option to add twisting to the shape. in one full rotation of the 'torus' each face has twisted to matchup with the 'next' face\n\ncan you add an option to add twisting to the shape. in one full rotation of the 'torus' each face has twisted to matchup with the 'next' face\n\nIt should skip twists where the faces don't perfectly match. So, depending on the number of faces, it should calculate the degrees to twist to align the next face, and that should be the smallest incremental twist\n\nIt should skip twists where the faces don't perfectly match. So, depending on the number of faces, it should calculate the degrees to twist to align the next face, and that should be the smallest incremental twist\n\ncan you support one more twist, so that each face can match with its original starting face\n\ncan you support one more twist, so that each face can match with its original starting face\n\nThis worked.\n\nhere's a crazy idea. instead of showing the torus once, show it twice, side by side, with the second one looking at it from the opposite side (like from deep in the z axis i guess)\n\nhere's a crazy idea. instead of showing the torus once, show it twice, side by side, with the second one looking at it from the opposite side (like from deep in the z axis i guess)\n\nIt showed two toruses, but they moved independently.\n\nNice!! I want the position of the 2 toruses to be related though. when i move one, the other should move too, but seen from the opposite side\n\nNice!! I want the position of the 2 toruses to be related though. when i move one, the other should move too, but seen from the opposite side\n\nclose enough. now the 2 are moving together as i wanted, but i'm not getting the 2 perspectives that i want. the left torus is perfect as is. the right torus should be as if i was looking at the left torus from behind\n\nclose enough. now the 2 are moving together as i wanted, but i'm not getting the 2 perspectives that i want. the left torus is perfect as is. the right torus should be as if i was looking at the left torus from behind\n\nThis produced the final result I showed at the beginning.\n\nSome thoughts\n\nAfter this initial experiment, I used this app to write another blog post, Merging Geometry.\n\nI kept adding features to this app, like:\n\nmaking the shapes rotate automatically\n\na button to download gifs of the animations\n\nadding more shapes\n\nremembering which shape was open the last time the app was used and opening it directly (using local storage)\n\nautomatically reopening the app when the code changes\n\nIt is now ~1200 LoC, and I still have no idea whatsoever how to draw a 3D shape with Python.\n\n\"But you're not learning anything!\"\n\nSome people think that that is a wasted opportunity and that it makes me a worse programmer because I am not learning anything.\n\nHere is the thing: people operate in different modes. I wanted these visualizations to satisfy my curiousity, and later to write the blog post, not because I wanted to code. I was in writer mode. My goal was to convey information clearly, and vibe coding is a tool that helped me do that.\n\n\"Is coding a useless skill now?\"\n\nAs much as I like vibe coding, I'll push back against this idea. Personally, I wouldn't trust vibe coding to handle anything with real users or personal data. I would still use LLM chats, but I would want to control the architecture and understand the codebase.\n\nEven if I didn't look at the code for this project, I still needed an intuitive understanding of how hard it is to code something (for an LLM) in order to chunk the project into doable steps.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/what-vibe-coding-actually-looks-like",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game UI Design (+ Frontend Generators)",
      "content": "Wall Game UI Design (+ Frontend Generators)\n\nThis blog post is a design doc for the frontend of wallgame.io, a board game I'm making. However, something probably more interesting came out of it: an assessment of frontend generators' ability to one-shot a 6000-word design doc prompt. The results deeply impressed me. They are in an appendix at the bottom. Feel free to skip the design doc and check out the appendix.\n\nThis is the specification of the frontend for the Wall Game, an online strategy board game. It only specifies the logic/functionality. It is agnostic of the look.\n\nA first version of the game is already available at wallwars.net. This is a UI overhaul with the following goals:\n\nA smooth onboarding experience. It should be very clear how to navigate the site and in what order to do things.\n\nTeaching the game to new players in a structured way.\n\nExpansive solo modes so that players can have fun even if there is no one else online.\n\nImproving the user journey of inviting friends to play.\n\nSupporting game variants as a first-class feature (this was a key feature for replayability when playing with a physical board).\n\nSupporting game variants with a varying number of players.\n\nSupporting multiple bots, including custom bots to foster the \"engine dev\" community.\n\nClean interface to game data, like past games, player history, rankings, etc., by showing interlinked tables with SQL-like features like filtering.\n\nMore \"social\" features, like an in-game chat and the ability to watch live games.\n\nFrontend Overview\n\nThe site is a SPA (single page app). There are 9 main pages, all of which are accessible from the top navigation bar. If a screen is not wide enough to show all the tabs, they are collapsed as necessary into a hamburger menu icon. Tabs act as buttons to show the corresponding page. Pages are self-contained and have their own URL:\n\nIn order, the tabs are:\n\nPlay (default) - wallgame.io\n\nRanking - wallgame.io/ranking\n\nPast games - wallgame.io/past-games\n\nLive games - wallgame.io/live-games\n\nLearn - wallgame.io/learn\n\nAbout - wallgame.io/about\n\nSettings - wallgame.io/settings\n\nProfile (appears as Login if the user is not logged in) - wallgame.io/profile\n\nThe navigation bar is always visible, and the current tab is highlighted.\n\nWe'll first go over the basic concepts, then some of the basic components reused across multiple pages, and finally, we'll go over each page (out of order).\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nPlayer types: there are 5 player types in the context of a game created by a user: \"You\": the user itself. \"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.) \"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\"). \"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game. \"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nPlayer types: there are 5 player types in the context of a game created by a user:\n\n\"You\": the user itself.\n\n\"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.)\n\n\"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\").\n\n\"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game.\n\n\"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter): The user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win). The user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully. The user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter):\n\nThe user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win).\n\nThe user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully.\n\nThe user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nThis section describes specific high-level components of the UI, which are reused in various places.\n\nThis is the main component involved in playing the game.\n\nA rectangular grid of square cells, with thick margins between them (that's where the walls go).\n\nA cell may contain one or more pawns. There is no limit on how many pawns can be in the same cell.\n\nA staged or premoved pawn move is shown with an arrow. Arbitrary arrows can also be added as calculations. It should be clear which one is which.\n\nBetween every two cells adjacent vertically or horizontally, there is a space where a wall can be placed, staged, premoved, calculated, or missing.\n\nThe corner between four cells is called a \"pillar\" and is not an interactable element.\n\nPlaced walls are colored according to the color of the pawns of the player who placed them.\n\nSimilar to chess and checkers, the cells are colored alternatively, so that cells that are an even number of moves away from each other share a color. The contrast between the two colors is subtle.\n\nLike chess, rows are labeled with numbers (starting from 1 on the top) and columns are labeled with letters (starting from 'a' on the left). The first cell in each row is labeled with the corresponding row number. The first cell in each column is labeled with the corresponding column letter. The labels are subtle, taking only a corner of the cell.\n\nThe last move is highlighted so it is easy for players to see what the opponent just did.\n\nThis includes the board itself and surrounding elements for any related information and interactions:\n\nthe timers. The timer of the player to move is highlighted.\n\nthe player names and ELOs. The name of the player to move is highlighted.\n\nthe move history in standard notation, with buttons to go back and forth and buttons to go to the beginning and latest move.\n\nthe chat. The chat can have multiple \"channels\": the \"game chat\", seen by all the players but not the audience the \"team chat\", seen only by players on the same team the \"audience chat\", seen only by the audience\n\nthe \"game chat\", seen by all the players but not the audience\n\nthe \"team chat\", seen only by players on the same team\n\nthe \"audience chat\", seen only by the audience\n\nan indicator of whose turn it is\n\nonline indicators for each player (if a player does not have the game tab/app active, it shows as offline)\n\nmenus for out-of-game interactions: \"resign\", \"offer draw\", \"propose take back\", \"give time (1 min)\", \"rematch\"\n\na button to toggle sounds\n\ncontextual information: the game variant and parameters the time control rated status the match score whose turn it is the player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\") after the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\nthe game variant and parameters\n\nthe time control\n\nrated status\n\nthe match score\n\nwhose turn it is\n\nthe player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\")\n\nafter the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\na button to see/copy the game's replay notation and standard notation\n\nGame configuration panel\n\nThis includes all the configuration options for a game.\n\ntime control: a selector with the options \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\".\n\nrated status: yes/no. If the player is not logged in, the 'rated status' is set to \"no\" and grayed out. There should be an informational text that says that the user needs to be logged in to play rated games.\n\nvariant: a selector of supported variants.\n\nadditional parameters that depend on the variant. These parameters appear in a container, and the container changes depending on the variant.\n\nFor example, for the standard variant:\n\nBoard width: number. Default: 8\n\nBoard height: number. Default: 8\n\nPlayer configuration\n\nA little component that lets you configure how a player in a game will move. It consists of a selector with a few options, each of which has an informational text.\n\n\"You\": \"You'll make the moves.\"\n\n\"Friend\": \"You'll get a link to share with a friend to join the game.\"\n\n\"Matched user\": \"You'll be paired with a random player with compatible settings and similar rating.\"\n\n\"Easy Bot\": \"You'll play against an easy AI bot.\"\n\n\"Medium Bot\": \"You'll play against a medium AI bot.\"\n\n\"Hard Bot\": \"You'll play against a hard AI bot.\"\n\n\"Custom bot\": \"You'll get an access token so that you can connect your own bot. See here for more information.\" The text links to a blog post explaining how to make a custom bot and connect it to the game using the token.\n\nThere is no default. It depends on the context.\n\nGame setup page\n\nThis page has its own URL: wallgame.io/game-setup.\n\nIt has two sections:\n\nCreate game\n\nCreate game\n\nThis part has the following elements:\n\nA button: \"Create game\".\n\nA player configuration component for each player (which depends on the variant, as set in #4). The selectors are labeled \"Player 1\", \"Player 2\", and so on. The default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe selectors are labeled \"Player 1\", \"Player 2\", and so on.\n\nThe default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe game configuration panel. Choosing a variant with more than 2 players will affect the number of player configuration components in #2.\n\nThis part has the following elements:\n\nA heading \"Join game\"\n\nA table showing games from other players that are in the \"matching stage\" and waiting for someone to join.\n\nThe table has the following columns:\n\nJoin: a button which, when clicked, joins the game.\n\nRated: yes/no.\n\nTime control: a string formatted like \"blitz (3+2)\"\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height).\n\nPlayer: a string formatted like \"name1 (1200)\". The numbers in parentheses is the rating. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (XXX) & name2 (YYY) vs name3 (ZZZ)\".\n\nThe rows are ordered by ELO closest to the current user's ELO. If the user chose a variant, rated status, time control, or board size in the game configuration panel, rows matching those settings are prioritized. Games that have been in \"matching stage\" for longer are also prioritized.\n\nThe parameterized URL is wallgame.io/game/game-id\n\nThe game page shows a game, identified with a given game ID in the URL. The game could be in the \"matching stage\", ongoing, or finished (a past game) The URL can be shared to join the game (if it is in the \"matching stage\"), to spectate it live (if it is ongoing) or watch it as a past game (if it is finished).\n\nThe game page has one main component: the board view.\n\nDepending on the context, it could contain other elements. See, e.g., the case of the \"Solo campaign\" puzzles, which contain an additional explanation text. So far, this seems to be the only exception.\n\nMatching stage panel\n\nWhen a user creates a game from wallgame.io/game-setup, a game ID is generated and they are taken to the game page with that game ID.\n\nHowever, it is possible that not all players are ready. For instance, if one of the player types is \"friend\", the game cannot start until the friend joins the game.\n\nIf not all players are ready, a \"matching stage\" panel component is shown as a modal over a faded out version of the game page.\n\nThe modal has a title: \"Waiting for players\". It contains one row for each player. Each row contains:\n\nThe player type (e.g., \"You\", \"Friend\", \"Easy Bot\", \"Medium Bot\", \"Hard Bot\", \"Custom Bot\", \"Matched player\")\n\nAn indication of whether the player is ready.\n\nInstructions for how that player should join the game If the player is \"You\", the player is automatically ready. If the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard. If the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready. If the player is \"Custom Bot\", the instructions include an access token for a custom bot. If the player is \"Matched player\", the instructions are to wait for someone to join.\n\nIf the player is \"You\", the player is automatically ready.\n\nIf the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard.\n\nIf the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready.\n\nIf the player is \"Custom Bot\", the instructions include an access token for a custom bot.\n\nIf the player is \"Matched player\", the instructions are to wait for someone to join.\n\nA button to abort the game and return to the previous page.\n\nIf a player joins a game but there are other players that are not ready (in the case of variants with more than 2 players), they will also see the matching stage panel.\n\nTab 7: Settings\n\nSettings have three sections:\n\nUser settings\n\nVisual style\n\nDefault game parameters\n\nFor sections 2 and 3, there should be an information box indicating that if the user is not logged in, they are saved as local cookies in the web browser. If they are logged in, the settings are saved to their account instead.\n\n1. User settings\n\nThis has one field:\n\nDisplay name (text field)\n\nIt behaves a bit differently depending on if the user is logged in.\n\nFor logged in users, the display name shows their current name and it is editable.\n\nThere should be a button next to the \"display name\" text field that says \"Change if available\" and an informational text that says \"Names must be unique across the site (case insensitive). You can only switch to another name not already in use.\" The button should be grayed out if the text field matches their current name. Names including \"guest\" or \"deleted\" or \"bot\" are not allowed. If the user tries to change to such a name, it should be explained to them.\n\nIf the user is not logged in, the display name should be grayed out and fixed as: \"Guest\"\n\nThere should also be an indication that the user needs to be logged in to change their display name, with a button to the Profile page.\n\n2. Visual style\n\nDark theme: on/off. Default: on\n\nBoard theme: selector. Default: \"classic\".\n\nPawn color: selector. Default: default.\n\nCat pawn: selector.\n\nMouse pawn: selector.\n\n... (one selector for each pawn type that appears in any variant)\n\nThe pawn selectors are between icons/small images.\n\n3. Default game parameters.\n\nThis is the game configuration panel component.\n\nA text says, \"When setting up a game, these parameters will be used as default.\"\n\nTab 6: About\n\nThis contains short informational text. The text can be something like this:\n\n\"Wall Game is a board game about building walls and outsmarting your opponents. It is inspired by Quoridor (wiki link) and Blockade (wiki link). Basic instructions about navigating the website (where to find the rules etc). Created by Nil Mamano (link). For more, you can read the blog (link).\"\n\nTab 8: Profile\n\nThis page looks different depending on whether the user is logged in or not.\n\nNot logged in\n\nThe tab appears as \"Login\".\n\nThe page shows two main buttons: log in and sign up\n\nIt includes a bit of text: \"Log in or sign up to choose a name, play rated games, and see your game history.\"\n\nFor the login and sign up flows, the user is redirected to an external auth service, so they are not part of this UI.\n\nThe tab appears as \"Profile\".\n\nIt shows the user display name and rating at the top, followed by a series of buttons grouped in two groups:\n\nPast Games: takes you to the Past Games tab but with the user's name already set as filter.\n\nRanking: takes you to the Ranking tab but with the user's name already set as filter.\n\nSettings: takes you to the settings page.\n\nDelete account\n\nThe delete account button shows a confirmation dialog: \"Your email will be deleted from the DB and all games you played will appear as 'Deleted User' and you won't be able to play again with this account. Are you sure?\"\n\nTab 3: Past games\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default. Filters are added as query parameters to the URL, so they can be shared.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nPlayer: text field (empty field acts as \"all\")\n\nPlayer: text field (empty field acts as \"all\").\n\nTime period: a date range\n\nThe two player fields serve the same purpose. Filling only one gives you all games with that player. Filling both gives you all games including both players.\n\nGames with fewer than 2 moves are filtered out. Games aborted during the \"matching stage\" are not even stored.\n\nThe rows are ordered by date. The order cannot be changed.\n\nWatch: a button which, when clicked, takes you to see the past game.\n\nVariant: clicking on a variant sets the variant filter.\n\nRated: yes/no. Clicking on a rating sets the rated status filter.\n\nTime control: a string formatted like \"blitz (3+2)\". Clicking on a time control sets the time control filter.\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height). Clicking on a board size sets the board size filter.\n\nPlayers: a string formatted like \"name1 (1200) vs name2 (1234)\". The numbers in parentheses are the ratings at the start of the game. Clicking on a name sets the first player filter. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (1200) & name2 (1234) vs name3 (1234) & name4 (1234)\". Clicking on the \"vs\" sets both player filters, with slight tweaks depending on the variant.\n\nMoves: a number. The number of moves of the game.\n\nViews: a number. The number of views the game got.\n\ndate: date type. When the game was played.\n\nThe name of the winning player is highlighted. Draws are also indicated.\n\nPast game view\n\nWhen a user clicks the \"Watch\" button for a past game, they are taken to the \"game page\" for that game (e.g., wallgame.io/game/2ei3nd43).\n\nThe final position is shown by default.\n\nThe chat is grayed out with a message that says \"Chat is not preserved.\"\n\nTab 4: Live games\n\nSimilar to the \"Past games\" page, this page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nThe formatting of the columns is the same as for \"Past Games\".\n\nWatch: a button that takes you to spectate the game in real time.\n\nViewers: a number.\n\nVariant: see \"Past games\" table.\n\nRated: see \"Past games\" table.\n\nTime control: see \"Past games\" table.\n\nBoard size: see \"Past games\" table.\n\nPlayers: see \"Past games\" table.\n\nMoves: see \"Past games\" table.\n\nThe rows are sorted by viewers first, by max ELO second.\n\nWhen a game ends, the number of spectators becomes the initial number of views in the past games table.\n\nLive game view\n\nWhen a user clicks the \"Watch\" button for a live game, they are taken to the \"game page\" for that game (e.g., wallgame.io/live/2ei3nd43).\n\nThe latest state of the game is shown by default.\n\nAs players make moves, spectators receive and see real-time updates.\n\nSpectators see the \"Spectator chat\", which is different than the ones the players see.\n\nTab 2: Ranking\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe filters do not have an \"all\" option.\n\nVariant: default: standard\n\nTime control: default: rapid\n\nPlayer: text field. Default: empty. The player filter acts more like a search box. If filled and the player exists, it only shows the row corresponding to that player and a few rows before and after. If the player does not exist, it shows nothing.\n\nRank: number starting at 1\n\nPlayer: the display name. It updates whenever players change their names delete their accounts.\n\nRating: the ELO rating. These are numbers sorted in decreasing order.\n\nPeak rating: the max ELO rating that player has ever had.\n\nRecord: a string formatted like \"10-4\" indicating the number of points the player got and lost across all its games.\n\nFirst game: a date.\n\nLast game: a date.\n\nClicking anywhere on a row takes you to the \"Past games\" page with the variant, time control, and player filters set. The \"rated\" filter is also set to \"yes\".\n\nTab 5: Learn\n\nThis page contains only static content, in four sections:\n\nRules (standard)\n\nNotation (standard)\n\nLessons (standard)\n\nAll the sections may contain images.\n\nSections can be collapsed.\n\nThis contains a couple of paragraphs explaining the rules of the \"standard\" variant.\n\nIt ends with: \"You can now start the solo campaign.\", with a link to the play tab (wallgame.io).\n\nThis contains a couple of paragraphs explaining the standard notation. This is useful since it appears in the game history element of the \"board view\" component.\n\nThis contains a bullet point list of links to blog posts explaining strategic and tactical ideas. More lessons can be added over time.\n\nThis contains definitions and special rules for all the supported variants.\n\nTab 1: Play\n\nThis is the 'landing' page.\n\nIts main purpose is to easily access the 6 game modes:\n\nSolo campaign\n\nStudy board\n\nPlay with others\n\nInvite friend\n\nIt contains three sections:\n\nSingle-player fun\n\nPlay with others\n\nGame showcase\n\nThe first two contain various buttons to go to the various game modes. The final one is just decorative. It's not there because it's related to the \"Play\" theme, but because it's the landing page.\n\nSingle-player fun\n\nThis section contains the following buttons:\n\nSolo campaign. There is an annotation that says \"Start here!\"\n\nStudy board\n\nPlay with others\n\nThis section contains the following buttons:\n\nFind others\n\nInvite friend\n\nGame showcase\n\nThis section shows a board and autoplays random past games, at high speed (2 moves per second). Above the board, a text says: \"Game showcase: name1 (1200) vs name2 (1234) (DATE)\", with the players and date updating as the game changes. There should also be a button to stop the autoplay.\n\nClicking on it takes you to the \"game page\" to watch the game, analogous to the \"Past games\" page. The only difference is that the game starts at the position that last played automatically in the game showcase.\n\nGame mode 2: Puzzles\n\nThe URL is wallgame.io/puzzles\n\nThe puzzles page has a list of puzzles.\n\nEach puzzle has:\n\nplay button\n\ndifficulty rating\n\ncompleted: yes/no. An indication of whether the user already solved it\n\nIf the user is not logged in, the 'completed' status is grayed out. There should be an information box indicating that the user should log in to save their completion status.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/puzzles/1, where 1 is the puzzle number. This makes it so that the user can share a puzzle by sharing the route.\n\nGame mode 1: Solo campaign\n\nThe URL is wallgame.io/solo-campaign\n\nThe solo campaign menu consists of a list of puzzles just like the menu for puzzles.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/solo-campaign/1, where 1 is the puzzle number.\n\nUnlike in normal puzzles, in solo campaign puzzles:\n\nThere is a text above the board view indicating what to do to win.\n\nThe game is usually played until the end.\n\nGame mode 3: Play vs AI\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Easy Bot\".\n\nGame mode 5: Play with others\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Matched user\".\n\nGame mode 6: Invite friend\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Friend\".\n\nGame mode 4: Study board\n\nThis takes you to a special instance of the \"game page\" with route wallgame.io/study-board.\n\nThe design for the study board page is work in progress.\n\nFinal thoughts\n\nI usually figure out the shape of things as I build them, like I did for wallwars.net, instead of writing a long design doc upfront. However:\n\nTo justify a full rewrite, I wanted to make sure the new design would accomplish the improvements that I wanted to see on the original site (see the list at the beginning of this post).\n\nAI-assisted coding has made all coding easier, but it has improved new code generation more than it has improved refactoring. For me, this shifted the tradeoff to the point where it seemed worth it to try to preempt as many direction shifts as possible.\n\nIn any case, now that I have this doc, I think it's a good opportunity to test out the various frontend generators (lovable and company) and see what they spit out. I probably won't use any of them directly, but they should give me good ideas for the styling.\n\nI fed this whole blog post to v0.dev (free tier). The prompt was \"Create mocks for the attached design doc.\" + this blog post, which is about 6000 words (a 33kB attachment).\n\nApart from putting the files in the wrong directory, it one-shotted the whole app with great prompt adherence and, in my opinion, great taste to fill in the gaps (recall that this design doc says basically nothing about styling).\n\nYou can see the results below (I skipped the less interesting pages).\n\nI emphasize that I did not have to break down the prompt into smaller chunks, as I'm so used to with tools like Cursor or basically anything LLM-based. I did not have to go screen by screen. It generated about 20 files and 3000 lines of next.js, with all navigation working as expected and mock data. I did not have to carefully craft a prompt on top of the design doc (though you can argue that this blog post is a great prompt). As someone who uses vibe coding regularly, this truly impressed me.\n\nI tried other frontend generators with the same prompt. lovable.dev did OK with prompt adherence (some pages did not work), but it did not have the same taste as v0.dev. It looks like a generic corporate site. Lovable's board component also looks messed up.\n\nbolt.new had great prompt adherence, about the same as v0.dev, but the site looked generic like lovable's (and the board was also messed up). V0 had the best use of space.\n\nOther tools I tried had a prompt length limit, so I didn't bother.\n\nIn the end, I just went back to v0.dev and used the rest of my daily free credits to ask it for different color themes.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-ui",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game DB Design",
      "content": "Wall Game DB Design\n\nThis blog post documents the initial design for the DB schema for the Wall Game, with commentary on the design choices.\n\nDisclaimer: I haven't tested any of the SQL. The site has not been built yet at the time of writing (March 2025). All the screenshots from the site are from a prototype made with v0.dev as explained in this post. As always, if you spot any mistakes or improvements, I'd love to know!\n\nThe DB is a PostgreSQL database, though I aim to keep the schema as dialect-agnostic as possible in case I want to migrate in the future. (You can see this post for a discussion on how I chose the tech stack.)\n\nWe'll start by designing all the tables, as shown in the diagram below, and then we'll write all the queries we need to support the frontend logic.\n\nThis is the main users table:\n\nFuture-proofing auth-provider changes\n\nI tried to future-proof it against auth-provider changes. The plan is to start using Kinde, which means that the only thing we need to store in the DB is a unique user ID provided by Kinde (it looks something like \"kp_a1b2c3d4e5\").\n\nTo avoid coupling, we don't want to use that as the user's primary id. A straightforward approach would be to put it in a separate field:\n\nHowever, in a migration, it may be tricky to coordinate the change of auth_user_id from the old auth provider to the new one. Instead, I decided to just indicate the auth_provider in the users table (e.g., \"kinde\") and put the auth_user_id in a separate table with primary key (user_id, auth_provider):\n\nThis way, a user can have, e.g., a Kinde key and an Auth0 key at the same time, and we can switch from Kinde to Auth0 by changing the auth_provider in the users table from \"kinde\" to \"auth0\" (without deleting the Kinde key yet).\n\nHandling unique usernames\n\nWe allow users to change their display name, and they are allowed to use uppercase letters, but, to avoid impersonation, we enforce that display name must be unique in a case-insensitive way.\n\nWe can think as the lowercase version of their display name as the \"canonical\" name, while the capitalized version is just an inconsequential styling choice. That's why we have both display_name and capitalized_display_name columns.\n\nIn general, the plan is to keep validation logic in the backend, not in the DB. However, I'm particularly concerned about uppercase letters slipping through to the display_name field, so I added the constraint:\n\nEncoding enum-like data\n\nI've considered multiple ways of storing \"enum-like\" data like auth providers, time controls (which can only be \"bullet\", \"blitz\", \"rapid\", or \"classical\") or variants (which will start with only two options, but more will be added over time).\n\nFor example, if we have a column, my_enum, that can only have values \"aa\" and \"bb\", we could do:\n\nPostgreSQL's ENUM type. This is efficient and straightforward, but it would be a bit annoying to add new fields (e.g., \"cc\"), as it would require a (small) schema change. It's also very Postgres specific.\n\nA VARCHAR with a CHECK constraint. This would still require a schema change to add a new value.\n\nA \"lookup table\". We store the allowed values as the primary key in a separate table, say allowed_values, and then have a foreign key constraint on the my_enum column. This allows us to add new values without a schema change.\n\nA \"lookup table\" with an auto-incremented integer primary key. Instead of making \"aa\" the primary key directly, we could make the primary key an auto-incremented integer. This is more flexible and avoids string-matching logic and duplicating strings. However, this requires joins to get the actual names, complicating queries.\n\nUse an integer, and have a convention between the backend and the DB about the mapping from those integers to the actual values. This is the most space- and time-efficient, but it's the most brittle.\n\nIn the end, I decided to KISS and use a plain string column, and just be careful when inserting values.\n\nELO ratings are specific to a variant and time control, so we can't keep them in the users table.\n\nOptimizing the Ranking page\n\nThe final four columns in the ratings table are needed for the Ranking page (the First Game column in the prototype below will be replaced by Join Date):\n\nThese columns are redundant, as they could be computed by aggregating information from the games table. However, it would be expensive to, e.g., look through all the games of a user to find its peak rating. Instead, the plan is to precompute these columns in the backend and update them whenever a user finishes a game.\n\nThe downside of this approach is that the games and ratings tables may be in an inconsistent state. For example, if a game somehow disappears from the games table, a player may end up with a \"3-0\" record even though they only have two games in the DB. I think this is OK. First, it's not clear what should happen if a game disappears--it doesn't retroactively change the fact that the player played three games. Second, we can always run a one-off query to fix the precomputed fields.\n\nInstead of having the backend compute these fields, an alternative approach would be to have a cron job that updates them periodically. However, when a user reaches a new peak rating, they probably want it to be reflected immediately in the Ranking.\n\nGames will only be stored in the DB when they are finished, which allows us to make more assumptions (all players joined, there is an outcome, etc.) and simplify the schema. The downside is that, if the server crashes, all on-going games will be lost. (I once mentioned this concern to a friend and he said, \"But the server shouldn't crash.\" Fair point...)\n\nOptimizing the Past Games page\n\nWe split the game data into two. The main table, games, has all the \"metadata\" about the game, while the game_details table has the actual list of moves and configuration parameters (e.g., variant-specific parameters):\n\nThe reason for the split is that the game details take a lot more space than the other fields, and the main use case for storing games is listing them on the \"Past Games\" page, which doesn't need the game details:\n\nThe query for this page can be based on the games table only. The game details only need to be brought in when the user watches a specific game.\n\nI'm really not sure if this is worth it, though. This may be a premature optimization that adds unnecessary complexity (the two tables now need to be kept in sync and updated together in transactions).\n\nAnother interesting decision was whether to store the moves in a SQL moves table or as a JSON blob. I decided to go with the latter because I don't have any need for querying individual moves within a game or across games. We'll always want either all the moves of a single game, or none. One downside is that we need to precompute the moves_count column in the games table.\n\nGame players\n\nAs you can see, the games table does not capture the players or the game outcome. The reason is that the number of players per game depends on the variant, so we couldn't simply have player1 and player2 columns. For the same reason, the outcome is not as simple as \"P1 won\" or \"P2 won\" or \"draw\". Instead, it makes more sense to think about per-player outcomes. Each player outcome consists of a placement and a reason. E.g., a player may have finished 3rd for the reason that the 4th player timed out.\n\nThe following table connects games and players:\n\nAs we discussed earlier, handling username changes is tricky. If you are watching a past game, do you want to see the current name or the name at the time of the game? In our case, we won't bother with historical names, so we don't need a player_name_at_the_time column. The same for the pawn color and shape they chose at the time. On the other hand, we do want to know their ELO at the time.\n\nLet's discuss the workflow for built-in bots. Besides the main backend, there is a bot service responsible for making bot moves. The main backend stays focused on I/O tasks and doesn't hang on long computations.\n\nThe steps go like this:\n\nThe user chooses the game parameters (e.g., the variant) and chooses to play against a built-in bot.\n\nThe backend asks the bot service for bots available given the game parameters.\n\nThe bot service responds with a list of bot names to display (e.g., \"Easy Bot\", \"Medium Bot\", \"Hard Bot\") along with their bot_id's.\n\nThe player chooses a bot and the game starts.\n\nThe backend asks the bot service for moves from the chosen bot by providing its bot_id.\n\nWhen the game ends, the backend uploads it to the DB. If the bot_id is not in the built_in_bots table, a new row is added:\n\nThe bot service is responsible for choosing and managing bot IDs. The idea is that they should identify a specific algorithm/implementation/binary/version. That is, if I train an improved version of the \"Hard Bot\", the display name can stay the same, but the bot_id should be different.\n\nThe backend and the DB don't need to know which bot_id's can play in which variants and things like that. The backend doesn't ask the DB for which bots are available--it asks the bot service. So, there is no variant column and such in the built_in_bots table.\n\nCustom bots\n\nCustom bots are not fully designed yet, but, for an initial design, we don't need a table for custom bots. When a user chooses to play against their own custom bot, the user is given a token to join the game from their bot client. The client only provides moves (as if it were a human), and does not have its own display name or bot id (to avoid having to deal with clashes with real users or built-in bots). The display name can always be \"Custom Bot\".\n\nIn a full-fledged custom bot system like the one on Lichess, custom bots are just like regular users (with some limitations). Anyone can list their bot, and then players can invite them to a game and they'll join just as if you invited a regular user. This is out of scope.\n\nA puzzle is a game that has been setup to a specific situation where there is a good move (or sequence of moves) that the user must find. Here is Puzzle 10 from the first version of the site, wallwars.net:\n\nHere is the main puzzles table. The specific initial configuration (pre-existing walls and player positions) is part of the game parameters.\n\nTo track completions:\n\nA complication with the Wall Game (compared to, e.g., chess) is that there are often many moves that achieve the same effect. E.g., if there is a long 'tunnel' that is one row wide, putting any wall along the tunnel has the same effect of blocking it. There can be 100's of equally good moves in realistic situations. Thus, we cannot simply check whether the user finds the \"correct\" move.\n\nInstead of \"hard-coding\" the solution, we can compare the user's move against the moves of a bot which is smart enough to solve the puzzle. If the bot scores the player's move as tangibly worse than its top choice, the move is considered wrong. The same bot also counters the player's moves. This goes on until the game ends (the player wins or draws) or until the user has made a predetermined number of moves (which can be specified in the puzzle_metadata). If necessary, we can experiment with fine-tuning the baseline AI to solve specific puzzles. We'll see.\n\nFor now, we don't support user-created puzzles.\n\nUser settings\n\nThe final tables store the user settings.\n\nThe following queries power the functionality we need for the site.\n\nGame showcase\n\nThe landing page shows a showcase from a past game, which autoplays the moves. This requires pulling a random game from the DB, including the moves.\n\nWe can get it with this query:\n\nTo reduce DB queries, the backend could send the same showcase game to multiple users.\n\nSolo campaign & Puzzles\n\nWhen the user goes to the 'Solo Campaign' page, they can see an ordered list of \"levels\" (i.e., puzzles) in order. Each level has a name, description, difficulty, and completion status.\n\nWe can pull them with this query:\n\nThe 'Puzzles' page is similar.\n\nWe include p.config_parameters and p.puzzle_metadata in the query so that, when the user clicks on a puzzle/level, we have everything we need to set it up and start playing.\n\nAvailable games\n\nPlayers can see a list of games in the matchmaking stage, where the user is waiting for an opponent.\n\nWe won't use SQL for this. These games haven't finished yet, so they are not in the DB--only in the backend.\n\nImplementing pagination and filtering\n\nThe 'Ranking' and 'Past Games' pages allow the user to essentially inspect the ranking and games tables, respectively, with pagination and filtering. This gives rise to a basic yet tricky software architecture question:\n\nSuppose you have a full-stack app and there is a large table in the DB, which the user can browse in the frontend. We show the user 100 rows at a time, and they can navigate to the next or previous 100 rows. How do you implement this pagination? (We could ask the same about filtering.)\n\nAssumptions:\n\nThe table is not just static data; it gets updates over time.\n\nThe rows must be shown to the user sorted by a specific column, say, 'rank'.\n\nThe backend runs on a single server.\n\nYou have 3 main options for where to implement pagination:\n\nAt the DB level: this is slow, as it requires a DB round-trip every time the user wants to see a new 100-row block, but it guarantees the data is never stale and the backend can remain stateless. We can add a table index on the 'rank' column to speed up the query.\n\nAt the DB level: this is slow, as it requires a DB round-trip every time the user wants to see a new 100-row block, but it guarantees the data is never stale and the backend can remain stateless. We can add a table index on the 'rank' column to speed up the query.\n\nAt the backend level: if the backend maintains a cached copy of the table (say, as an array), it can return the appropriate range of the array to the frontend, avoiding the DB. This introduces the problem of how to keep the backend's copy of the table always synced with the DB and sorted by 'rank'. For the former, the backend would need to do parallel updates to the DB and the cache. For the latter, if re-sorting on each update is too expensive, something like Redis could take care of it for us.\n\nAt the backend level: if the backend maintains a cached copy of the table (say, as an array), it can return the appropriate range of the array to the frontend, avoiding the DB. This introduces the problem of how to keep the backend's copy of the table always synced with the DB and sorted by 'rank'. For the former, the backend would need to do parallel updates to the DB and the cache. For the latter, if re-sorting on each update is too expensive, something like Redis could take care of it for us.\n\nAt the frontend level: whenever the user goes to the page, the backend sends the full table (or a big chunk of it), not just the first 100 rows (the backend either maintains a cached copy or queries the DB). This approach makes pagination the most responsive, involving no API calls, but it is also the most stale, as the data won't update until the user refreshes the page. In this case, whether the backend maintains a local copy or not only affects the initial load time.\n\nAt the frontend level: whenever the user goes to the page, the backend sends the full table (or a big chunk of it), not just the first 100 rows (the backend either maintains a cached copy or queries the DB). This approach makes pagination the most responsive, involving no API calls, but it is also the most stale, as the data won't update until the user refreshes the page. In this case, whether the backend maintains a local copy or not only affects the initial load time.\n\nEach approach has its pros and cons. It comes down to the numbers, like the number of rows, the size of each row, the frequency of updates, the duration of a round-trip, how often each feature is used, and so on.\n\nDid I miss any other options?\n\nUltimately, there's no right answer, as it also depends on subjective factors like how much you care about user experience vs data freshness, or how much you care about adding engineering complexity.\n\nThe same decision about where to do pagination also comes up with row filtering and ordering. It can be done in the DB, backend, or frontend.\n\nFor our site, we'll start with the slowest but simplest solution (DB round-trip each time), and we'll optimize as needed.\n\nThe 'Ranking' page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe mandatory filters are 'Variant' and 'Time control'.\n\nBy default, the ranking shows the top 100 players for that variant and time control. We can use pagination to see more.\n\nTo fill in each row, we need the following data: rank, player, rating, peak rating, record wins and losses, user creation date, and date of the user's last game.\n\nThere is also an optional 'Player' search box. If filled with a player name and the player exists, it jumps directly to the page (100-block) containing that player. If the player does not exist, it shows nothing.\n\nAs mentioned, we'll implement pagination and filtering in the DB. We can add a table index on the display_name column to speed up the \"player search\" query:\n\nHere is the full query:\n\nWe include deleted players in the ranking. They'll just show up as something like \"Deleted User 23\".\n\nWe already discussed the 'Past games' page in the Games section. All the filters have an \"all\" option which is the default:\n\nTime control\n\nBoard size: selector with (small / medium / large / all). Games are grouped by board size according to width x height: \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares).\n\nELO: a numerical range (missing from the 'Past games' page screenshot)\n\nTime period: a date range (missing from the 'Past games' page screenshot)\n\nTwo player filters: filling one gives you all games with that player. Filling both gives you all games including both players.\n\nWe also need pagination: we'll show up to 100 games per page and let the user navigate to the next/previous 100-block.\n\nTo fill in each row, we need the following data: variant, rated, time control, board width and height, names and ELOs of all the involved players (could be more than 2 depending on the variant), the number of moves, and the date when the game was played. We also need the game id in case the user wants to watch the game.\n\nWhen the user selects a game to watch, we need to get the moves and configuration parameters, as well as the players' chosen pawn colors and shapes, which we can pull from the user_settings table:\n\nUser settings\n\nWhen the user goes to the 'Settings' page, they can change the following settings, and this is stored in the DB:\n\nDisplay name\n\nBoard theme\n\nCat pawn shape\n\nMouse pawn shape\n\n... (one selector for each pawn type that appears in any variant)\n\nDefault variant\n\nDefault time control\n\nDefault rated status\n\nDefault parameters for each specific variant\n\nWe pull the settings with this query:\n\nTo guarantee unique usernames, a user can only change it to a username that does not appear in the DB. We can check this with this query:\n\nWe'd also need queries to update each user settings (changes take effect immediately--there's no final \"Update\" button in the UI), but these are straightforward.\n\nFinally, if a user chooses to delete their account, we need to rename them to \"Deleted User #\" where # is the next available number among deleted users, starting from 1. We can do this with this query:\n\nThe actual user record remains in the database to maintain game history and statistics, but the user can no longer log in and their personal information is removed.\n\nThis concludes the discussion of the DB schema for the Wall Game, a series of blog posts on building a multiplayer online board game. Next, we'll deep dive into how to train an alpha-zero-like AI for the Wall Game.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-db",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Why Many Greedy Algorithms Are Pickier Than They Need To Be",
      "content": "Why Many Greedy Algorithms Are Pickier Than They Need To Be\n\nIntroduction\n\nThe image below shows four problems from completely different domains. A possible solution to each is shown in red.\n\nThe solutions in red are not just any solution. They are the results of well known greedy algorithms for each of these problems. Greedy algorithms, soon to be covered in detail, follow intuitive rules: in clustering, cluster together the two closest points. In routing, use the shortest edge in your route. In shorest superstring, combine the two strings that overlap the most. In matching, assign together the worker and task with the cheapest cost.\n\nThis article is not about any of these algorithms in particular, but about something they have in common. We will take a look at greedy algorithms like those above and see that it is often possible to design alternative algorithms (what I will call local greedy algorithms below) with \"weaker\" selection rules that somehow still end up with the same solution. The meaning of this will become clear in time. This observation changed my understanding of greedy algorithms and led to many of the results in my research. I dedicated chapter 2 of my thesis to it. This article presents the main takeaways from that chapter and illustrates them with plenty of examples without getting into the weeds.\n\nScope: this article is intended for people interested in algorithm design. It only requires a basic understanding of algorithms, as I tried to keep it self-contained except for the references, which can be found in my thesis (Disclaimer: I will shamelessly not include any references here). The article begins explaining greedy algorithms and this idea of \"weakening\" their selection rules. We will then look at standard greedy algorithms for 6 different problems, analyze their selection rules, and find ways to weaken them. Half-way through, once we have built some intuition, I explain the necessary conditions for this to be possible. Since the greedy algorithms I consider are not new, I will not get into their runtimes or approximation ratios here. This, again, can be found in the references. I hope you find it interesting!\n\nGreedy algorithms\n\nGreedy algorithms are perhaps the most common way to approach optimization problems. They can be used in a broad class of problems where the input is a set of elements which need to be arranged into a solution. The input elements could be nodes in a graph, points in space, strings, tasks to be scheduled... The structure of the solution depends on the problem: perhaps we need to select a subset of the input elements, order them, group them in some fashion... Many optimization problems can be defined by just two things: a criteria that determines what constitutes a valid solution, and an objective function among valid solutions. The goal is to find a valid solution optimizing the objective function.\n\nWe focus on problems of this type. A classic example is the maximum-weight matching problem (MWM): Given an undirected graph with weighted edges, find a matching (a pairing of the nodes such that each node is in at most one pair) of maximum weight.\n\nGreedy algorithms are often employed for this kind of combinatorial problems because they have an exponential number of potential solutions. For instance, the number of different subsets of a set of n elements is 2^n, while the number of orderings is n!. Thus, brute force search is too expensive.\n\nThe greedy approach is to construct a solution one component at a time. At each step, we consider a set of legal choices that allow us to make progress towards a solution. Among those, we choose the one that seems best according to an evaluation function. This function, which the algorithm designer must devise, should evaluate the utility of each choice, i.e., how \"desirable\" it appears in terms of reaching a good solution. Using the right evaluation function is key for the success of a greedy algorithm. The name greedy comes from the fact that once a choice is made, that choice is permanent; in algorithmic terms, there is no backtracking. Given its nature, a greedy algorithm should only consider \"legal\" choices in the sense that they should always lead to a final solution that is valid. However, a choice that seem best at an early stage (according to the evaluation function) may turn out to be suboptimal. This is why, in general, greedy algorithms are not guaranteed to find the optimal solution.\n\nIn the MWM example, a greedy algorithm constructs a matching one edge at a time. At each step, it chooses the edge with the maximum weight among the valid edges (edges that do not connect already matched nodes). While this greedy algorithm is not optimal, its approximation factor is 1/2, meaning that the weight of the resulting matching is guaranteed to be at least half the weight of the optimal one.\n\nHere is an example execution of the Greedy for MWM in a geometric setting. Nodes are points in the plane and every pair of points is connected by an edge with weight proportional to their proximity (closer nodes have higher weight). The greedy algorithm repeatedly matches the closest available pair.\n\nLocal Greedy\n\nAs mentioned, only two ingredients are necessary to design a greedy algorithm: a way to construct a valid solution by making a sequence of choices, and an evaluation function to rank the choices at each step.\n\nUsing these same two elements, we will design a variant of the greedy strategy that we call local greedy. As in a greedy algorithm, a local greedy algorithm constructs a solution by making an irrevocable choice at each step. However, we relax the condition that we must pick the best choice at each step. In order to define the new criteria for picking a choice, we need one more ingredient: a notion of interaction between the available choices at each step. Two choices can interact in two ways. First, in terms of validity: often, making a choice means that another choice stops being compatible with a valid solution. Second, in terms of utility: making a choice might make another one less or more desirable according to the evaluation function. Since not all pairs of choices necessarily interact, this relationship defines an interaction graph: a graph with the set of valid choices as nodes and where edges represent interaction.\n\nIn the greedy for MWM, two edges interact if they share an endpoint, because picking one invalidates the other. For other greedy algorithms, the interactions depend on the problem and the evaluation function.\n\nGiven the interaction graph, we can define the local greedy algorithm. For simplicity, assume that there are no ties in the evaluations of the choices. We call the choice with the highest evaluation globally dominant. We call a choice locally dominant if it has a higher evaluation than its neighbors in the interaction graph. Whereas the standard greedy algorithm makes the globally-dominant choice at each step, local greedy makes any of the locally-dominant choices. Note that there is a unique globally-dominant choice, while there can be multiple locally-dominant ones. The globally-dominant choice is also locally dominant, but the converse is not necessarily true. Henceforth, we refer to the standard greedy algorithm as global greedy (GG) to distinguish it from local greedy (LG).\n\nEven if GG and LG operate over the same set of choices and with the same evaluation function, they have two remarkable differences: first, local greedy is non-deterministic. If there are multiple locally-dominant choices, any of them can be chosen. Thus, one can entertain different strategies for finding locally-dominant choices. In fact, GG is one such strategy, so GG is a special case of LG. The second difference, naturally, is its locality: to implement GG, one needs to know every choice in order to determine the globally-dominant one. In contrast, LG can make a choice while being only aware of its neighbors. The extra freedom and locality are promising angles of attack for the design of algorithms, particularly in distributed and parallelized settings.\n\nWe can turn the Greedy algorithm that we saw for MWM into LG: at each step, choose any edge e={u,v} such that e is heavier than any other edge touching u or v. Repeat until no more edges can be added.\n\nHere is one of the possible runs of local greedy for the geometric version of MWM (the circles pairs are all the options LG can choose):\n\nGlobal-Local Equivalence\n\nAt first glance, LG seems like a downgrade from GG: at best, the choices of LG are as good as those of GG, but they can also be worse (according to the evaluation function). This article is about an observation that was surprising to me: for many greedy algorithms, local greedy produces the same solution as global greedy. (Disclaimer: This is not entirely new, as it was already known for some specific problems, including MWM. However, to my knowledge, it had not been treated as a general phenomenon before my work. See a discussion on related work in my thesis.) We coin the term global-local equivalence (GLE) for greedy algorithms with this property. A consequence of global-local equivalence is that every run of local greedy produces the same solution, the global greedy solution, regardless of the order in which the choices are made.\n\nNot all greedy algorithms exhibit GLE. We will see examples of both and understand the key difference.\n\nMaximum-weight matching\n\nAs mentioned, MWM is one of the problems with GLE. Here we can see that even though the orderings differ, the final matching in the previous example is the same:\n\nI claimed I wouldn't get into proofs, but the proof of GLE for the MWM Greedy is really neat and short so I'll just leave it here.\n\nLemma: Let G be an undirected graph with unique edge weights. Let M1, M2 be any two matchings in G obtained by the local greedy algorithm for MWM. Then, M1=M2.\n\nProof: Assume, for a contradiction, that M1 differs from M2. Let e be the heaviest edge in one (without loss of generality, M1) but not the other (M2). During the course of the algorithm, every edge is either added to the matching or invalidated because a heavier neighbor was picked. Since e is not in M2, M2 contains a neighbor edge e' of e that is heavier than e (see the figure below). However, e' cannot be in M1 because e is in M1. This contradicts the assumption that e was the heaviest edge in only one of the matchings. That completes the proof.\n\nSince any two runs of LG find the same solution, and GG is a special case of LG, it follows that every run of LG finds the same solution as GG.\n\nI'll take a quick detour into the story of GLE for MWM. Before it was discovered, LG was proposed as a \"new\" algorithm and it was proven that it achieves a 1/2 approximation ratio, just like Greedy (of course, they achieve the same approximation ratio because they find the same solution). A funny thing I found is that there is a paper doing an empirical comparison of the solution quality of different MWM algorithms, and it includes the traditional Greedy and LG as different algorithms. They compared two things mathematically proven to be the same. In the experiment, they actually obtain slightly different results for the two, which must come down to handling ties differently. Had they used consistent tie-breaking rules in both implementations, they would have got the exact same numbers, probably rising some questions. Here is the table from their paper (LG is labeled LAM):\n\nSet cover is another classic NP-complete optimization problem: Given a set U and a collection X of subsets of U with positive weights, find a cover of U of minimum weight. A cover is a subset of X such that every element of U is contained in one of the sets.\n\nSet cover has some important special cases such as vertex cover.\n\nThe image below shows a set cover instance: on the left, we have a visual representation of the elements in U and the subsets they belong to. On the middle, the same instance is represented as a bipartite graph where the edges denote that the element belongs to the set. On the left, we have the \"interactions\" between the sets: two sets interact if they have an element in common.\n\nThere is a well known Greedy for set cover which picks one set a time until all the elements are covered. It uses an evaluation function known as cost-per-element. The cost-per-element of a set is the weight of the set divided by the number of still-uncovered elements in it (or infinite, if they are all covered). Greedy always picks the set minimizing the cost-per-element.\n\nTo define LG, we need to start with the interactions: two sets interact if they have an element in common because picking one increases the cost-per-element of the other. Based on this, a set is locally dominant if it has a smaller cost-per-element than any other set with an element in common. LG constructs a cover by repeatedly picking a \"locally-dominant\" until every element is covered.\n\nAgain, we have global-local equivalence in Set Cover. That is, GG and LG always end up with the same cover. To prove it, we cannot use the simple argument we saw for MWM. That proof relies on the ability to identify the heaviest edge where two matchings differ. However, the cost-per-element of the sets depend on the current partial solution, so the evaluations evolve over time. This makes it impossible to pinpoint the first discrepancy. I will later talk about how we proved GLE for set cover and other problems with changing evaluations.\n\nNow, let us look at a greedy algorithm without GLE.\n\nMaximum-weight Independent Set\n\nIn the Maximum-weight Independent Set (MWIS) problem, we are given an undirected graph with weighted nodes, and the goal is to find an independent set of maximum weight. An independent set is a subset of nodes such that no two nodes in the subset are neighbors.\n\nA Greedy for the unweighted case (all nodes have the same weight) starts with an empty solution and adds nodes to it one by one. Since when we add a node to the solution none of its neighbors can be added in the future, the selection rule is to always pick the node that \"invalidates\" the fewest neighbors. That is, neighbors not in the solution nor with a neighbor in it.\n\nThis intuition can be generalized to the weighted case as follows: the Greedy for the weighted case chooses the node maximizing its weight divided by the number of valid neighbors (including itself).\n\nThinking in terms of the interaction graph, picking a node changes the evaluation of the nodes at distance 1 (they become invalid) and at distance 2 (their evaluation improves, because they invalidate one fewer neighbors). Thus, we can turn this Greedy into LG: pick any node that has a better evaluation than any other node within distance 2.\n\nHowever, this local greedy does not necessarily produce the same solution as the Greedy. The next example proves that this Greedy does not have GLE:\n\nThe nodes are labeled with their weights. The edges of the graph are shown in black, and the edges of the interaction graph are shown dashed in blue. Below each node, their initial evaluation is shown in red. Initially, the locally-dominant nodes are the ones with weight 5 and 8. GG chooses the node with weight 8 first, and then (after readjusting the evaluations), the node with weight 6. In contrast, LG could start by picking the node with weight 5, resulting in a different final solution, 8.\n\nI do not mean to imply that LG is not \"good\" without GLE -- only that the solution may differ. In this particular case, even though we do not have GLE, GG and LG guarantee the same approximation ratio. I'll defer to my thesis for more details. Also in my thesis are other Greedys for MWIS that do have GLE, showing that GLE is not only about the problem, but also about the evaluation function.\n\nSo WHEN do we have Global-Local Equivalence?\n\nWhat is the common structure that MWM and set cover have, but MWIS does not? What is the key to GLE?\n\nOne of my favorite results from my PhD is that there is a simple rule for when we have GLE: informally, the key is that the evaluation of the choices must stay the same or get worse over the course of the algorithm. In other words, it should never get better. The intuition is that if a choice, say, C, is better than all its neighbors in the interaction graph (what we call locally dominant) and its neighbors can only get worse as a result of other choices made by the algorithm, then C will remain locally dominant until it is eventually picked. Of course, its neighbors won't be picked before C, because they cannot be locally-dominant while C is present. Conversely, if the choices can get better over time, then a neighbor of C could become better than C and C would stop being locally-dominant, and it may end up not being picked.\n\nWe were able to capture this intuition in a single theorem, from which all the results we have seen follow:\n\nTheorem 2.9 page 20. Let h be a deteriorating evaluation function for a combinatorial optimization problem. Then, the global and local greedy algorithms based on h output the same solution.\n\nIf it's not clear from the context, \"deteriorating\" evaluation functions are those where the evaluations of the choices cannot get better. Let's review the examples we have seen:\n\nMaximum-weight matching: we select edges based on their weights, which do not change until they are picked or become invalid, so the evaluation function is deteriorating.\n\nSet cover: as sets are added to the solution, the evaluation of the remaining sets stays the same or gets worse because there are fewer remaining elements to cover and their cost-per-element goes up. Thus, the evaluation function is deteriorating.\n\nMaximum-weight independent set: as nodes are picked, the evaluation of the remaining nodes can go up. For instance, if a node v has a neighbor that is invalidated by another neighbor, the evaluation of v goes up because now v invalidates one fewer neighbor. Thus, the evaluation function is not deteriorating.\n\nI'll omit the proof to avoid getting technical, but I'll recommend it to readers who enjoyed the proof for GLE for the MWM Greedy. It's an elegant argument (in my opinion) that considers a hypothetical hybrid algorithm that starts behaving as LG and at some iteration transitions to GG. We show that no matter where the switch happens, the final result is the same. Since GG and LG are at the two endpoints of this spectrum (GG corresponds to transitioning immediately, and LG corresponds to never transitioning), the theorem follows.\n\nThe origin of GLE: Hierarchical Clustering\n\nHierarchical clustering deals with the organization of data into hierarchies. Given a set of points, we can construct a hierarchy as follows: each point starts as a base cluster (a cluster is a set of points). Then, a hierarchy of clusters is constructed by repeatedly merging the two \"closest\" clusters into a single one until there is only one cluster left.\n\nA key component of hierarchical clustering is the function used to measure distances between clusters. The image above illustrates the result for a set of points when using the minimum distance among points from different clusters (also known as single linkage) as the cluster-distance metric. Other popular metrics include maximum distance (or complete linkage), and centroid distance (the centroid of a cluster is the point with the average of the coordinates of all the points).\n\nThis process is called agglomerative or bottom-up hierarchical clustering (regardless of the cluster-distance metric used). It creates a hierarchy where any two clusters are either nested or disjoint.\n\nOur work on GLE was inspired by previous work on agglomerative hierarchical clustering. A kind of LG was proposed in the 80's as a way to speed up the construction. Instead of always merging the closest pair of clusters, LG merges any two clusters which are closer to each other than to any third cluster, also known as mutual nearest-neighbors (MNN). They discovered that GLE holds for agglomerative hierarchical clustering, but only for some cluster-distance metrics.\n\nFor example, we have GLE with single-linkage and complete-linkage, but not with centroid distance, as shown in the example below. The hierarchies found by GG and a possible run of LG for the point set on the left, using centroid distance, differ. The points a and b are the closest pair, while c and d are MNN. The centroids of the inner clusters are indicated with red crosses.\n\nThey found that there is no GLE if a new cluster resulting from a merge can be closer to other clusters than both of the original clusters before the merge. For instance, in the example above, the centroid of c and d is closer to b than both c and d. This is why there is no GLE. In contrast, using minimum-distance instead, a new cluster is as far from the other clusters as one of the original clusters were. Thus, we get GLE.\n\nThe intuition is the same as we saw for combinatorial optimization problems: if new clusters cannot get closer to other clusters, then the merges done by the algorithm cannot \"break\" existing mutual nearest-neighbors, and they will eventually be picked. MNN are like locally-dominant pairs of clusters.\n\nUnfortunately, this line of work on GLE died out in the 80's and never branched out beyond hierarchical clustering. In parallel, GLE was discovered for specific combinatorial problems like MWM, but no connection was drawn between the two.\n\nTravelling Salesperson Problem\n\nThe Travelling Salesperson Problem (TSP) is a famous NP-complete optimization problems at the root of most routing problems. One of its variants is Euclidean TSP: given a set of points in the plane, find a cycle going through all the points of minimum total length. The points can be seen as cities that must be visited by a salesperson.\n\nSince TSP is computationally hard, a myriad of heuristic approaches have been proposed, including greedy algorithms. For instance, we can start at a random city and always go to the nearest unvisited city.\n\nA greedy algorithm that seems to perform better in practice is the multi-fragment algorithm. Instead of growing the solution linearly, every node starts as a \"fragment\" of the solution. Then, the multi-fragment algorithm repeatedly finds the two closest fragments and connects them, creating longer fragments. The distance between two fragments, when they consist of more than one node, is the minimum distance between their endpoints. At the end, there is a single path going through every node. Then, the two endpoints are connected, closing the cycle.\n\nHere is an animation of the multi-fragment algorithm. The gray nodes are those that are internal to a fragment and cannot be matched anymore. The closest pair of fragments at each step is highlighted in red.\n\nThis algorithm is very reminiscent of agglomerative hierarchical clustering. We can say that two fragments are MNN if they are closer to each other than to any third fragment. Then, we can define a local greedy alternative algorithm which connects any pair of fragments which are MNN. Note that when we connect two fragments, the resulting fragment cannot be closer to a third fragment than either of the original fragments were. Thus, by a similar argument as we saw for hierarchical clustering, we have GLE.\n\nHere is an animation of the LG algorithm. The dashed red loops highlight all the MNN that we could connect at each step. One of them is chosen arbitrarily.\n\nThe final cycle will be the same regardless of the choices we make:\n\nShortest Common Superstring\n\nShortest Common Superstring (SCS) is an optimization problem over strings: given a set of strings, find the shortest string that is a superstring of all of them. A string is a superstring of another if it contains it consecutively, that is, without additional characters intertwined.\n\nOne of the killer applications of SCS is DNA sequencing. My (limited) understanding is that biologists have methods to sample short segments of a much longer DNA sequence, but they cannot pinpoint exactly where in the sequence the sample was extracted.\n\nThey end up with a big pool of overlapping samples, and SCS is used to try to reconstruct the original sequence from the samples: if the end of a sample has a long matching sequence of characters with the beginning of another sample, it's statistically likely that they come from overlapping sections of the DNA sequence. The shortest common superstring is the string that contains all the samples and finds the most overlaps.\n\nThe problem is NP-hard, but some approximation algorithms are known. The most famous is a greedy algorithm simply known as Greedy (in our context, it corresponds to GG). This algorithm maintains a set of strings. Initially, this set is just the input set. Then, it repeatedly takes two strings in the set with the longest overlap and replaces them with the shortest superstring of both. We call this merging two strings. Greedy finishes when there is a single string left, which is returned.\n\nThis algorithm is similar to the multi-fragment algorithm for TSP, and, indeed, GLE also holds. Here, LG repeatedly merges any two strings which overlap more with each other than with any third string. It is harder to see, but we proved that the resulting merged strings do not overlap more with other strings than the original strings did before the merge.\n\nConclusions\n\nI have shown some instances of GLE, but it would be interesting to find more (if someone knows or finds a greedy algorithm that might have GLE, please do reach out!)\n\nI find GLE interesting on its own, but this article left unanswered a central question: once we have established that we have GLE, how do we actually use it to design faster algorithms? I'll leave that for a future entry (or, see the next chapter in my thesis).\n\nOne of our results is that you can use GLE to speed up the multi-fragment algorithm for Euclidean TSP from O(n^2) (a result from my own advisor 20 years ago) to O(n log n). In other cases, like set cover and the shortest common superstring, we still haven't found a way to implement LG asymptotically faster than GG. However, my research focused on the sequential setting, and I think that GLE has even more potential in distributed and parallel algorithms, which I did not have time to explore much!\n\nFinally, I will mention again that all the references for the problems and algorithms discussed here can be found in my thesis. Many thanks to my colleagues Daniel Frishberg and Pedro Matias, and my advisors Michael Goodrich and David Eppstein, with whom I worked closely developing these ideas.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/greedy-algorithms",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Choosing a tech stack in 2025",
      "content": "Choosing a tech stack in 2025\n\nI'm rebuilding one of my side projects from scratch, the Wall Game. The first version is playable at wallwars.net.\n\nOne of the first choices for a new project is the tech stack, so this blog post will go over my choice for this project and the thought process behind it.\n\nRequirements\n\nTo choose a tech stack, we should start from the features we need.\n\nIn this case, the easiest way to think about the feature set is that we are building a Lichess clone (lichess.org), except for a different board game.\n\nI'll list here the main features and their implications about the tech we need.\n\nReal-time turn-based multiplayer games. Implications: This means using websockets, the main networking protocol for this use case. This also means that \"serverless\" backends are out of the question.\n\nImplications: This means using websockets, the main networking protocol for this use case. This also means that \"serverless\" backends are out of the question.\n\nMatchmaking: people can broadcast if they are looking for someone to play, and everyone online should be able to see it. Implications: This requires a broadcasting mechanism. Websockets also handle this use case.\n\nImplications: This requires a broadcasting mechanism. Websockets also handle this use case.\n\nHuman-level bots running Deep WallWars, an Alpha-Zero-like AI. Implications: The AI requires a beefy CPU (for the MCTS) and GPU (for ML model inferences) per move. This means that either the server needs access to GPUs (which would be very expensive in a cloud provider) or, the AI needs to be self-hosted. The current version of the game has a C++, minimax-based bot that runs on the frontend. This requires transpiling C++ to WASM, which hasn't worked well in every browser/device. After dealing with that, I think it's not worth it, so this time I'm only considering bots that run on the backend.\n\nImplications: The AI requires a beefy CPU (for the MCTS) and GPU (for ML model inferences) per move. This means that either the server needs access to GPUs (which would be very expensive in a cloud provider) or, the AI needs to be self-hosted.\n\nThe current version of the game has a C++, minimax-based bot that runs on the frontend. This requires transpiling C++ to WASM, which hasn't worked well in every browser/device. After dealing with that, I think it's not worth it, so this time I'm only considering bots that run on the backend.\n\nUser accounts. We want to handle a mix of non-logged-in and logged-in players seamlessly. Ideally, we want to support something like Google log-in. Implications: This means either implementing authorization from scratch (this would be my first time) or using an auth provider.\n\nIdeally, we want to support something like Google log-in.\n\nImplications: This means either implementing authorization from scratch (this would be my first time) or using an auth provider.\n\nSatisfying visuals and animations. Implications: We need a modern UI library that supports animations without requiring being an expert (which I'm not). As much as I love Lichess, I want the game to have more dynamic visuals and animations.\n\nImplications: We need a modern UI library that supports animations without requiring being an expert (which I'm not). As much as I love Lichess, I want the game to have more dynamic visuals and animations.\n\nPhone and tablet support. A native phone app may come later, but for now I want the website to work well on every device. Implications: A mature UI library that supports responsive design.\n\nImplications: A mature UI library that supports responsive design.\n\nDB for things like finding recent games, your game history, leaderboards, etc. Implications: We don't have any need for NoSQL features. A SQL DB should do just fine.\n\nImplications: We don't have any need for NoSQL features. A SQL DB should do just fine.\n\nAllowing users to provide their own AIs. Implications: We will have to provide a game client as a separate repo which people can clone to run their own AI locally and connect to the site. I considered the option of letting users upload their AI code to the backend, but I don't want to deal with the server costs or security concerns.\n\nImplications: We will have to provide a game client as a separate repo which people can clone to run their own AI locally and connect to the site.\n\nI considered the option of letting users upload their AI code to the backend, but I don't want to deal with the server costs or security concerns.\n\nA blog for dev journaling--you are probably reading it. Implications: An SSG (static-site generator) is a good fit for this.\n\nImplications: An SSG (static-site generator) is a good fit for this.\n\nA community space to discuss the game. Implications: I already set up a discord server for the first version of the game: discord.gg/6XFsZHGZ. :)\n\nImplications: I already set up a discord server for the first version of the game: discord.gg/6XFsZHGZ. :)\n\nThe following features have no additional implications on the tech stack, as far as I can tell, meaning that any stack should be able to handle them more or less equally well:\n\nSingle player modes: playing vs bots, puzzles, and analysis board.\n\nELO system and rating-based matchmaking.\n\nIn-game chat (this is handled by websockets).\n\nSpectating on-going games (this is handled by websocket broadcasting).\n\nSound effects and music.\n\nKeyboard support.\n\nModel training for the AI. This will be an offline process based on PyTorch, independent of the app's tech stack.\n\nPuzzle generation. The puzzles will be generated and uploaded to the DB as part of an offline process.\n\nNon-functional requirements\n\nThis app will be heavy on business logic, both in the frontend and the backend. Implication: It would be great if the stack used the same language for frontend and backend to allow us to share business-logic code between them. However, LLMs have made code translation pretty trivial, so this is not a hard requirement.\n\nImplication: It would be great if the stack used the same language for frontend and backend to allow us to share business-logic code between them. However, LLMs have made code translation pretty trivial, so this is not a hard requirement.\n\nUsually, apps have minimal business logic in the frontend, but for a real-time game it is not ideal. For instance:\n\nWe want move legality checks to be instantaneous: if the user hovers over a wall slot, we want to indicate to them if they can place it or not, and this requires bridge-detection graph algorithms. We don't want to add server lag for such things.\n\nPremoves are frontend-only and require graph algorithms like bridge detection to do properly.\n\nSmall storage needs (compared to a media-centered app). All games should be stored but they shouldn't take much space. We don't have to deal with heavy data like images or video. Implications: We don't need some kind of CDN.\n\nImplications: We don't need some kind of CDN.\n\nTests. Implications: I like to keep testing infrastructure to a minimum, so I won't add testing framework as a requirement.\n\nImplications: I like to keep testing infrastructure to a minimum, so I won't add testing framework as a requirement.\n\nSafe rollouts. Implications: We need a cloud provider for the backend that supports CI/CD and a dev environment.\n\nImplications: We need a cloud provider for the backend that supports CI/CD and a dev environment.\n\nLow budget. Since there is no plan to monetize the game, at least initially, we want to keep costs low. Implications: we will try to leverage free-tier plans where possible for cloud services (DB, auth, etc.).\n\nImplications: we will try to leverage free-tier plans where possible for cloud services (DB, auth, etc.).\n\nLLM-friendly stack. I want to be able to do CHOP (chat-oriented programming). Implications: This means that popular frameworks and tools are preferred. Maybe more importantly, stable frameworks are preferred. (It is a pain to work with an LLM with a knowledge cutoff date earlier than the version of a framework you are using.)\n\nImplications: This means that popular frameworks and tools are preferred. Maybe more importantly, stable frameworks are preferred. (It is a pain to work with an LLM with a knowledge cutoff date earlier than the version of a framework you are using.)\n\nBig and stable (i.e., boring) ecosystem. We don't want simple integrations to become an adventure.\n\nMinimize dependencies.\n\nwallwars.net was my first project using npm and I was not mindful to vet dependencies, and it's been a drag to keep them updated. For instance, I used a \"React wrapper\" around Material UI which was not updated when a new React version came out, and it was a pain to migrate out of it (I'm sure js devs can relate). The new philosophy will be to avoid dependencies as much as possible.\n\nAvoid framework and hosting provider lock in.\n\nAt some point, Heroku suddenly removed the free tier that wallwars.net was on. So, the new philosophy will be to try to avoid getting locked in into specific tech or services. Here are some implications of this goal:\n\nThis pushes me away from next.js because of how it subtly and not so subtly pushes you into hosting on Vercel.\n\nI'd rather avoid ORMs (Object-Relational Mappers), or, if I do use one, it should be a thin wrapper around SQL and not use features specific to that ORM.\n\nRolling out my own authentication becomes a lot more appealing, as this can be particularly hard to migrate.\n\nAvoid the complexity of microservices. Exception: it seems like a good idea to have a separate service for computing bot moves, so the main service can stay responsive by avoiding compute-heavy tasks.\n\nException: it seems like a good idea to have a separate service for computing bot moves, so the main service can stay responsive by avoiding compute-heavy tasks.\n\nAvoid slow languages. I'd be concerned about running the game logic in a language like Python.\n\nI'd be concerned about running the game logic in a language like Python.\n\nNon-MVP features\n\nAll of these probably make sense at some point, but that's a problem for future me. The initial scope is just to make the web experience great.\n\nMobile app.\n\nMailing list (to announce things like tournaments).\n\nIn-game purchases.\n\nSubjective preferences\n\nAfter the requirements, a less important factor is the developer's (i.e., my) experience and preferences.\n\nI favor plain old procedural programming, with strong typing. I try to keep as much logic as possible in pure functions, but I don't like when functional languages are forcefully strict about it (e.g., Haskell). I'm allergic to OOP.\n\nI'd probably rank the languages I've used by preference like this: Go > TS > Python > JS > C++ > Java. I like languages a bit on the lower level, so the \"modern C++ replacements\" like Rust and Zig seem appealing if I were to use a new language.\n\nFor this project, I'm not counting \"learning new things\" as a goal. Otherwise, I might prioritize something like Rust for the backend.\n\nAs you can see, the goals are often contradictory. For instance:\n\nDjango is a very stable and mature framework, which is a plus, but it is Python-based, and I want a fast language.\n\nWanting a stable ecosystem would mean avoiding the mess that is the JS ecosystem, but using TypeScript for both the frontend and backend seems like the easiest way of reusing business logic code between them.\n\nWanting a type-safe and fast language points to Rust, but I'm not sure how good LLM completions would be compared to, e.g., TS.\n\nEvery tech has trade-offs, and I'm sure each dev would reach a different conclusion about the right stack based on these requirements. What would you use?\n\nBefore we get to my choice, I'll go over the Lichess stack and the current wallwars.net stack.\n\nLichess stack\n\nLichess is a free open-source online chess platform with a significant share of online chess, only second to chess.com. The Lichess case study should be very interesting to any solo builders: it was built by basically one person, Thibault Duplessis, and it has hosted over 6 billion games. I highly recommend the video, \"How 1 Software Engineer Outperforms 138 - Lichess Case Study\" by Tom Delalande.\n\nLuckily, Thibault has given talks and written about the Lichess stack and the thought process behind it (see his blog and his Reddit AMA).\n\nThibault's philosophy is based on simplicity and minimalism, prioritizing cleaning up tech debt over adding new features. Here's an excerpt from We don't want all the features:\n\nLines of code are not valuable. They are a cost, that is not paid while writing them, but while maintaining them. Sometimes years later. And they pile up.\n\nLines of code are not valuable. They are a cost, that is not paid while writing them, but while maintaining them. Sometimes years later. And they pile up.\n\nHere is the stack:\n\nBidirectional communication: WebSocket\n\nFrontend: Type: SPA Language: TypeScript Framework: Snabbdom CSS framework: Sass\n\nLanguage: TypeScript\n\nFramework: Snabbdom\n\nCSS framework: Sass\n\nBackend: Type: \"Monolith with satellites\" Language: Scala (+ other languages like Rust for special tasks) Framework: Play Framework Ecosystem: Java/JVM Database: MongoDB DB cache: Redis\n\nType: \"Monolith with satellites\"\n\nLanguage: Scala (+ other languages like Rust for special tasks)\n\nFramework: Play Framework\n\nEcosystem: Java/JVM\n\nDatabase: MongoDB\n\nDB cache: Redis\n\nDeployment: Backend host: self-hosted Authentication service: Custom Database host: MongoDB Atlas\n\nBackend host: self-hosted\n\nAuthentication service: Custom\n\nDatabase host: MongoDB Atlas\n\nPhone app: Flutter (Android and iOS)\n\nComments (mostly based on Tom Delalande's video):\n\nScala: Thibault chose it because it is functional, high-level, and, even though it is not popular, it can leverage the JVM ecosystem. That last point is why he chose it over other functional languages like Haskell.\n\nPlay Framework: Thibault says the framework sped up the initial development, but now he would prefer to ditch it and use \"smaller independent libraries that we can swap as needed\" for things like HTTP, routing, JSON, etc.\n\nMongoDB: Thibault would now probably go for PostgreSQL because it's open source and cheaper.\n\nSnabbdom: this is a minimalistic virtual DOM library. Thibault chose it because of its simplicity compared to something like React.\n\nSass: Thibault said \"Sass is annoying, but that's just because CSS is annoying.\"\n\nOne reason why I'm not considering Lichess' stack is that I want the website to have an engaging look and feel, complete with animations and cool visual effects. Thibault said on Reddit:\n\nI'm a programmer, not a designer, that's why it's always been quite bland, with no images and very little colors. I made up for my lack of UI skills by focusing on UX (user experience) and I think it paid out. There's lots to improve, though...\n\nI'm a programmer, not a designer, that's why it's always been quite bland, with no images and very little colors. I made up for my lack of UI skills by focusing on UX (user experience) and I think it paid out. There's lots to improve, though...\n\nwallwars.net stack\n\nThe current site (wallwars.net) was built in 2019. It is based on the popular web stack at the time: MERN (MongoDB, Express, React, Node.js). I actually chose the stack first, because my goal was to learn full-stack development, and then chose the Wall Game as the project to learn on.\n\nContainerization: None\n\nLanguage: JS, latter ported to TypeScript (frontend and backend)\n\nPackage manager: npm\n\nBidirectional communication: Websocket\n\nFrontend: Type: SPA Build tool: the default for CRA (Create React App) Framework: React CSS framework: None, just plain CSS Component library: Material UI Router: React Router AI: C++17 -> LLVM -> WASM (running in the browser)\n\nBuild tool: the default for CRA (Create React App)\n\nFramework: React\n\nCSS framework: None, just plain CSS\n\nComponent library: Material UI\n\nRouter: React Router\n\nAI: C++17 -> LLVM -> WASM (running in the browser)\n\nBackend: Runtime: Node.js Web server: Express Database: MongoDB DB wrapper: Mongoose\n\nRuntime: Node.js\n\nWeb server: Express\n\nDatabase: MongoDB\n\nDB wrapper: Mongoose\n\nDeployment: Backend host: Heroku Authentication service: Auth0 Database host: MongoDB Atlas\n\nBackend host: Heroku\n\nAuthentication service: Auth0\n\nDatabase host: MongoDB Atlas\n\nA lot of the stack is considered fairly outdated now. You can see the replacements in the next section.\n\nTwo special callouts for things I want to change:\n\nMongoDB: NoSQL was a mistake for this application. Everything I need from the DB is easily expressed in SQL.\n\nHeroku: it rug-pulled the free tier, costing $5/month now.\n\nMy choice: modern JS ecosystem\n\nI decided to stick with the JS ecosystem, as it seems to be consolidating around a more stable and sane set of tools.\n\nI'll include this section of the blog post in the system prompt (e.g., \"cursor rules\") when building the game. It will provide useful context for the LLM.\n\nAs discussed in the Requirements section, the main reasons are:\n\n(My impression that) JS frontend frameworks can more easily create slick interactive UIs than other languages because they are closer to the browser. If that's incorrect, let me know!\n\nFactoring out and reusing business logic across frontend and backend.\n\nFrontend-backend communication may work better if they are implemented in the same language. E.g.: Type checking and autocomplete across API boundaries. socket.io is a JS/TS WebSocket implementation with client and server components. The fact that the two sides are built by the same team means it will probably work better out of the box.\n\nType checking and autocomplete across API boundaries.\n\nsocket.io is a JS/TS WebSocket implementation with client and server components. The fact that the two sides are built by the same team means it will probably work better out of the box.\n\nIt's popular, so I'm hoping I'll have an easier time integrating services like authentication, DBs, etc.\n\nLLM friendly-ish. The best frontend generator I know, v0.dev, outputs TS. (Though it will be annoying to deal with evolving APIs.)\n\nAn alright language I'm already familiar with, TS: it's type-safe(ish), fast(ish), and has good DX(ish).\n\nMaybe in the future, the react frontend can become the basis for react native mobile apps.\n\nI used the Youtube video, \"The React, Bun & Hono Tutorial 2024 - Drizzle, Kinde, Tanstack, Tailwind, TypeScript, RPC, & more\" by Sam Meech-Ward as a baseline for the stack. I highly recommend this video!\n\nI found Sam's choices and explanations reasonable and clear, so I didn't change much and didn't do much additional research beyond that. (Any bad choices will be found by the tried-and-true FAFO method.)\n\nType: Monorepo\n\nContainerization: Docker\n\nLanguage: TypeScript (both frontend and backend)\n\nPackage manager: Bun (both frontend and backend)\n\nBidirectional communication: Socket.io\n\nFrontend: Type: SPA (single-page application with client-side rendering) Build tool: Vite Framework: React CSS framework: Tailwind Component library: Shadcn/ui Router: TanStack Router\n\nType: SPA (single-page application with client-side rendering)\n\nBuild tool: Vite\n\nFramework: React\n\nCSS framework: Tailwind\n\nComponent library: Shadcn/ui\n\nRouter: TanStack Router\n\nBackend: Type: Monolith with an external service for bot moves Runtime: Bun Web server: Hono Database: PostgreSQL ORM: Drizzle Bot service: some minimalistic web server (TBD) running the bot (C++, CUDA & TensorRT for inference).\n\nType: Monolith with an external service for bot moves\n\nRuntime: Bun\n\nWeb server: Hono\n\nDatabase: PostgreSQL\n\nORM: Drizzle\n\nBot service: some minimalistic web server (TBD) running the bot (C++, CUDA & TensorRT for inference).\n\nDeployment: Backend host: Fly.io (with self-hosting for the bot service) Authentication service: Kinde Database host: Neon\n\nBackend host: Fly.io (with self-hosting for the bot service)\n\nAuthentication service: Kinde\n\nDatabase host: Neon\n\nDocker should help with things like migrating hosting providers if necessary.\n\nVite is a modern alternative to CRA that covers a lot of functionality, reducing dependencies. For local development, it allows hot reloading/HMR and running TS and JSX code natively. For production, it \"builds\" the frontend (removing TS and JSX, tree shaking, bundling, minification). Vite also allows importing node modules directly in the frontend, which may be useful for sharing code between the frontend and backend.\n\nBun acts as both a package manager and a runtime, replacing both npm and Node. Deno would also work.\n\nInstead of using an SSG like 11ty (eleventy) for the blog, I'm thinking of just using my personal blog, but with a post filter to include only posts related to the game: nilmamano.com/blog/category/wallgame.\n\nHono seems to be recommended over Express because it is more lightweight (it is built directly on top of browser standards, without additional dependencies), at the cost of less available middleware. It has a frontend client which can import the API types, adding type checking between the frontend and backend (in both directions).\n\nDrizzle adds type safety to the database layer. I'm not interested in ORM abstractions/features beyond that, but Drizzle can be used as a thin wrapper around SQL queries.\n\nTanstack Router adds type safety over the normal React Router. It also does file-based routing (à la next.js) instead of code-based routing.\n\nFly.io has a usage-based plan, which means that, if nobody is playing, I don't pay anything. Details: fly.io/pricing.\n\nKinde has a free plan with up to 10500 MAU (monthly active users). After that, it increases steeply. I decided to use an authentication provider to move faster at the start. I may regret this.\n\nNeon has a free plan with only 0.5GB of storage. After that, it is $19/month for 10GB. This seems borderline unacceptable, so I'm happy to hear any suggestions. Maybe Supabase?\n\nRequest-response flow diagram\n\nReact Query (also known as Tanstack Query) is an optional dependency--we could use a raw useEffect hook to fetch data. But it seems like a helpful wrapper around it for handling the data fetching lifecycle of API requests (caching, authentication, loading states, errors).\n\nZod is another optional dependency. Together with Hono's compile-time type checking, it adds defense in depth in ensuring frontend and backend types match. It makes it easier to add runtime validations on data received by the backend. I decided to add it because I hope it will surface tricky bugs earlier. Zod can also be used to validate data sent from the backend to the frontend, but since we have full control over backend responses, compile-time type checking is probably enough.\n\nThe steps for WebSocket messages would be similar.\n\nLocal development with Vite Server Proxy\n\nThis setup is explained by Sam in the video linked above.\n\nIn production, Vite builds the frontend, and the same server that runs the backend also serves the frontend (e.g., wallgame.io/ serves you the frontend and wallgame.io/api/ allows you to call the backend). This simplifies deployment and helps remove CORS issues.\n\nThe question then is: how do we match this situation when developing locally and make it so both frontend and backend share the same port?\n\nLocally, we don't want to use a built/bundled version of the frontend served through the backend. We want to run the frontend directly with Vite to leverage features like \"hot reloading\" and having useful error messages right in the browser during a crash. So, we can get the frontend running (usually on port 5173 for Vite) in parallel to the backend (usually on port 3000). But if we go to http://localhost:5173/api/, we won't get to the backend.\n\nTo fix that, we use Vite Server Proxy. It is a configuration that automatically redirects calls to http://localhost:5173/api/ to http://localhost:3000/api/.\n\nSo, locally, everything goes through the frontend (due to the Vite Server Proxy), while in production, everything goes through the backend. What matters is that, in both cases, the same origin serves the frontend and the backend.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/2025-stack",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Breaking Down Dynamic Programming",
      "content": "Breaking Down Dynamic Programming\n\nNote: the approach in this guide later became the foundation for the dynamic programming chapter in Beyond Cracking the Coding Interview.\n\nIntroduction\n\nWhen I was a TA for \"Algorithm Design and Analysis\", the students struggled with dynamic programming. To simplify/demystify it, I tried to break it down into a logical sequence of steps, each of which should not feel too intimidating on its own. This is explained in detail here. To complement the explanations, there are links to problems on leetcode.com, in case the reader wants to practice. The code snippets are in Python, but Leetcode accepts most popular languages.\n\nOverview: Recursive vs Iterative DP\n\nIn short, dynamic programming (DP) is a technique for problems that seem hard to solve as a whole, but become easy if we know the solution to smaller subproblems. More technically, we can use it in problems where the (value of the) solution can be expressed as an equation which is a function of the input, and is expressed in terms of itself with smaller inputs. This is called a recurrence equation. The classic example is the Fibonacci recurrence: Fib(n) = Fib(n-1) + Fib(n-2).\n\nhttps://leetcode.com/problems/fibonacci-number/\n\nA recurrence equation can be translated into code:\n\nHowever, the above function has an exponential runtime. A recursive function becomes exponential when it is possible to reach the same subcall through different execution paths. In the Fibonacci case, we have the following nested calls: Fib(n) -> Fib(n-1) -> Fib(n-2), and Fib(n) -> Fib(n-2). Since Fib(n-2) is called twice all the work from this call is duplicated, which in turn means that subcalls made from Fib(n-2) will start to duplicate and grow exponentially.\n\nDynamic programming is simply a workaround to this duplication issue. Instead of recomputing the solutions of the subproblems, we store them and then we recall them as needed. This guarantees that each subproblem is computed only once.\n\nThere are two main approaches for DP.\n\nRecursive / Top-down DP\n\nWe start with the code which is a literal translation of the recurrence equation, but then we add a dictionary / hash table to store results.\n\nThere are three changes in the code above:\n\ndeclaring our dictionary for storing results, memo outside the recursive function (memo comes \"memorization\" or \"memoization\", a name used in the literature).\n\nbefore computing the result, we check if the solution has already been computed. This check can be done before or after the base case.\n\nbefore returning, we save the result in the memo table.\n\nUsing a memoization table in this way solves the inefficiency (we will go deeper into the analysis part later).\n\nIterative / Bottom-up DP\n\nInstead of starting from the largest input and recursively reaching smaller subproblems, we can directly compute the subproblems from smallest to largest. This way, we already have the solutions to the subproblems when we need them. For this approach, we change the dictionary for an array/vector, and we change recursive calls for a for loop.\n\nMost problems can be solved with both recursive and iterative DP. Here are some considerations for how to choose:\n\nRecursive DP matches the recurrence equation more directly, so it can be easier to implement.\n\nBoth have the same runtime complexity, but the recursive version will generally have larger constant factors due to all the recursive function calling and due to using a hash table instead of an array.\n\nIterative DP often allows for an optimization to reduce the space complexity (discussed later).\n\nRecursive DP in 5 Steps\n\nChoose what your subproblems are.\n\nFind the recurrence equation.\n\nTranslate the recurrence equation into recursive code.\n\nAdd memoization.\n\n(Optional) Reconstruct the solution.\n\nWe already saw steps 1–4 with the Fibonacci example. Now, we will walk through all the steps in more detail using a more complicated example, the longest common subsequence problem:\n\nGiven two strings s1 and s2, find the length of the longest string which is a subsequence of both s1 and s2. A string t is a subsequence of a string s if every char in t appears in order in s, but are not necessarily contiguous. For example, abc is a subsequence of axbyz, but ba is not (do not confuse subsequence with substring or subset).\n\nhttps://leetcode.com/problems/longest-common-subsequence/\n\nStep 1: choose our subproblems. This varies from problem to problem, but when the input to the problem is a string, a natural way to obtain smaller problems is to look at shorter strings. Here we can use as a subproblem a prefix of s1 and a prefix of s2.\n\nSome notation: let n be the length of s1 and m the length of s2. Let LCS(i,j) be the solution for the LCS problem for the prefix of s1 of length n (s1[0..i-1]) and the prefix of s2 of length m (s2[0..j-1]). Then, our goal is to find LCS(n, m).\n\nStep 2: find the recurrence equation. Now we need to come up with an expression for LCS(i,j) as a function of LCS with smaller indices (as well as a base case). This is the hardest step of DP, and often it is here that we realize that we chose bad subproblems in Step 1. If that happens, hopefully we will discover some hint for what our subproblems should be.\n\nIn order to derive the recurrence equation for LCS, we need the following observation: if the two strings end with the same character c, then, to maximize the length of the subsequence, it is \"safe\" to add c to the subsequence. In contrast, if both strings end with different characters, then at least one of them cannot appear in the subsequence. The complication is that we do not know which one. Thus, instead of guessing, we can simply consider both options.\n\nThis observation yields the recurrence equation (excluding base case):\n\nThis step is not intuitive at first, and requires practice. After having done a few problems, one starts to recognize the typical patterns in DP. For instance, using max among a set of options of which we do not know which one is the best is easily the most common pattern in DP.\n\nStep 3. Translate the recurrence equation into recursive code. This step is a very simple programming task. Pay attention to the base case.\n\nIf we draw the few first steps of the call graph, we will see that the same subproblem is reached twice. Thus, call graph blows up, leading to an exponential runtime.\n\nStep 4. Add memo table. This step should be automatic: one does not even need to understand the previous code in order to add the memo table.\n\nThe base case corresponds to when one of the strings is empty. The LCS of an empty string with another string is clearly an empty string.\n\nIncidentally, if we flip the check on the memo table, the code becomes a bit more streamlined (fewer lines + merging the two returns). I prefer this form (it does the same):\n\nWe have eliminated the exponential blowup. In general, DP algorithms can be analyzed as follows: # of distinct subproblems times time per subproblem excluding recursive calls. For LCS, we get O(nm)*O(1)=O(nm).\n\nStep 5. Reconstruct the solution.\n\nWe used DP to compute the length of the LCS. What if we want to find the LCS itself? A naive way to do it would be to store the entire result of each subproblem in the memoization table instead of just its length. While this works, it is clear that it will require a lot of memory to store O(nm) strings of length O(min(n,m)) each. We can do better.\n\nStep 5, \"Reconstruct the solution\", is how to reuse the table that we constructed in Step 4 to find the actual solution instead of just its length. I said that this step is optional because sometimes we just need the value of the solution, so there is no reconstruction needed.\n\nThe good news is that we do not need to modify the code that we already wrote in Step 4. The reconstruction is a separate step that comes after. In addition, the reconstruction step is very similar (follows the same set of cases) as the step of building the memo table. In short, we use the memo table as an \"oracle\" to guide us in our choices. Based on the values in the memo table, we know which option is better, so we know how to reconstruct the solution.\n\nIn the code above, first we run LCS(n,m) to fill the memo table. Then, we use it in the reconstruction. The condition memo[(i-1,j)] >= memo[(i,j-1)] tells us that we can obtain a longer or equal LCS by discarding a char from s1 instead of from s2.\n\nNote that there is a single recursive call in the reconstruction function, so the complexity is just O(n+m).\n\nIterative DP in 6 Steps\n\nChoose what your subproblems are.\n\nFind the recurrence equation.\n\nDesign the memo table.\n\nFill the memo table.\n\n(Optional) Reconstruct the solution.\n\n(Optional) Space optimization.\n\nThe new/different steps are highlighted. Step 3. is to design the layout of the table/matrix where we are going to store the subproblem solutions. There is no coding in this step. By \"design\", I mean making the following choices:\n\nwhat are the dimensions of the table, and what does each index mean. Generally speaking, the table should have one dimension for each parameter of the recurrence equation. In the case of LCS, it will be a 2-dimensional table.\n\nwhere are the base cases.\n\nwhere is the cell with the final solution.\n\nwhat is the ``dependence relationship'' between cells (which cells do you need in order to compute each cell).\n\nwhich cells do not need to be filled (in the case of LCS, we need them all).\n\nHere is how I would lay out the table for LCS (you can find a different layout in the problems below):\n\nNext (Step 4), we fill the memo table with a nested for loop. If the layout is good, this should be easy. Before the main loop, we fill the base case entries. Then, we must make sure to iterate through the table in an order that respects the dependencies between cells. In the case of LCS, we can iterate both by rows or by columns.\n\nWe obtain the following algorithm:\n\nIn the code above, the base case entries are filled implicitly when we initialize the table with zeros everywhere.\n\nIf we need to reconstruct the solution, we can do it in the same way as for the recursive DP. The only difference is that memo is a matrix instead of dictionary.\n\nSpace optimization\n\nClearly, the space complexity of iterative DP is the size of the DP table. Often, we can do better. The idea is to only store the already-computed table entries that we will use to compute future entries. For instance, in the case of Fibonacci, we do not need to create an entire array -- keeping the last two numbers suffice. In the case of a 2-dimensional DP table, if we are filling the DP table by rows and each cell only depends on the previous row, we only need to keep the last row (and similarly if we iterated by columns). Here is the final version for LCS where we improve the space complexity from O(nm) to O(n+m):\n\nNote: this optimization is incompatible with reconstructing the solution, because that uses the entire table as an \"oracle\".\n\nDP Patterns\n\nHere are some typical patterns:\n\nFor Step 1. The subproblems.\n\nIf the input is a string or a list, the subproblems are usually prefixes or substrings/sublists, which can be specified as a pair of indices.\n\nIf the input is a number, the subproblems are usually smaller numbers.\n\nGenerally speaking, the number of subproblems will be linear or quadratic on the input size.\n\nFor Step 2. The recurrence equation.\n\nOften, we use max or min to choose between options, or sum to aggregate subsolutions.\n\nThe number of subproblems is most often constant, but sometimes it is linear on the subproblem size. In the latter case, we use an inner loop to aggregate/choose the best solution.\n\nSometimes, the recurrence equation is not exactly for the original problem, but for a related but more constrained problem. See an example below, \"Longest Increasing Subsequence\".\n\nPractice Problems\n\nHere are some practice problems showcasing the patterns mentioned above. Follow the Leetcode links for the statements and example inputs. I jump directly to the solutions. I'd recommend trying to solve the problems before checking them.\n\nhttps://leetcode.com/problems/palindromic-substrings/\n\nHere, the goal is to count the number of substrings of a string s which are palindromic. There is a trivial O(n³) time solution without DP:\n\nWe can improve this to O(n²) with DP. The subproblems are all the substrings of s. Let Pal(i, j) be true iff s[i..j] is a palindrome. We have the following recurrence equation (excluding base cases):\n\nBased on this recurrence equation, we can design the following DP table:\n\nThis type of \"diagonal\" DP tables are very common when the subproblems are substrings/sublists. In this case, the base cases are substrings of length 1 or 2. The goal is Pal(0,n-1).\n\nGiven the dependency, the table can be filled by rows (starting from the last row), by columns (starting each column from the bottom), or by diagonals (i.e., from shortest to longest substrings). In the code below, I illustrate how to fill the table by diagonals.\n\nhttps://leetcode.com/problems/minimum-path-sum/\n\nHere, a subproblem can be a grid with reduced width and height. Let T[i][j] be the cheapest cost to reach cell (i,j). The goal is to find T[n-1][m-1], where n and m are the dimensions of the grid. The base case is when either i or j are zero, in which case we do not have any choices for how to get there. In the general case, we have the recurrence equation T[i][j] = grid[i][j] + min(T[i-1][j], T[i][j-1]): to get to (i,j), we first need to get to either (i-1,j) or to (i,j-1). We use min to choose the best of the two. We convert this into an iterative solution:\n\nhttps://leetcode.com/problems/unique-paths-ii/\n\nThis is similar to the previous problem, but we need to accumulate the solutions to the subproblems, instead of choosing between them. Problems about counting solutions can often be solved with DP.\n\nhttps://leetcode.com/problems/longest-increasing-subsequence/\n\nThis problem will illustrate a new trick: if you cannot find a recurrence equation for the original problem, try to find one for a more restricted version of the problem which nevertheless you enough information to compute the original problem.\n\nHere, the input is a list L of numbers, and we need to find the length of the longest increasing subsequence (a subsequence does not need to be contiguous). Again, the subproblems correspond to prefixes of the list. Let LIS(i) be the solution for the prefix of length i (L[0..i]). The goal is to find LIS(n-1), where n is the length of L. However, it is not easy to give a recurrence equation for LIS(i) as a function of smaller prefixes. In particular, the following is wrong (I will let the reader think why):\n\nThus, we actually give a recurrence equation for a slightly modified type of subproblems: let LIS2(i) be the length of the LIS ending at index i. This constraint makes it easier to give a recurrence equation:\n\nIn short, since we know that the LIS ends at L[i], we consider all candidate predecessors, which are the numbers smaller than it, and get the best one by using max. Crucially, this recurrence works for LIS2(i) but not for LIS(i). Here is a full solution:\n\nAt the end, we do not simply return T[n-1] because T is the table for LCS2, not LCS. We return max(T) because the LCS must end somewhere, so LCS(n-1) = LCS2(j) for some j < n.\n\nNote that the runtime is O(n²) even though the table has linear size. This is because we take linear time per subproblem.\n\nhttps://leetcode.com/problems/number-of-longest-increasing-subsequence/\n\nA harder version of the previous problem. A similar approach works. First solve the LIS problem as before, and then do a second pass to count the solutions.\n\nhttps://leetcode.com/problems/shortest-common-supersequence/\n\nThis problem is similar to LCS, and it requires reconstruction.\n\nI should mention that not every problem that can be solved with DP fits into the mold discussed above. Despite that, it should be a useful starting framework. Here are many more practice problems:\n\nhttps://leetcode.com/tag/dynamic-programming/",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/breaking-down-dynamic-programming",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Lifecycle of a CS research paper: my knight's tour paper",
      "content": "Lifecycle of a CS research paper: my knight's tour paper\n\nIn math research, the way we arrive at a proof is nothing like how it is laid out in a paper at the end. The former is messy, full of false starts and dead ends. The latter is designed to be formal, concise, and neutral, devoid of any trace of personality of the authors.\n\nWhile rigor is very important in a paper with theorems and proofs, it has the unfortunate side effect of being unrelatable. A common reaction is \"How did they come up with that? I could never.\"\n\nSo, as someone who'd love to increase interest in theoretical CS research, I'll take one of my papers and try to make it more relatable by talking about everything that is not in it.\n\nI'll choose a paper that was particularly fun: Taming the Knight's Tour: Minimizing Turns and Crossings (co-authored with Juan Jose Besa, Timothy Johnson, Martha C. Osegueda, and Parker Williams).\n\nBackground: the knight's tour problem\n\nA knight is a chess piece that moves in an L-shape:\n\nThe traditional formulation of the knight's tour problem goes as follows:\n\nA knight starts in any square of a chess board. The challenge is to visit every square, without repetition, using only knight moves, and return to the starting square. This puzzle becomes an interesting computational problem when generalized to n x n boards for any n.\n\nThe research group where I did my PhD had a fun little tradition: every Wednesday afternoon, we'd have a \"tea time\", where someone would propose a math riddle, and we'd try to solve it as a group while drinking tea and eating cookies.\n\nOur group does research on graph drawing (among other things), which is the study of graph embeddings in the plane. One of the central questions is about how to draw a graph in the plane with as few edge crossings as possible. With that in mind, I proposed the following problem during tea time:\n\n\"Look at a knight's tour on an 8x8 chessboard as a graph embedding, where the squares are nodes and the knight moves are edges. Can you find the tour that minimizes the number of crossings?\"\n\nThis created a cute intersection between a classic riddle and one of the group's research interests.\n\nThe co-authors mentioned above were other PhD students from the group who came to tea time that week (except for Parker Williams, who will come into the picture later). This ended up being my only publication without any professor involved!\n\n\"Recreational mathematics is a gateway drug to hard math.\" - Erik Demaine (I believe).\n\nInitial exploration\n\nThe first step is always the play around with the problem by hand to start building some intuitions around it. We started drawing tours on the whiteboard while trying to avoid crossings as much as possible.\n\nThe first observation was that the 8x8 board felt too small and constrained to avoid crossings, so we decided that it would be more interesting as a generalized problem in n x n boards for arbitrarily large n. This put us more firmly in CS territory, where we care about how things scale. Instead of finding a specific solution, we were now looking for a generic way of constructing tours for any n x n board with a small number of crossings. That is, we were looking for an algorithm.\n\nUpper and lower bounds\n\nWhen looking at a new problem, it is always a good idea to establish\n\n(1) how well do existing algorithms do on the problem, and\n\n(2) what is the absolute best we could hope for.\n\nThe former sets a baseline for what we have to beat to have something interesting at all; it gives us an upper bound on the number of crossings in the optimal tour. The latter establishes a lower bound.\n\nSometimes, you find that the upper bound and the lower bound match, in which case there is no room for progress and the project is essentially dead.\n\nWhen thinking about these bounds, we realized that it'd be easier, while still interesting, to minimize turns instead of crossings. A \"turn\" is a cell where the knight changes directions. Turns are easier to work with because a cell is either a turn or it is not, while an edge can be involved in multiple crossings. So, we decided to focus on minimizing turns.\n\nAs you can see, we have already reframed the problem twice. Trying to find the most interesting (but still doable) questions is an organic part of research.\n\nWorking with turns instead of crossings gave us a trivial lower bound: every cell along the edge of the board must be a turn, so we have at least 4n - 4 turns on an n x n board.\n\nTo establish an upper bound, we looked at how existing algorithms do on the metric of minimizing turns. We found that there are only two main kinds of knight's tour algorithms:\n\nBacktracking algorithms with heuristics like Warnsdorf's rule. The idea is to construct a tour step by step, always going to the most promising next move (according to the rule), and backtrack if we get stuck. These algorithms, while very effective for 8x8 boards, quickly reveal their exponential nature for larger boards.\n\nDivide-and-conquer algorithms, which split the board into four quadrants, 'solve' each quadrant recursively down to, e.g., 8x8 boards, and then change some of the boundary moves to concatenate the different bits together.\n\nBacktracking algorithms are inherently uninteresting because they don't scale and don't have structure that can be analyzed.\n\nThe divide-and-conquer algorithms, however, allowed us to establish an upper bound: on an n x n board, the board ends up divided into about ~n^2/64 \"tiles\", assuming that the base case is 8x8. Each of these tiles must have at least one turn, so the tours from these divide-and-conquer algorithms have at least O(n^2/64) = O(n^2) turns.\n\nThis leaves us with a very interesting gap between the O(n^2) upper bound and the O(n) lower bound.\n\nAt the time, after playing around with the problem and looking at existing backtracking and divide-and-conquer solutions, I had a strong intuition that O(n^2) was the best possible number of turns. I had an even stronger intuition that O(n) turns was impossible. At best, I thought we could find something in between, like O(n^1.5) turns.\n\nFirst approach: generalizing from small boards\n\nA common problem-solving technique is to look at the solution for small inputs, and try to extrapolate the pattern to larger inputs. In our case, that means brute-forcing the problem for small boards, and see what the optimal solutions look like there. Maybe, that would show us some emergent structure that we could use to construct larger solutions.\n\nHowever, even for small boards, it is far from easy to find the optimal tour. To that end, Tim encoded the problem in the Z3 theorem solver, a general optimization tool, to find the tour with the least number of turns.\n\nThis was a laughable failure: the solver took about 2 hours to run for 6x6 boards (the smallest size with a tour), and it never finished running for the next smallest board with a tour, the 8x8 one.\n\nHere is the optimal tour for 6x6 boards:\n\nLooking at the \"optimal\" tour for 6x6 boards gave absolutely no insight: due to the small size, almost every square was a turn. The optimal tour has a total of 32 turns in 36 squares. Face palm moment.\n\nSecond approach: aim for the sky\n\nThe next approach we tried was to start from the lower bound:\n\n\"If a tour with O(n) turns existed, what would it look like? And, if it is not possible, what exactly is the obstacle?\"\n\nUnderstanding what, exactly, makes a problem hard, can lead to insights for how to address it.\n\nSo, we asked, \"what if none of the inner squares had a turns?\" What if all the turns were along the edges?\"\n\nWe started drawing a tour that would only turn near the edges, like this, knowing that it would be practically impossible to actually finish it:\n\nWe learned that we could cover a compact chunk of the board this way, leaving only the edges to figure out later:\n\nNow, the \"only\" thing that was left to get a tour with O(n) turns was completing the the edges of the board. While obviously hard, it didn't seem outright impossible.\n\nWe started looking at ways of covering a narrow strip, and we found constructions like this, which consists of two separate path segments (red and blue):\n\nSince the previous image shows a way of covering an edge pattern with two path segments, we started exploring the idea of covering the main body of the board with multiple path segments as well. Here's an example with 3 path segments:\n\nA happy idea\n\nAt this point, we still didn't have anything concrete, but we kept exploring patterns.\n\nWe found that using 4 path segments seemed to fill the board with a pretty regular shape:\n\nIt was looking at this that we hit on the key abstraction that made the whole project fall into place:\n\nA 2x2 formation of knights moves kind of like a king. That is, four knights can make straight moves (up, down, left, right) or diagonal moves without leaving any gaps in between.\n\nWhat makes the knight case hard compared to a king is that, when it moves, it leaves \"gaps\" that need to be filled later. But this formation solves this problem!\n\nWe now had a clear direction: instead of traversing the board with a single knight, we'd traverse it with a formation of four knights. Then, somewhere, like in a corner of the board, we'd reserve a special region to tie together the four knights into a single path.\n\nObviously, we still need to work out the \"tie together\" part, but that seemed very doable.\n\nUnlike the divide-and-conquer approaches, this new approach is actually great for minimizing turns. Straight formation moves (up, down, left, right) introduce turns, so they are no good, but consecutive diagonal moves in the same direction do not. Thus, our approach to minimize turns consisted on maximizing long sequences of diagonal moves, resulting in this zig-zag pattern across the board:\n\nAnd this can be tied together into a single tour by filling in the corners carefully:\n\nFiguring out the corners\n\nOne challenge is that different board dimensions require different corner patterns, so we had to put some attention to detail when proving that the construction works for all dimensions.\n\nEventually, we showed that we can handle any board dimensions with some combinations of the following corner patterns:\n\nYou can try different dimensions in our interactive demo here: nmamano.github.io/MinCrossingsKnightsTour.\n\nThis is formalized as Algorithm 1 in the paper (along with a formal proof that it always forms a complete tour).\n\nWith it, we now had our holy grail: a tour with O(n) turns and crossings, since all turns and crossings happen along the edges, which contain O(n) cells. This matches our lower bound, at least asymptotically, defeating my intuition that it was impossible.\n\nNow, if you just read the paper, you'd think that plugging in the right corners was straightforward. And, to be clear, finding corners that work is not too hard. But we still spent a lot of time figuring out the cleanest way to handle them. Here is a collage of sketches we shared in the project's group chat--and it's not all of them:\n\nI could make another collage for how to handle the bottom-right and top-left corners, which we covered with formation moves. For instance, here is some case analysis we did for how to handle these corners for different rectangular board dimensions:\n\nThis case analysis used \"square\" corners in the bottom-left and top-right corners, which we ended up not using in the paper.\n\nLike the tip of an iceberg, a paper hides most of the work that goes into making it.\n\nGeneralizations\n\nWhen presenting a new idea in a paper, it is a good idea to ask \"what other problems can be solved with this idea? can it be generalized to other problems?\" This is a good way to make your paper stronger and increase your chances of getting through peer review.\n\nIn our case, it seemed clear that our idea should be able to handle rectangular boards, so, when we formalized the algorithm, we made it in a way that works for any dimensions where a tour exists (i.e., where the dimensions are not too small and at least one dimension is even).\n\nBut we didn't stop at rectangular boards. Since we had to go through the literature on the knight's tour problem to make sure our idea was new, as we did, we looked at all the variants that people have addressed in the past. Then, we used our knight formation idea to tackle those as well:\n\nTours on boards with three and higher dimensions. Here you can see the 4-knight formation moving from one layer of a 3D board to the next:\n\n(This figure sent me on a side quest to figure out perspective drawing in a 2D drawing editor).\n\nTours that are symmetric under 90 degree rotations. We did this by stitching together four copies of our tour:\n\nTours for \"giraffes\", which move one square in one direction and 4 in the other. This one is funny because it involves a formation of 16 giraffes:\n\nTransition from one diagonal to the next with 16 giraffes is kind of an ordeal:\n\nAnd making sure that the corners tied the 16 giraffes together into a single path was impossible to do by hand. I coded a backtracking algorithm to crack it.\n\nBehold, the ultimate monster:\n\nAnyway, enough horsing around...\n\nWe essentially covered the main variations discussed in the literature. In each case, we mostly had to make tweaks about how to handle corners, but the main idea held well. To me, this suggests that our technique should be the go-to approach for the knight's tour problem even when you don't care about turns and crossings, but I may be biased ;)\n\nBesides these variations, to further strengthen our paper, we also showed that our algorithm was not only efficient (running in linear time) but also highly parallelizable.\n\nApproximation ratios\n\nAs we mentioned, the number of turns on an nxn board, O(n), is asymptotically optimal. That is, our tour is within a constant factor of the optimal number of turns.\n\nHowever, we can refine that: what is the exact number? and how close is that to the optimal number?\n\nThe first question is straightforward: we calculate how many zig-zags the formation makes as a function of n, and then multiply that by the number of turns made by the formation each time it transitions to the next diagonal. In total, we get 9.25n + C turns, where C is some small constant.\n\nThe second question is much more difficult. To know how far we are from the optimal number, we would need the optimal tour, which we obviously don't have. Instead, if we can find some lower bound on the number of turns, then the ratio between the lower bound and our count gives us an approximation ratio of how far off we are from the optimal number in the worst case.\n\nWe already discussed a trivial lower bound: every cell along the edge of the board must be a turn, so we have at least 4n - 4 turns. However, the higher we can take it, the better our approximation ratio will look.\n\nWe were able to prove a lower bound of 5.99n. That is, no matter the approach, there must be at least 5.99n turns in any knight's tour. (The exact statement is: for any ε > 0, there exists an n0 such that, for all n > n0, a knight's tour on an nxn board has at least (6 - ε)n turns.)\n\nThe proof is a bit convoluted, but it comes from a simple intuition (as is often the case...). Take all ~4n edge cells. Each one has two \"legs\": sequences of aligned moves coming out of it. The legs end when they either (a) reach another edge of the board, or (b) run into something that prevents them from reaching it. The idea is that the ~8n legs running across the board make the board too crowded and eventually some of them \"crash\" into each other, creating new turns that are not at edge cells. We show that there must be at least ~2n \"crashes\", bringing the lower bound up to ~6n.\n\nI won't get into why (you can see the paper), but I found it pretty unexpected that the proof involves a fractal, so I'll just show the fractal here out of context:\n\nCombining the upper and lower bounds, we get an approximation ratio of ~9.25/6. A pretty small gap!\n\nSo, what do I think is the actual optimal number? I'm really not sure, but I think it will be easier to raise the lower bound than to lower the upper bound.\n\nEventually, we circled back to the original problem of minimizing crossings, and we were able to show an approximation ratio of ~3 in that case. Our construction has ~12n crossings, and the best lower bound we were able to show is ~4n. (This lower bound seems like low hanging fruit for improvement, if anyone is looking for a problem to work on!)\n\nUnexpected help\n\nOne day, I received the most random (and delightful) of emails: a student from a class I TA'd, Parker Williams, sent me an improvement to our approximation ratio out of nowhere. We had never discussed collaborating on this.\n\nThe email read:\n\nHi Nil, I had a look at the heel in the open problems doc and I couldn't help myself, here are all possible tours for the \"small heel\" (there are possible improvements for both turns and crossings!) the one used in the paper is the fourth one down: I found this list by searching the problem space exhaustively, I was expecting it to take too long and that maybe a greedy/DP type algorithm would be necessary but the whole search actually finished in less than a second in python on a laptop. [...] Are any of the small heel findings valuable? I understand it's a very marginal improvement in upper bound [...].\n\nI had a look at the heel in the open problems doc and I couldn't help myself, here are all possible tours for the \"small heel\" (there are possible improvements for both turns and crossings!) the one used in the paper is the fourth one down:\n\nI found this list by searching the problem space exhaustively, I was expecting it to take too long and that maybe a greedy/DP type algorithm would be necessary but the whole search actually finished in less than a second in python on a laptop.\n\nAre any of the small heel findings valuable? I understand it's a very marginal improvement in upper bound [...].\n\nYes, yes, they are! Parker's optimized diagonal transitions improved our upper bounds from ~9.5n turns and ~13n crossings to ~9.25n turns and ~12n crossings (as mentioned above), tightening the approximation ratios a bit further.\n\nBy that point, we had already published the paper in a conference called FUN (short for \"Fun with algorithms\"), but we had been invited to publish a journal version in TCS, so we added Parker's results to the journal version and added him as a co-author.\n\nStill one of my favorite emails I've ever received.\n\nI hope this post helped demystify CS theory research a bit--even if it is for a silly puzzle that originated at tea time. I may summarize it as: it's not as hard as it seems, but it is more work than it seems. So, enjoying the process and having fun is probably more important than being a genius.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/knights-tour",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Double-Edge Cut Problem",
      "content": "Double-Edge Cut Problem\n\nIn this post, we'll solve a graph problem that comes up in the Wall Game.\n\nSee also the related, but easier, Single-Edge Cut Problem.\n\nThe double-edge cut problem\n\nYou are given an undirected, unweighted graph G with V nodes and E edges, where each node is identified by an integer from 0 to V - 1. You are also given a pair of distinct nodes, s and t, in the same connected component of G.\n\nWe say a pair of edges (e1, e2) is essential if removing e1 and e2 from G disconnects s and t.\n\nImplement a data structure that takes G, s, and t at construction time, and then can answer queries of the form \"Is a given pair of edges essential?\"\n\nIn this post, we'll see how to construct such a data structure in linear time and space (O(V + E)) and answer queries in constant time.\n\nIn this graph, if s is 0 and t is 6, the essential pairs are ((0, 1), (0, 3)), ((2, 4), (3, 8)), and ((2, 4), (7, 8)).\n\nAny other pair of edges can be removed and s and t will remain in the same connected component, even if the graph itself is disconnected. For instance, if we remove (4, 5) and (5, 6), node 5 ends in its own connected component, but s and t are still connected.\n\nBrute force solution\n\nThe brute force solution is to do nothing at construction time. For each query, take each pair of edges, remove them, and then use a graph traversal to see if s and t are still connected. This takes O(E) time per query.\n\nThe brute force implementation is on github. We'll compare it against the optimized solution in the benchmark at the end.\n\nThis is the key problem behind whether a double-wall move is valid or not in the Wall Game. The board of the Wall Game may look something like the picture on the left:\n\nThe right picture is the board modeled as a graph. The cells become nodes and two adjacent nodes are connected if there is no wall between them.\n\nDuring their turn, players can build up to two walls anywhere, which is like removing two edges. The only constraint is that they cannot fully block the opponent's path to their goal (or their own). In this setting, each player forms an s-t pair with their goal, and the essential edge pairs correspond to invalid double-wall moves.\n\nIn the picture, the red player and goal are labeled s and t, and one essential pair is shown in red. There are many more essential pairs.\n\nImagine that you want to implement an engine for the Wall Game. One question you'll probably have to answer frequently is, \"Given a position, is a given move valid?\" The hardest type of move to check is a double wall move (the single-wall move case is handled by the single-edge cut problem). To answer this question efficiently, we can solve the double-edge cut problem and build one data structure for each player; we can query them to check if a double wall move disconnects any player from their goal.\n\nI got nerd-sniped by this problem in 2021, when I was coding an engine for the Wall Game (it's on github; it's in C++ but you can play against it on wallwars.net thanks to WebAssembly). The engine is based on negamax with alpha-beta pruning, and the bottleneck is generating all the valid double-wall moves from a position.\n\nThe move generation implementation from back then already uses some of the ideas we'll see in this post, like the fact that we can precompute two node-disjoint paths for each biconnected component, and two walls can only be an invalid if they are in the same biconnected component and there is one wall in each path (this will make sense later).\n\nHowever, I couldn't figure out how to handle the case of two walls in the same biconnected component and in the two precomputed paths in constant time, defaulting to a full graph traversal for that case (here).\n\nI revisited the problem in 2025 because I'm rebuilding the game. The key new insight is the construction of the path-segment graph, which we'll get to below. Something that was very helpful in this breakthrough was vibe coding a tool to visualize the various graph transformations (we'll see screenshots of it in this post).\n\nYes, I could have coded the visualization tool myself back then, but vibe coding removed the friction. Ironically, vibe coding has a rep for only being good at starting projects and then abandoning them, but here it helped me pick up an abandoned project and finish it.\n\nPreliminary definitions\n\nThe algorithm relies heavily on the concepts of articulation points and biconnected components, so we'll need the following definitions:\n\nA biconnected graph is a graph that remains connected even if any single node is removed.\n\nAn articulation point is a node whose removal increases the number of connected components. A graph is biconnected if and only if it has no articulation points.\n\nA biconnected component is a maximal biconnected subgraph.\n\nA bridge is an edge whose removal increases the number of connected components.\n\nIn a connected graph with at least two nodes, every node is in at least one biconnected component. The graph can be decomposed into what is called the block-cut tree of the graph, which has one node per biconnected component and biconnected components are connected by articulation points. For example:\n\nThis graph on the left has four articulation points: 2, 4, 6, and 7. It has six biconnected components (shown in different colors). The bridges are (7, 9), (7, 8), and (6, 12).\n\nThe block-cut tree is a tree in the sense that there cannot be a cycle of biconnected components--the cycle would collapse into a single biconnected component.\n\nHere are some additional well known properties:\n\nAn articulation point is always in more than one biconnected component. For instance, node 7 in the picture above is in three biconnected components. An edge is always in a single biconnected component.\n\nNot every edge between articulation points is a bridge. For instance, (2, 4) in the graph above is not a bridge.\n\nEvery node adjacent to a bridge is an articulation point with the exception of degree-1 nodes (like 9 in the picture above).\n\nAn edge is a bridge if and only if it is the only edge in a biconnected component.\n\nIn a biconnected component that is not a single edge, there are two node-disjoint paths between any two nodes. For instance, in the blue biconnected component, there are two paths from 2 to 4 that don't share any nodes: 2 -> 4 and 2 -> 10 -> 11 -> 4.\n\nTwo biconnected components can only have one articulation point in common. Otherwise, the two biconnected components would collapse into a single one.\n\nThere cannot be a cycle that is not fully contained in a single biconnected component. Otherwise, all the biconnected components in the cycle would collapse into a single one. (That's why the block-cut tree is called a tree.)\n\nIf a simple path (path with no repeated nodes) leaves a biconnected component, it cannot return to it (for similar reasons).\n\nReduction to biconnected graphs\n\nIn this section, we'll reduce the original problem to the case where the graph is biconnected, which we'll tackle in the next section.\n\nNote that the graph from the Wall Game may not be biconnected. It may not even be connected--see, e.g., the isolated connected component in the top-left corner above. All we are guaranteed is that each player is in the same connected component as their goal.\n\nFirst, we'll get an edge case out of the way: if s and t are neighbors and connected by a bridge, then an edge pair is essential if and only if it contains that bridge.\n\nNext, consider the case where s and t are in the same biconnected component, C (which is not just a bridge). Any edge pair where at least one edge is in another biconnected component is not essential. Thus, we can focus on edge pairs inside C. In fact, when analyzing if an edge pair in C is essential, we can completely ignore the rest of the graph (we can literally remove nodes and edges outside of C). That is because any simple path from s to t must be fully contained in C (Property 8).\n\nIf s and t are not already in the same biconnected component, any path from s to t must go through the exact same sequence of articulation points and biconnected components. Otherwise, there would be a cycle of biconnected components, which is impossible (Property 7).\n\nLet C1, C2, ..., Ck be the sequence of biconnected components that any s-t path must go through. In fact, not only is the sequence of biconnected components fixed, but also the entry and exit nodes of each biconnected component. The entry and exit nodes must be an articulation point, except for C1, where the entry node is s, and Ck, where the exit node is t. This is because there cannot be two articulation points from Ci to Ci+1 (Property 6).\n\nAmong the biconnected components between s and t, there may be one or more consisting of a single edge (i.e., a bridge). Removing that bridge disconnects s and t by itself, so any edge pair containing it is automatically essential.\n\nAside from the specific case of bridge-only biconnected components, there is no way to disconnect s and t by removing two edges from different biconnected components.\n\nWhat that means is that we can tackle each biconnected component C1, C2, ..., Ck independently, and then combine the results.\n\nWe can start by finding the biconnected components of the graph and any s-t path. From there, we can decompose the input graph into C1, C2, ..., Ck, and solve the problem for each of them. Instead of s and t, for each biconnected component, we use the path's entry and exit nodes as the new s and t.\n\nThis all can be done in linear time, and allows us to reduce the general case to a number of instances of the biconnected case, all of which combined have an equal or smaller size than the original graph.\n\nNext, we'll focus exclusively on the special case where the input graph is biconnected.\n\nBiconnected graphs\n\nIn this section, we assume that G is biconnected.\n\nOne obstacle we'll need to overcome is that we cannot possibly store every essential pair in our data structure given the time and space constraints. The worst case for the number of essential pairs in a biconnected graph is about (V^2)/4, which happens when the graph forms a single cycle, and s and t are as far apart as possible in the cycle, with (V - 2)/2 edges between them on each side. In this case, each edge on one side of the cycle forms an essential pair with each edge on the other side of the cycle, for a total of ((V - 2)/2)^2 pairs. Since we want a data structure that takes O(V+E) space, we'll need to store some information that uses less space than the essential pairs themselves, but still allows us to answer queries in constant time.\n\nFinding two node-disjoint paths\n\nIn the algorithm, we'll need to find two node-disjoint paths between s and t, which we know exist because the graph is biconnected.\n\nThe naive approach of finding a simple path, removing the nodes, and then looking for a second path doesn't work, like in this case:\n\nFor example, in this graph, there are two node-disjoint paths from 3 to 2: 3 -> 1 -> 0 -> 2 and 3 -> 4 -> 5 -> 2. However, if we start by finding the path 3 -> 4 -> 0 -> 2 and remove nodes 4 and 0, we won't be able to find a second path.\n\nInstead, we can use the following approach:\n\n1. Take the undirected graph and convert it into a directed graph with the following transformation:\n\nEach node u becomes a pair of nodes, u_in and u_out, connected by an edge u_in -> u_out.\n\nEach undirected edge (u, v) becomes two directed edges, u_out -> v_in and v_out -> u_in. Note that the \"out\" nodes are always connected to \"in\" nodes. The only way to get to u_out is to come from u_in.\n\n2. Next, we need to find two edge-disjoint paths from s_out to t_in in this directed graph. These two paths can be mapped to two node-disjoint paths in the original graph because, for each node u in the original graph, they can't both go through the edge u_in -> u_out in the directed graph.\n\nThis image shows a biconnected graph with two node-disjoint paths from 0 to 5:\n\nFinding two edge-disjoint paths in a directed graph can be done with two iterations of the Ford-Fulkerson algorithm. Essentially, we can think of the directed graph as a flow network, where each edge has a capacity of 1. We then need to be able to send two units of flow from s to t. The paths of the flow form two edge-disjoint paths in the directed graph.\n\nBuilding the directed graph takes linear time, and each iteration of Ford-Fulkerson algorithm requires a linear-time graph traversal. Thus, this all takes linear time (see the TypeScript implementation).\n\nEssential edge candidates\n\nAmong all the edges in the biconnected graph, we will start by filtering down the edges that can be part of an essential pair to a smaller set of candidates.\n\nWe start by finding any two node-disjoint paths from s to t, as described above. Which we'll call the red path (R) and the blue path (B). We'll call the edges in R red edges and the edges in B blue edges.\n\nAn edge pair can only be essential if it has one red edge and one blue edge (otherwise, s and t remain connected via one of the two paths). Thus, we can narrow down the set of candidate edges to those in R and B.\n\nWe can narrow the candidate edges further. Consider a red edge, e1. We know that if e1 is part of an essential pair, (e1, e2), then e2 must be a blue edge. So, if s and t remain connected even after removing e1 and all the blue edges, then we can safely say that e1 can never be part of an essential pair. That is, e1 is not a candidate.\n\nWe can find all the red candidates, which we'll call RC = (r1, r2, ..., rk), in linear time, as follows:\n\nRemove all the blue edges from G.\n\nFind all the bridges in the remaining graph.\n\nRC is the list of red bridges.\n\nSimilarly, we can find all the blue candidates, which we'll call BC = (b1, b2, ..., bk'), by removing all the red edges from G and finding the bridges in the remaining graph that overlap with B:\n\nAn edge pair can only be essential if it contains an edge from RC and an edge from BC.\n\nHowever, not every edge pair with one edge in RC and one edge in RB is essential. For example:\n\nIn this graph, the essential pairs are (r1, b1), (r2, b2), and (r3, b2). Other pairs of candidates, like (r1, b2), are not essential. Intuitively, a pair of candidates is not essential when we can stich together parts of the red and blue paths together that avoid the candidates.\n\nThings will get a bit complicated from now on, so it's worth mentioning that, if we wanted to settle for not-always-constant-time queries, we could simply store the sets of red and blue candidates, and only do an s-t reachability check when we get a query with one red candidate and one blue candidate. For every other edge pair, we can simply return False in O(1) time.\n\nThe path-segment graph\n\nWe'll assume that RC and BC are both non-empty from now on (otherwise, we can just return False for every query).\n\nTo achieve worst-case constant-time queries, we'll need to construct what I call the path-segment graph:\n\nThis is an undirected graph that has one node for each disconnected segment of the red path after removing the red candidates, and one node for each disconnected segment of the blue path after removing the blue candidates.\n\nIn the path-segment graph, we call the nodes for the red segments rs_0, rs_1, ..., rs_k and the nodes for the blue segments bs_0, bs_1, ..., bs_k'. We'll also call them red-segment nodes and blue-segment nodes, respectively.\n\nThe nodes rs_0 and rs_1 are connected by an edge, which we call r1, just like in the original graph. Similarly, rs_1 and rs_2 are connected by r2, and so on, up to rs_k-1 and rs_k, which are connected by rk. The same applies to the blue-segment nodes, so every edge in RC and BC is \"present\" in the path-segment graph.\n\nBesides the RC and BC edges, which connect the nodes of the red-segment nodes and blue-segment nodes in two separate paths, there are also cross edges between red-segment and blue-segment nodes. Intuitively, these edges denote that we can go from one segment of the red path to a segment of the blue path without crossing any of the candidate edges.\n\nHere is the path-segment graph for the example above:\n\nThe red path is broken into four segments: rs_0 is just s, rs_1 is just the node between r1 and r2, rs_2 is the segment up to r3, and rs_3 is the final edge of the red path. Similarly, the blue path is broken into three segments.\n\nIn the path-segment graph, there is always a cross edge between rs_0 and bs_0 because they share the node s. Similarly, there is always a cross edge between rs_k and bs_k' because they share the node t. For this specific example, there is also a cross edge between rs_1 and bs_1 because we can walk from the node to the right of s to the segment of B that starts at the node below s without crossing any of the candidate edges.\n\nNext, we'll describe how to compute the cross edges.\n\nIf we take the original graph and remove all the red candidates and all the blue edges (G - RC - B), we are left with a sequence of connected components, each of which contains one of the red-path segments, and perhaps additional connected components that don't contain any of the red-path segments.\n\nWe call RCC_i the connected component in G - RC - B that contains the red segment rs_i. Thus, the red path traverses RCC_0, RCC_1, ..., RCC_k, in this order. We also do the same for the blue path, and call the components BCC_0, BCC_1, ..., BCC_k'.\n\nHere we can see the two sets of connected components for the example above (shown in different colors):\n\nTo compute the cross edges in the path-segment graph, we first label all the nodes in the original graph according to which RCC_i and BCC_j connected components they belong to. Then, we add a cross edge between rs_i and bs_j in the path-segment graph if and only if there is a node in the original graph that is in both RCC_i and BCC_j.\n\nHere is another example of path-segment graph:\n\nIn this graph, the essential pairs are (r1, b1), (r1, b2), (r4, b3), and (r4, b4).\n\nThis example shows that there can be candidates that are not part of any essential pair (r2 and r3 in this case).\n\nYou can create the visualizations above for any grid graph with a visualization tool I vibe coded: https://github.com/nmamano/two-edge-removal-problem/tree/main/python_visualization\n\nThe path-segment graph can be computed in linear time. In particular, it has at most V cross edges, since each cross edge (rs_i, bs_j) requires a node in the original graph contained in both RCC_i and BCC_j.\n\nReducing connectivity in the original graph to connectivity in the path-segment graph\n\nStarting from this section, we need one more bit of notation: we use the subindex >=i to indicate \"all subindices greater than or equal to i\" and the subindex <i to indicate \"all subindices less than i\".\n\nThe following lemma shows that instead of checking if a candidate pair, (ri, bj), disconnects s and t in the original graph, we can check if it disconnects rs_0 and rs_k in the path-segment graph. This makes our job easier since the path-segment graph is structurally simpler than the original graph.\n\nLemma 1: A candidate pair (ri, bj) is essential if and only if it disconnects rs_0 and rs_k in the path-segment graph.\n\nIn other words:\n\nIf removing (ri, bj) disconnects rs_0 and rs_k in the path-segment graph, then it disconnects s and t in the original graph.\n\nIf removing (ri, bj) does not disconnect rs_0 and rs_k in the path-segment graph, then it does not disconnect s and t in the original graph.\n\nStarting with (2), if there is a path from rs_0 to rs_k in the path-segment graph that does not use ri or bj, we can turn it into an s-t path in the original graph that does not use ri or bj either: we follow one of the paths, say R, until we have to use a cross edge in the path-segment graph, say, (rs_x, bs_y). We know that RCC_x and BCC_y share at least a node, v, so we can find a path from one of the nodes in the path segment for rs_x to v and from v to one of the nodes in the path segment for bs_y. We can then continue following the other path, B, until we reach t or need to use another cross edge, which we can handle in the same way.\n\nFor (1), we want to show that there is no s-t path in the original graph without ri and bj.\n\nBy definition, without ri, there is no way to get to RCC_>=i without using blue edges. However, using blue edges before bj still does not allow us to reach any nodes in RCC_>=i (otherwise, rs_0 and rs_k would still be connected in the path-segment graph thanks to a cross edge).\n\n(The proof for (1) is admittedly hand-wavy, I may have to revisit it.)\n\nCompressing the path-segment graph\n\nThe following lemma will allow us to do a final transformation to the path-segment graph to further simplify its structure (the exact reason will be clear later).\n\nLemma 2: The following two statements are equivalent: (a) A candidate pair (ri, bj) is essential; (b) for every cross edge (rs_x, bs_y) in the path-segment graph, ri and bj are both on the same side of that cross edge (i <= x and j <= y, or i > x and j > y).\n\n(a) => (b) direction: Assume, for the sake of contradiction, that (ri, bj) is essential but there is a cross edge (rs_x, bs_y) such that i <= x and j > y. Then, we can go from rs_0 to bs_0, from bs_0 to bs_y, from bs_y to rs_x, and from rs_x to rs_k. This contradicts that (ri, bj) is essential. The other case is symmetric.\n\n(b) => (a) direction: cross edges of the form (s1_<i, s2_<j) do not allow us to \"skip\" over ri and bj. Cross edges of the form (s1_>=i, s2_>=j) have two endpoints neither of which can be reached from rs_0 in the first place.\n\nLemma 2 is important for the following reason:\n\nIf we have a chain of edges in the path-segment graph, rx, ..., ry, without any cross edges coming out of the nodes between them, then all the edges in the chain have all the same cross edges on each side. A corollary of Lemma 2 is that combining any of these edges with a blue candidate, bj, has exactly the same effect on whether rs_0 and rs_k stay connected. Thus, we can compress the chain into a single edge, r_x,y, as shown in the figure:\n\nIn this path-segment graph, we compressed r1, r2, and r3 into r_1,3, left r4 alone (relabeled as r_4,4), and compressed r5 and r6 into r_5,6. The blue candidates got compressed similarly.\n\nThe result is a new graph, which we call the compressed path-segment graph. It is similar to the path-segment graph, but with potentially fewer nodes and edges.\n\nWe call a pair of edges in the compressed path-segment graph, (r_x,y, b_z,w), essential if they disconnect r_0 and r_k. What that means is that any red candidate compressed into r_x,y forms an essential pair with any blue candidate compressed into b_z,w.\n\nThe compressed path-segment graph has the property that every node is adjacent to at least one cross edge. This is important for one reason:\n\nIn the normal path-segment graph, an edge in the top path could form an essential pair with many edges in the bottom path, leading to a potentially quadratic number of essential pairs. In the compressed path-segment graph, each edge in the top path can only form an essential pair with at most one edge in the bottom path. This is because of Lemma 2: there are cross edges between every pair of edges in the bottom path, so only one of them can match the position of the top edge relative to all the cross edges.\n\nFinally, we reached a point where we can store all the essential pairs in O(V) space. We can only do this because each edge of the compressed path-segment graph represents potentially many candidates in the original graph.\n\nNow, we just need to compute them in linear time.\n\nComputing essential pairs in the compressed path-segment graph\n\nWe can use a straightforward two-pointer algorithm, with one pointer for each path. The red pointer starts at the edge r_1,x and the blue pointer starts at the edge b_1,y. For each pointer, we keep track of which cross edges we've already passed. Then, we have a case analysis:\n\nIf both pointers have passed the same cross edges, mark the current edge pair as essential, and advance both pointers.\n\nIf the red pointer has passed any cross edges that the blue pointer hasn't passed, advance the blue pointer.\n\nIf the blue pointer has passed any cross edges that the red pointer hasn't passed, advance the red pointer.\n\nWith this method, we can find and store all the essential pairs in the compressed path-segment graph in O(V) time.\n\nTo know if a pair of candidates (ri, bj) in G is essential, we check if the compressed edges they belong to form an essential pair in the compressed path-segment graph.\n\nImplementation\n\nIn this section, we'll see how all the pieces fit together by designing the full data structure as described at the beginning of the post.\n\nThe data structure is implemented in TypeScript here. There is also the brute-force solution, tests, the visualization tool (in Python), and a little benchmark we'll use for the next section.\n\nConstruction:\n\nThe only constraint on G is that s and t are connected and different.\n\nTime and space: O(V + E).\n\nTime and space: O(1).\n\nI generated 10 random 30x30 grid graphs, where each edge is present with probability 0.5. For each graph, I picked s and t randomly, making sure that s and t were connected.\n\nI then initialized the data structure for each graph and queried it with every edge pair in the graph. I also ran all the queries with the brute-force solution.\n\nHere are the results:\n\nThe bigger the graph, the more queries we can do, and thus the more the preprocessing pays off. With 11x11 grid graphs, which is the standard size for the Wall Game, we do only ~15k queries per graph, and the speedup is only about 6x.\n\nFor both 30x30 and 11x11 grid graphs, the construction of the data structures is about 3 orders of magnitude slower than solving a single query directly with a graph traversal. This is surprising, given the optimized data structure only does a constant number of graph traversals (about 10). My theory is that the overhead comes from allocating memory (e.g., for the various derived graphs; the keyword new appears ~30 times in the code) and from the use of hash sets and maps.\n\nOptimizing the code was not the main point of this post. It can be optimized further by doing things like:\n\nPre-allocating and reusing the visited and stack arrays across all the functions that need to do some kind of graph traversal.\n\nNot explicitly constructing the directed graph in findTwoNodeDisjointPaths().\n\nNot explicitly constructing graphs like G - R, G - B, G - R - BC, and G - B - RC. Instead, we can pass around a set of \"disallowed\" edges. (The path-segment graph and the compressed path-segment graphs are already not constructed explicitly.)\n\nAvoiding hash sets and maps with edges as keys. Instead, edges could be mapped to contiguous integers from 0 to E - 1 (I already avoided using sets and maps when the keys are integers starting at 0, like node indices).\n\nChoosing a better language for low-level optimizations...\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/double-edge-cut-problem",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Negative Binary Search and Choir Rehearsal",
      "content": "Negative Binary Search and Choir Rehearsal\n\nOne of the points we touch on in the upcoming book, Beyond Cracking the Coding Interview, is that binary search has many interesting applications besides finding an element in a sorted array. I'll share an example based on a personal story that's a bit too niche for the book, but kind of fun.\n\nA friend sings in a choir of 40-50 people, and they told me that, in the last rehearsal, the conductor could hear one person singing the wrong part but couldn't identify who. The conductor tried to isolate where the wrong part was coming from by basically binary searching the choir members, but there was an issue: when the conductor narrowed down the source to a small enough group, the issue disappeared. Whoever was singing the wrong part was only getting tripped up by hearing other people singing around them, but would sing their part perfectly in isolation. Eventually, the conductor gave up.\n\nWhat should the conductor have done? More precisely, what algorithm should they have used to find the culprit? First, let's formalize the problem.\n\nThe problem\n\nYou are given n, the number of singers, and a number k < n/2. You have n singers, say, singer 1 to singer n, and you can make any subset sing a song. This gives you 1 bit of information: whether they all sang it correctly or whether someone in that group messed up. All the singers always sing the right part except one, who sings the wrong part, but only if at least k people are singing with them. How do you find who it is?\n\nThe solution\n\nThe key is to do a kind of \"negative binary search,\" where you make everyone sing except the subset you want to test. You know the culprit is in a subset when everyone else sings correctly.\n\nExample: imagine n is 100 and k is 30.\n\nIteration 1:\n\nThe culprit is in range 1-100.\n\nYou split the range into 1-50 and 51-100.\n\nYou want to check if the culprit is in 1-50, so you make everyone else (51-100) sing.\n\nImagine they sing correctly. That means the culprit is in 1-50.\n\nIteration 2:\n\nThe culprit is in range 1-50.\n\nYou split the range into 1-25 and 26-50.\n\nYou want to check if the culprit is in 1-25, so you make everyone else (26-100) sing.\n\nImagine they sing incorrectly. That means the culprit is in 26-50.\n\nIteration 3:\n\nThe culprit is in range 26-50.\n\nYou split the range into 26-38 and 39-50.\n\nYou want to check if the culprit is in 26-38, so you make everyone else (1-25 and 39-100) sing.\n\nImagine they sing correctly. That means the culprit is in 26-38.\n\nIteration 4:\n\nThe culprit is in range 26-38.\n\nYou split the range into 26-31 and 32-38.\n\nYou want to check if the culprit is in 26-31, so you make everyone else (1-25 and 32-100) sing.\n\nImagine they sing incorrectly. That means the culprit is in 32-38.\n\nAnd so on. In this way, the conductor could have found the culprit in O(log n) steps.\n\nCredit to Timothy Johnson for the \"negative binary search\" idea, which I had never heard before.\n\nPS. Let me know if you had seen this technique used before. Also, if you happen to be a choir conductor, I'd love to hear if (a) the problem is relatable, and (b) the algorithm may be useful to you.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/negative-binary-search",
      "author": "",
      "user_id": ""
    },
    {
      "title": "In Defense of Coding Interviews",
      "content": "In Defense of Coding Interviews\n\nThere is already a lot of discourse about everything wrong with coding interviews. Indeed, one of the first chapters in Beyond Cracking the Coding Interview is What's Broken About Coding Interviews? (it's one of the sneak peek free chapters in bctci.co/free-chapters).\n\nHere, I want to collect all the arguments for the contrary view: that there are no clear better alternatives to coding interviews at Big Tech companies.\n\nDisclaimers:\n\nI am one of the authors of Beyond Cracking the Coding Interview, a prep book for coding interviews. Thus, I am vested in coding interviews not going away.\n\nI love leetcoding and specialized in DS&A for my PhD, so I haven't personally experienced the dread that most people feel grinding it.\n\nI've been an interviewer at Google in the past, but I'm not currently working for Big Tech, and I don't have any inside knowledge. This is just my assessment.\n\nThis post is only about Big Tech. I don't think coding interviews are a good idea for startups.\n\nThis post contains \"Strong Opinions, Weakly Held\". I believe everything here, but I'm very receptive to pushback and opposing data.\n\nThe rationale for coding interviews\n\nI think Big Tech companies understand that being cracked at DS&A is not really necessary to be a good SWE. I don't think coding interviews are about that at all.\n\nImagine you are a Big Tech company, like Google. You receive a massive stream of applications, and you have to trim that down to a still large number of hires. Your hiring system needs to be scalable:\n\nyou need to quickly train many interviewers\n\nyou need a way to evaluate candidates that minimizes interviewer bias (not your bias, or a specific person's bias, but all the biases of a large, heterogeneous group)\n\nSo, the first thing you do to scale--in true engineering fashion--is decoupling hiring and team matching. But that means you cannot hire for specific tech or domain experience: You don't know in what team candidates will end up, and your teams use a bunch of different languages and tech stacks (and a lot of it is internal anyway, so you definitely can't hire for that).\n\nSo, you need a competence assessment that is independent of any particulars about the job, much like the role the SAT plays for college admissions. How do you do that?\n\nIf you are a Big Tech company, what you actually want is candidates who can take any complex software system (that's not part of the candidate's previous expertise) and answer hard questions about it, like what's the best way to add a feature, how to optimize it, or how it should be refactored. In other words, the competence you want to assess is general problem-solving skills, and that's what coding interviews are designed for: you are given a tough problem that you have ideally never seen before (more on this later), and asked to showcase your thought process on how you approach it. When working as intended, I believe it gives more signal about your problem-solving skills and is easier to evaluate impartially than other popular interview formats, like talking about previous experience or take-home assignments. And there's an impartial way to evaluate them, by looking at the optimality of the solution.\n\nYes, there's a lot more to being a SWE than problem-solving skills--and that's why Google also does system design and behavioral interviews, but you still want to hire for this trait.\n\nThe two crucial flaws: memorization and cheating\n\nHopefully, the rationale above covered one of the most common criticisms of coding interviews: that they do not reflect the day-to-day work of an engineer. Instead, I want to focus on what I think are the two biggest issues with coding interviews:\n\nMemorizing an absurd amount of leetcode problems gives you an edge. This is the classic reason why people hate coding interviews with a passion. It has led to an \"arms race\" where candidates have to memorize more and more problems to improve their odds, and interviewers keep asking about more niche topics. At the extreme, coding interviews end up feeling like a lottery, and candidates find prep a soul-sucking waste of time.\n\nMemorizing an absurd amount of leetcode problems gives you an edge. This is the classic reason why people hate coding interviews with a passion. It has led to an \"arms race\" where candidates have to memorize more and more problems to improve their odds, and interviewers keep asking about more niche topics. At the extreme, coding interviews end up feeling like a lottery, and candidates find prep a soul-sucking waste of time.\n\nCheating has become easy with AI. This is a newer issue that's becoming more prevalent due to the fact that LLMs are pretty good at leetcoding. In real time, a cheater can feed the problem statement to an LLM (without obvious tales like \"select all\"), get a solution, and even a script for what to say.\n\nCheating has become easy with AI. This is a newer issue that's becoming more prevalent due to the fact that LLMs are pretty good at leetcoding. In real time, a cheater can feed the problem statement to an LLM (without obvious tales like \"select all\"), get a solution, and even a script for what to say.\n\nFrom the company's side, Issue (1) is not much of an issue. It definitely undermines the \"problem-solving\" part of the interview if a candidate is just recalling the question, but, statistically, if they do enough rounds, it's unlikely to happen every round. Some people (not me) also argue that the memorization is even good for the companies because it rewards hard work and dedication.\n\nFor what it's worth, one thing we hoped to change about the interview prep discourse with BCtCI is that candidates should focus on improving their problem-solving skills rather than memorizing. See, for instance, how we teach binary search or how we approach hard problems. But yes, grinding is still necessary.\n\nIssue (1) also means that they'll lose a big chunk of candidates who are great SWEs but won't put up with grinding leetcode or that simply don't perform well under pressure (and, from personal experience, many great developers fall in this group). This sucks from the candidate's perspective, but if you are Google, you receive an overwhelming amount of applications from qualified candidates, so you are more OK with rejecting good candidates than accepting bad ones.\n\nIssue (2), on the other hand, has the potential to completely ruin coding interviews from the company's side. I'm seeing a quick rise of stories from frustrated interviewers who interviewed or even hired cheaters who could then not do the job (Exhibit A).\n\nI expect to see some kind of systematic response to this from Big Tech, but it's not clear what as of April 2025. This article includes some internal comments from Google execs:\n\n[Brian] Ong [Google’s vice president of recruiting] said candidates and Google employees have said they prefer virtual job interviews because scheduling a video call is easier than finding a time to meet in available conference rooms. The virtual interview process is about two weeks faster, he added. He said interviewers are instructed to probe candidates on their answers as a way to decipher whether they actually know what they’re talking about. “We definitely have more work to do to integrate how AI is now more prevalent in the interview process,” said Ong. He said his recruiting organization is working with Google’s software engineer steering committee to figure out how the company can refine its interviewing process. “Given we all work hybrid, I think it’s worth thinking about some fraction of the interviews being in person,” Pichai responded. “I think it’ll help both the candidates understand Google’s culture and I think it’s good for both sides.”\n\n[Brian] Ong [Google’s vice president of recruiting] said candidates and Google employees have said they prefer virtual job interviews because scheduling a video call is easier than finding a time to meet in available conference rooms. The virtual interview process is about two weeks faster, he added.\n\nHe said interviewers are instructed to probe candidates on their answers as a way to decipher whether they actually know what they’re talking about.\n\n“We definitely have more work to do to integrate how AI is now more prevalent in the interview process,” said Ong. He said his recruiting organization is working with Google’s software engineer steering committee to figure out how the company can refine its interviewing process.\n\n“Given we all work hybrid, I think it’s worth thinking about some fraction of the interviews being in person,” Pichai responded. “I think it’ll help both the candidates understand Google’s culture and I think it’s good for both sides.”\n\nI thought going back to in-person interviews would be a no-brainer for a company like Google, but my reading of these comments is that they don't seem too bothered for now. ~shrug~\n\nDisclaimer: I haven't worked for a Big Tech company since before AI cheating went viral, so I don't have internal insight into what people in charge of hiring are actually thinking.\n\nTwo related arguments that I don't subscribe to are (1) that leetcode-style interviews are no longer relevant because AI can solve them, and (2) that LLMs should be allowed during coding interviews because they are allowed on the job. The fact that AI can solve coding questions doesn't change that it still gives you the important signal that you want from humans: algorithmic thinking and general problem-solving skills. We just need humans to not cheat.\n\nI'll share my thoughts on how to improve coding interviews to address these issues. First, let's see why I think the alternatives are not better.\n\nThe problems with the alternatives\n\nTake-home assignments\n\nTake-home assignments are even more subject to cheating, so that can't be the answer to cheating. Never mind LLMs, you don't even know who did the assignment. But take-home assignments have other flaws:\n\nThey create an asymmetry between company and candidate, where the company asks for a ton of work from the candidate without putting any effort in. \"Oh, we have way too many candidates we need to filter down to a shortlist? Send all of them a complex task to do over the weekend.\" I prefer a model where both company and candidate have to put in time. I'm more OK with take-home assignments as the final stage of the process.\n\nThey favor people who are unemployed and/or have a lot of free time to polish the assignment.\n\nPrevious experience\n\nI find this too subjective to give signal about problem-solving skills, and it's more about being a good \"salesperson\". I also think it's more subject to bias: people with a similar background as yours are probably more likely to have similar interests, and thus you may find their side-projects more interesting.\n\nTrial periods\n\nThis makes sense to me in smaller companies, where you find a candidate with the perfect profile for the task at hand. It doesn't scale to Big Tech companies.\n\nOther alternatives\n\nIf there are other alternatives that fulfill the same purpose as coding interviews but don't suffer from the same issues, I'd love to hear about them.\n\nOne idea I liked is going through a code review during the interview, but it's not clear that (1) it offers as much signal about problem-solving skills, and (2) it is easy to evaluate impartially.\n\nHow to improve coding interviews\n\nRight now, FAANG interviewers focus too much on \"Did they solve the question or not?\" That's because they don't get much training on how to interview well (if at all), and it's the most straightforward way to pass on a hire/no hire recommendation to the hiring committee. This leads to many interviewers just pasting the prompt in and mostly sitting in silence. This is the ideal scenario for cheaters.\n\nThe obvious things\n\nThere are obvious ways to improve this situation:\n\nIn-person interviews. These have other benefits, like allowing the candidate to get a better sense of the company culture.\n\nNot using publicly available questions, and actively scanning for leaks.\n\nCheating detection software (privacy is a concern here -- would it be too crazy for a company to ship a laptop to the candidate just for the interview?).\n\nStop asking questions that require knowing some niche trick that a normal person wouldn't be able to figure out on the spot. Those reinforce a focus on memorization.\n\nLow effort ways of countering cheating\n\nI also think that measures designed to throw LLMs off could be effective (at least in the short term) and require minimal effort, such as:\n\nStating the question, or part of it, instead of writing the whole thing down\n\nIncluding a 'decoy' question and telling the candidate, \"Ignore that line, it is part of our anti-cheating measures.\"\n\nSee LinkedIn discussion.\n\nA fundamental tradeoff\n\nPerhaps the most effective way to counter both memorization and cheating is to make coding interviews more open ended and conversational. To use a chess analogy, a cheater may make a great move, but if you ask them to explain why they did it, they may not be able to.\n\nThe interviewer can use a coding question as a launching point, but then drill down on technical topics as they come up. So, e.g., if a candidate chooses to use a heap, the interviewer could go into:\n\nWhat made you think of using a heap? What properties are important for this problem?\n\nWhat are the tradeoffs of using a heap vs binary search trees?\n\nHow would you go about implementing a heap that supports arbitrary priorities?\n\nWhy is heapify faster than inserting one by one?\n\nIf interviewers did that, it wouldn't even be necessary to ask tricky questions. They could even ask Fibonacci.\n\nThe problem is that, the more open ended the interview is, the more difficult it is to evaluate candidates systematically. To start, you'd need better interviewers and better interviewer training. However, it seems to me that there is a fundamental tradeoff between how objective the evaluation is and how gameable the interview is by memorizing or cheating.\n\nI don't have a good solution to this--I would love to hear yours.\n\nMore good things about coding interviews\n\nOnly one thing to study\n\nAn underrated upside of leetcode interviews is that you only need to study one thing for all the big companies. I feel like if every company asked different things, interview prep time would decrease for any specific company but increase overall.\n\nIn fact, a likely outcome of the push for fewer leetcode-style interviews is an even worse compromise: coding interviews won't completely go away, so you'll still need to grind leetcode, but you'll also have to prep a bunch of specialized stuff for each company on top of that.\n\nSee LinkedIn discussion.\n\nThey are not based on pedigree\n\nCoding interviews act as a form of standardized testing, similar to the role of SAT for college admissions in the US. And, much like the SAT allows high-school students from all backgrounds to attend top colleges, coding interviews allow candidates from all backgrounds to get at the top companies. The leetcode grind is the same for everyone.\n\nIf we kill coding interviews without a good alternative, it seems inevitable that Big Tech companies will give more weight to resume and referrals. We all agree that's a bad thing.\n\nFinal thoughts\n\nThe best question we got in our Reddit AMA for BCtCI was whether we'd use coding interviews ourselves if we were in charge of hiring. You can see Gayle's, Mike's (mikemroczka.com), and my answers. We all said no in its current form, but yes with caveats/improvements.\n\nMy favorite answer was Mike's. He's less of a proponent of leetcode-style interviews than I am, but I think he strikes a thoughtful balance between DS&A and practical stuff:\n\nBest question so far. Yes, I would ask DS&A questions still, but not exclusively and not difficult ones. Many startups shouldn't ask them though, because most people are bad at discerning what a reasonable question is. I would do 4-5 rounds of interviews because less than that is hard to be significant, but more than that and you're wasting too much of a candidate's time (Netflix has a whopping 8 rounds!!). For a senior engineer role, I'd do something like this. Round 1: An online DS&A assessment to filter out people that can't do the simple things (easy & very simple medium questions only, not hard) Round 2: Live interview of DS&A (simple medium, not hard. essentially just making sure you didn't cheat on the previous round by asking you to explain your answers and code something new from scratch) Round 3: System design (no need for perfect answers, but I'd ask an uncommon question to ensure it was something they hadn't memorized) Round 4: Behavioral, with a focus on cross-team impact. This would just be a simple pass/fail and just a vibe check. It might also be skipped if the prior two rounds had good signal for emotional intelligence Round 5: Remote logging into a server and working on an actual bug that was fixed in our codebase before. There would be no time limit, but time on the server would be logged to weed people out who needed days to complete a simple task. This ends up testing a little bit of theory, practical knowledge, emotional intelligence, and the generalized SWE skillset. Full disclosure. This is my answer. Not the answer of every author. Again, I'd stress that the average startup wouldn't benefit from DS&A and shouldn't be asking them\n\nBest question so far. Yes, I would ask DS&A questions still, but not exclusively and not difficult ones. Many startups shouldn't ask them though, because most people are bad at discerning what a reasonable question is.\n\nI would do 4-5 rounds of interviews because less than that is hard to be significant, but more than that and you're wasting too much of a candidate's time (Netflix has a whopping 8 rounds!!). For a senior engineer role, I'd do something like this.\n\nRound 1: An online DS&A assessment to filter out people that can't do the simple things (easy & very simple medium questions only, not hard)\n\nRound 2: Live interview of DS&A (simple medium, not hard. essentially just making sure you didn't cheat on the previous round by asking you to explain your answers and code something new from scratch)\n\nRound 3: System design (no need for perfect answers, but I'd ask an uncommon question to ensure it was something they hadn't memorized)\n\nRound 4: Behavioral, with a focus on cross-team impact. This would just be a simple pass/fail and just a vibe check. It might also be skipped if the prior two rounds had good signal for emotional intelligence\n\nRound 5: Remote logging into a server and working on an actual bug that was fixed in our codebase before. There would be no time limit, but time on the server would be logged to weed people out who needed days to complete a simple task.\n\nThis ends up testing a little bit of theory, practical knowledge, emotional intelligence, and the generalized SWE skillset.\n\nFull disclosure. This is my answer. Not the answer of every author. Again, I'd stress that the average startup wouldn't benefit from DS&A and shouldn't be asking them\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/in-defense-of-coding-interviews",
      "author": "",
      "user_id": ""
    },
    {
      "title": "My family during the Spanish Civil War",
      "content": "My family during the Spanish Civil War\n\nAll four of my grandparents were in Catalonia during the 1936-1939 Spanish Civil War. Coming from families from both sides, each had a different journey through it. Bits of \"family lore\" about the war times have trickled down to me through the years, but I decided it's worth trying to put together and contrast their stories.\n\nEventually, I'd like to expand this to my four grandparents, but for now, I'll focus on one of my grandad's story, which I'll call J.M.\n\nDisclaimer: Since J.M. already passed away, this account is based on how he chose to talk about it (and what to include), and on the imperfect memory of his children. As such, it may not be historically accurate.\n\nBorn in 1920 and raised in Barcelona, J.M. was 16 when the military coup d'état that started the war happened. Barcelona was one of the 'strongholds' of the republican side, but he actually came from a family that supported the military takeover led by the soon-to-be fascist dictator, Franco.\n\nThe younger of two brothers, he was not the 'family heir', so he was treated accordingly. When the mandatory draft happened, his dad hid himself and the older son above a fake ceiling, but J.M. was not spared in the same way.\n\nAnd thus, in 1938, at 18, he became a member of what was known as the \"Baby bottle levy\", a levy of boys aged 14-18 drafted to fight for the republican side when things got dire.\n\nHis first and last major operation was the Battle of the Ebro, not far from home for J.M., about 100 miles south of Barcelona. It was one of the final major counterattacks by the republican side. It was also one of the bloodiest.\n\nFor historical context, this battle started just months before Germany, the UK, France, and Italy signed the Munich agreement, which pretty much sealed the spanish republic's fate. At the time, the Republican side was losing ground rapidly, but tension in Europe was getting to a boiling point, and the republican side was hoping that an Europe-wide conflict would erupt and Spain would get sucked into it, at which point they would have support from other european powers (especially their neighbor, France). So, all they needed was to last long enough. It was a wager that turned out to be correct, but it came too late. France and the UK's attempt to appease Nazi Germany with the Munich agreement crushed that hope, and the spanish war was officially over a few months before WW2 began.\n\nAnyway, so my grandad makes it to the battle of the Ebro, and the army discovers in him a valuable talent that spares him the frontline. At the time, the republican side had just received a large batch of Czechoslovakian rifles, but--largely due to the language barrier--they had trouble operating them. J.M. had a talent for technical drawing, and made drawings showing the steps to assemble and disassemble the rifles.\n\nWhen I asked about this story, my aunt named Czechoslovakia specifically as the source of the rifles, which checks out with Wikipedia.\n\nFor the next part of the story, there are two pretty different accounts. What we know for sure is that the republican side was under heavy bombing, and J.M.'s company (not sure what's the technical term) was hiding in a bunker, and the bunker was hit directly and critically, killing everyone or almost everyone inside.\n\nIn one account, J.M. and a friend of his were the only ones outside the bunker, because it was claustrophobically crowded. Each of them was sitting under a different tree. When the bunker got bombed, his friend died too, either by the same or a different bomb, making him the only survivor. In the other account, he was also inside the bunker, but behind a blind corner that was spared the blast.\n\nThe next thing we know about J.M. is that he deserted during the battle of the Ebro, and he started making his way toward the French border, about 200 miles north. Initially, his only clothes were his military uniform, an obvious tell of a deserter, which makes it extremely dangerous to be wandering around alone. As the story goes, he got hold of a herd of sheep, and walked north with it. He used the herd as a cover: he said he was walking alone because he was in charge of bringing the sheep to feed the big mass of refugees also headed north. Eventually, farmers along the way helped feed him and gave him new clothes.\n\nApparently, he was stopped at least once by military, possibly multiple times and from both sides, and asked \"what side do you belong to?\" to which he answered something along the lines of, \"I don't belong to any side, shoot me if you want\" and continued on his way.\n\nEventually, he made it to the Argelers refugee camp in southern France. A camp which, like the other French camps for spanish refugees, would later be relabeled as concentration camps due to the dire conditions. The cold and famine was bad enough that when the war ended, one night, J.M. escaped and headed back to Spain.\n\nApparently, he didn't receive any punishment for fighting for the republican side. He simply had to spend the next three years doing mandatory military service, this time for the nationalist side--the opposite side he fought for.\n\nAll in all, in his words, he \"wasted seven years on the whole ordeal.\" He never claimed to support either side, and always showed skepticism toward any kind of political and religious movements and ideologies.\n\nWhen he was finally able to move past all that, he pursued his passion for art. He worked in graphic design and used that money to pay for an arts degree in college, where he met my grandmother, with whom he shared a love for painting.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/spanish-civil-war",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Lazy vs Eager Algorithms",
      "content": "Lazy vs Eager Algorithms\n\nWarning: I have not tested any code snippet below. Please let me know if you find a bug.\n\nIntroduction\n\nMost algorithms have multiple valid implementations. For instance, in a binay tree problem, you have multiple ways of handling NULL nodes. I'm currently writing Beyond Cracking the Coding Interview (beyondctci.com), which means that my co-authors and I need to take a stance on what version of each algorithm to use. Ideally, we want to show the simplest version of each algorithm:\n\nEasy to recall for interview,\n\nEasy to explain to interviewers,\n\nEasy to debug by hand,\n\nShort, so that it is quick to code.\n\nIn the book, we don't claim that the version we show is \"the best\" - we say to use the one that works best for you. But showing one in the book is an implicit endorsement.\n\nOne particular decision that comes up again and again with recursive algorithms is choosing between the lazy version and the eager version of an algorithm.\n\nAn eager recursive function expects 'valid' inputs and ensures to only call the recursive function with 'valid' inputs. We can also call it a clean (call) stack algorithm.\n\nA lazy recursive algorithm allows 'invalid' inputs, so it starts by validating the input. Then, it calls the recursive function without validating the inputs passed to it. We can also call it a dirty stack algorithm.\n\nWhat 'valid' means depends on the algorithm--we'll see plenty of examples. We'll also translate the concept of eager vs lazy to iterative algorithms.\n\nLazy vs Eager Tree Traversals\n\nAn eager tree traversal eagerly validates that the children are not NULL before passing them to the recursive function. A lazy tree traversal doesn't, so it needs to check if the current node is NULL before accessing it.\n\nFor instance, here is eager vs lazy preorder traversal:\n\nBoth have the same runtime and space analysis. Even the constant factors probably don't change much, so it comes down to style preference. Which one do you prefer?\n\nLazy vs Eager graph DFS\n\nAn eager graph DFS eagerly checks that the neighbors are not already visited before passing them to the recursive function. A lazy graph DFS doesn't, so it needs to check if the current node is already visited.\n\nFor a graph DFS, we can also do a mix between lazy and eager: we can eagerly check if nodes are already visited, and lazily mark them as visited:\n\nAgain, they all have the same analysis. Which one do you prefer?\n\nLazy vs Eager grid algorithms\n\nConsider the same DFS algorithm but on a grid of 0's and 1's. The 0's are walkable cells, the 1's are obstacles, and walkable cells next to each other are connected. This time, we need to check that the neighbors are not out of bounds, which we can do lazily or greedily.\n\nLazy vs Eager Memoization DP\n\nIn a lazy memoization DP (Dynamic Programming) algorithm, we call the recursive function for a subproblem without checking first if we have already computed that subproblem. In an eager algorithm, we only call the recursive function for subproblems that we still need to compute.\n\nFor memoization DP, I think lazy is cleaner and more conventional.\n\nLazy vs Eager Iterative Tree traversals\n\nConsider a level-order traversal on a binary tree. A level-order traversal is an iterative algorithm that uses a queue data structure.\n\nA lazy version puts children in the queue without checking if they are NULL first. We can call it a dirty queue algorithm.\n\nAn eager version checks for NULL nodes and avoids putting them in the queue. We can call it a clean queue algorithm.\n\nEager Graph BFS is better than lazy Graph BFS\n\nThis is the first exception where one is better than the other in terms of big O analysis. The lazy BFS allows adding already-visited nodes to the queue, while the eager one does not. We'll first look at the two versions, and then analyze them.\n\nIt may come as a surprise that these two are not equivalent like all the other examples.\n\nLet's say V is the number of nodes and E is the number of edges. To keep things simple, consider that the graph is connected, meaning that E is at least V-1 and at most O(V²).\n\nBoth versions take O(E) time. The difference is in the space complexity: the eager version takes O(V) space because we never have the same node twice in the queue. The lazy version takes O(E) space because we allow the same nodes multiple times in the queue.\n\nTo see this, consider a complete graph:\n\nWhen we visit start, we add A, B, C, D, E to the queue. Now the queue is: [A, B, C, D, E]\n\nWhen we visit A, we add start, B, C, D, E to the queue. Now the queue is: [B, C, D, E, start, B, C, D, E]\n\nWhen we visit B, we add start, A, C, D, E to the queue. Now the queue is: [C, D, E, start, B, C, D, E, start, A, C, D, E]\n\nBy the time we finish popping the nodes added as neighbors of the start node, we've done V queue pops and V² queue appends, so the queue size is O(V²).\n\nSo, why didn't this happen for other lazy algorithms we have seen?\n\nFor tree traversals, each tree node has a single parent that it can be reached from, so we don't need to worry about the same node appearing twice in the call stack or in the level-order traversal queue.\n\nFor graph DFS, every node in the call stack is marked visited, so if we call visit() on a node that is already in the call stack, we'll immediately return as we'll see it is marked as visited.\n\nEager Dijkstra is better than Lazy Dijkstra, but harder to implement\n\nI wrote extensively about different Dijktsra implementations in this Dijkstra blog post.\n\nDijkstra is similar to BFS, with the main difference that it uses a priority queue (PQ) instead of a queue to visit the nodes that are closer first (in terms of shortest paths).\n\nIn BFS, when a node is added to the queue, its distance from the starting node is already established and there is never a reason to add it again to the queue. In Dijkstra, when a node is added to the PQ, we might later find a shorter path while it is still in the PQ. When that happens, we can do two things:\n\nLazy Dijkstra: just add the node again with the new, improved distance. It will get popped before the previous occurrence because it has higher priority in the PQ. When a node with a \"stale\" distance gets popped off from the queue, we just ignore it.\n\nEager Dijkstra (called textbook Dijkstra in the other blog post): instead of adding the node again, find the existing occurrence of it in the PQ, and update it with the new found distance. This guarantees that the same node never appears twice in the PQ.\n\nBoth versions take O(E*log V) time, but eager is more space efficient, analogously to eager BFS: O(V) for eager Dijkstra vs O(E) for lazy Dijkstra.\n\nHere is lazy Dijkstra:\n\nUnfortunately, eager Dijkstra is not so easy to implement in Python because we are missing the decrease_key() operation in a heap (and Python does have a self-balancing BST data structure, which can also be used for eager Dijkstra). You can see a BST-based C++ implementation in my other blog post.\n\nThe dijkstra_lazy() algorithm above is more or less standard and it has been known as \"lazy Dijkstra\" for a while. However, it is possible to make an even lazier version which has the same runtime and space analysis (but likely bigger constant factors). The idea is that instead of only adding to the PQ the neighbors for whom we find an improved distance, we can simply add all of them, and discard duplicates once we extract them from the PQ:\n\nSo, Lazy or Eager?\n\nWe could keep looking at lazy vs eager algorithms, but I'll stop here. In aggregate, these are the pros and cons that I see:\n\nPros of lazy algorithms\n\nLazy algorithms require less code. This is because you only need to validate the parameters of the recursive function once at the beginning, instead of validating what you pass to each recursive call. This is specially true in binary tree problems, where you usually have two recursive calls. It doesn't apply as much for graphs.\n\nLazy algorithms require less indentation. For instance, in graph problems, we don't need to do checks inside the for loop over the neighbors.\n\nLazy algorithms do not require special handling for the first recursive call. You don't need to worry about things like checking if the root is NULL or marking the start node as visited.\n\nLazy recursive functions have simpler preconditions. You can just pass anything to them, and they work.\n\nPros of eager algorithms\n\nFor a graph BFS, eager has a better space complexity. This is a case where eager is objectively better. (Eager Dijkstra is also better but it is not expected to be implemented in interviews. Your interviewer is probably expecting lazy Dijkstra.)\n\nEager algorithms do fewer recursive calls or iterations. In a binary tree, the number of NULL nodes is always one more than the number of internal nodes. This means that a lazy traversal does twice as many recursive calls/iterations as the eager counterpart. This could make a big difference if you want to debug the code manually. For instance, in this picture, you can see that adding NULLs to the queue makes visualizing the steps more painful:\n\nEager algorithm can 'feel safer'. A friend commented that, with a lazy algorithm, they feel like they are missing an edge case.\n\nMy preference\n\nHere are my personal preferences for coding interviews (not those of the other authors of 'Beyond Cracking the Coding Interview'):\n\nStrong preferences:\n\nFor BFS, use eager. This one is clear cut.\n\nFor memoization DP, use lazy. It is much cleaner to code.\n\nFor Dijkstra, use lazy Dijkstra (not super lazy Dijkstra). It is what is realistic to do in an interview and probably what the interviewer expects.\n\nWeak preferences:\n\nFor binary tree traversals (iterative or recursive), use lazy. It is a bit cleaner.\n\nFor graph DFS, use eager. It is a bit more standard, and aligned with a graph BFS.\n\nIn the book, we'll definitely mention that some algorithms can be implemented in a lazy or eager way (in way less detail than here), and that you should choose the one that feels easier to you. But, we still need to pick one to show in the problem solutions. One idea is trying to be consistent throughout (e.g., doing all tree and graph traversals in an eager way). If you have an opinion on which one is better, please reach out! I'd love to hear it.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/lazy-vs-eager",
      "author": "",
      "user_id": ""
    },
    {
      "title": "The Wall Game Project",
      "content": "The Wall Game Project\n\nWelcome to the Wall Game project! The Wall Game is a multiplayer board game I invented, and which I'm building in public in 2025.\n\nIn this post, I'll go over how to play, my approach to building in public, and the backstory of the game. Once finished, it will be available at wallgame.io.\n\n\"Why are you building this?\"\n\nFirst of all, because I think it's a great game. I've shown it to many people over the years, and the reaction is always that (1) it's fun; and (2) it's super easy to pick up (it passes the subway-legibility test).\n\nOn a more personal note, my goal for 2025 is to get better at building things, and I believe that working on things you find fun is key for consistency.\n\nRules of the game\n\nThe Wall Game is simple to understand.\n\nInitial setup: In the \"standard\" 2-player version of the Wall Game, the board setup looks like this:\n\nGoal: The red player controls the red cat and mouse, and the blue player controls the blue cat and mouse. The red player wins by having their cat catch the blue mouse before the blue cat catches the red mouse.\n\nHow to move: the game is turn-based. On each turn, you can make 2 actions. Each action can be either moving your cat, moving your mouse, or placing a wall. Cats and mice move to adjacent cells, but walls can be placed anywhere between two cells on the board. The only restriction is that you cannot completely block the opponent's cat from reaching your mouse.\n\nThat's it! That's all the rules. It's simple enough that you can play it with just pen and paper.\n\nTo preempt the two most common questions:\n\nMoving diagonally counts as 2 actions.\n\nYou cannot move through your own walls.\n\nExample game\n\nHere is an example of a full game that was played on wallwars.net (the first version of the site, which I'm currently rebuilding).\n\nBuilding in public\n\nI love the concept of building in public, sharing my learnings, and getting feedback. If nothing else, writing down my thought process helps future-me reference what I learned.\n\nSo, as I build it, I'm making a series of blog posts about the game. You can find them all at nilmamano.com/blog/category/wallgame.\n\nSo far, I've written about:\n\nChoosing a tech stack\n\nDesigning the UI\n\nDesigning the DB\n\nThe graph algorithms behind invalid move detection (Part 1, Part 2)\n\nNext, I'll write about Deep Wallwars, an alpha-zero-like AI made by a friend, as well as other interesting aspects of the app's implementation, like automatic puzzle generation.\n\nUltimately, this collection of posts should provide a playbook for building any multiplayer online game, not just the Wall Game.\n\nThe game dates back to my high school days, circa 2006, when my friends and I entertained ourselves with pen-and-paper games. Around that time, I played Quoridor once at a friend's house, and that inspired me to make a pen-and-paper game with similar ideas but with my own rules, like having two actions per move and unlimited walls. After some experimentation, we settled on a 10x12 board, with players starting at the top corners and having to move to their opposite corners (there was no \"mouse\" yet).\n\nThe game was a hit among my high-school friends, and I've basically been playing it and showing it to people ever since. For example, the name WallWars, which I used until the recent rebranding to the Wall Game, was coined by a PhD colleague in 2016 (let me know which name you like more).\n\nIn 2012, during college, I implemented a version of the game in Python (it's on GitHub):\n\nHowever, that version was not online, so, in 2020, I reimplemented it as a full-stack app to play with my friends during the Covid-19 lockdowns. It's currently live at wallwars.net. According to the DB, 421 online games have been played as of May 2025 (I'm the most active player by far).\n\nIn 2021, I started building a C++ minimax-based engine for the game, which you can play against on wallwars.net thanks to WebAssembly. Optimizing it was a challenge, as the branching factor is much higher than, e.g., in chess. Eventually, I got it to work well for small boards, but it was still not good enough for the exponential explosion that comes from bigger boards. That's when Thorben came to the rescue with the Deep Wallwars project, an alpha-zero-like engine that scales a lot better to bigger boards. This is not integrated on the site yet, but it's planned for the rebuild.\n\nIn 2023, I built a physical board to play in person:\n\nWe started experimenting with different variants, in part to accommodate 4 players, but also because we realized that exploring variants of the rule increased the game's replayability. As long as the same strategic and tactical patterns are present, variants are really fun, like playing a new level of a video game. This is also when I adopted the \"cat and mouse\" variant as the default.\n\nTwo of the main reasons I want to rebuild the site are to integrate Deep Wallwars and to support variants, as each of these would require a major overhaul.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-intro#building-in-public",
      "author": "",
      "user_id": ""
    },
    {
      "title": "The Wall Game Project",
      "content": "The Wall Game Project\n\nWelcome to the Wall Game project! The Wall Game is a multiplayer board game I invented, and which I'm building in public in 2025.\n\nIn this post, I'll go over how to play, my approach to building in public, and the backstory of the game. Once finished, it will be available at wallgame.io.\n\n\"Why are you building this?\"\n\nFirst of all, because I think it's a great game. I've shown it to many people over the years, and the reaction is always that (1) it's fun; and (2) it's super easy to pick up (it passes the subway-legibility test).\n\nOn a more personal note, my goal for 2025 is to get better at building things, and I believe that working on things you find fun is key for consistency.\n\nRules of the game\n\nThe Wall Game is simple to understand.\n\nInitial setup: In the \"standard\" 2-player version of the Wall Game, the board setup looks like this:\n\nGoal: The red player controls the red cat and mouse, and the blue player controls the blue cat and mouse. The red player wins by having their cat catch the blue mouse before the blue cat catches the red mouse.\n\nHow to move: the game is turn-based. On each turn, you can make 2 actions. Each action can be either moving your cat, moving your mouse, or placing a wall. Cats and mice move to adjacent cells, but walls can be placed anywhere between two cells on the board. The only restriction is that you cannot completely block the opponent's cat from reaching your mouse.\n\nThat's it! That's all the rules. It's simple enough that you can play it with just pen and paper.\n\nTo preempt the two most common questions:\n\nMoving diagonally counts as 2 actions.\n\nYou cannot move through your own walls.\n\nExample game\n\nHere is an example of a full game that was played on wallwars.net (the first version of the site, which I'm currently rebuilding).\n\nBuilding in public\n\nI love the concept of building in public, sharing my learnings, and getting feedback. If nothing else, writing down my thought process helps future-me reference what I learned.\n\nSo, as I build it, I'm making a series of blog posts about the game. You can find them all at nilmamano.com/blog/category/wallgame.\n\nSo far, I've written about:\n\nChoosing a tech stack\n\nDesigning the UI\n\nDesigning the DB\n\nThe graph algorithms behind invalid move detection (Part 1, Part 2)\n\nNext, I'll write about Deep Wallwars, an alpha-zero-like AI made by a friend, as well as other interesting aspects of the app's implementation, like automatic puzzle generation.\n\nUltimately, this collection of posts should provide a playbook for building any multiplayer online game, not just the Wall Game.\n\nThe game dates back to my high school days, circa 2006, when my friends and I entertained ourselves with pen-and-paper games. Around that time, I played Quoridor once at a friend's house, and that inspired me to make a pen-and-paper game with similar ideas but with my own rules, like having two actions per move and unlimited walls. After some experimentation, we settled on a 10x12 board, with players starting at the top corners and having to move to their opposite corners (there was no \"mouse\" yet).\n\nThe game was a hit among my high-school friends, and I've basically been playing it and showing it to people ever since. For example, the name WallWars, which I used until the recent rebranding to the Wall Game, was coined by a PhD colleague in 2016 (let me know which name you like more).\n\nIn 2012, during college, I implemented a version of the game in Python (it's on GitHub):\n\nHowever, that version was not online, so, in 2020, I reimplemented it as a full-stack app to play with my friends during the Covid-19 lockdowns. It's currently live at wallwars.net. According to the DB, 421 online games have been played as of May 2025 (I'm the most active player by far).\n\nIn 2021, I started building a C++ minimax-based engine for the game, which you can play against on wallwars.net thanks to WebAssembly. Optimizing it was a challenge, as the branching factor is much higher than, e.g., in chess. Eventually, I got it to work well for small boards, but it was still not good enough for the exponential explosion that comes from bigger boards. That's when Thorben came to the rescue with the Deep Wallwars project, an alpha-zero-like engine that scales a lot better to bigger boards. This is not integrated on the site yet, but it's planned for the rebuild.\n\nIn 2023, I built a physical board to play in person:\n\nWe started experimenting with different variants, in part to accommodate 4 players, but also because we realized that exploring variants of the rule increased the game's replayability. As long as the same strategic and tactical patterns are present, variants are really fun, like playing a new level of a video game. This is also when I adopted the \"cat and mouse\" variant as the default.\n\nTwo of the main reasons I want to rebuild the site are to integrate Deep Wallwars and to support variants, as each of these would require a major overhaul.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-intro#rules-of-the-game",
      "author": "",
      "user_id": ""
    },
    {
      "title": "The Wall Game Project",
      "content": "The Wall Game Project\n\nWelcome to the Wall Game project! The Wall Game is a multiplayer board game I invented, and which I'm building in public in 2025.\n\nIn this post, I'll go over how to play, my approach to building in public, and the backstory of the game. Once finished, it will be available at wallgame.io.\n\n\"Why are you building this?\"\n\nFirst of all, because I think it's a great game. I've shown it to many people over the years, and the reaction is always that (1) it's fun; and (2) it's super easy to pick up (it passes the subway-legibility test).\n\nOn a more personal note, my goal for 2025 is to get better at building things, and I believe that working on things you find fun is key for consistency.\n\nRules of the game\n\nThe Wall Game is simple to understand.\n\nInitial setup: In the \"standard\" 2-player version of the Wall Game, the board setup looks like this:\n\nGoal: The red player controls the red cat and mouse, and the blue player controls the blue cat and mouse. The red player wins by having their cat catch the blue mouse before the blue cat catches the red mouse.\n\nHow to move: the game is turn-based. On each turn, you can make 2 actions. Each action can be either moving your cat, moving your mouse, or placing a wall. Cats and mice move to adjacent cells, but walls can be placed anywhere between two cells on the board. The only restriction is that you cannot completely block the opponent's cat from reaching your mouse.\n\nThat's it! That's all the rules. It's simple enough that you can play it with just pen and paper.\n\nTo preempt the two most common questions:\n\nMoving diagonally counts as 2 actions.\n\nYou cannot move through your own walls.\n\nExample game\n\nHere is an example of a full game that was played on wallwars.net (the first version of the site, which I'm currently rebuilding).\n\nBuilding in public\n\nI love the concept of building in public, sharing my learnings, and getting feedback. If nothing else, writing down my thought process helps future-me reference what I learned.\n\nSo, as I build it, I'm making a series of blog posts about the game. You can find them all at nilmamano.com/blog/category/wallgame.\n\nSo far, I've written about:\n\nChoosing a tech stack\n\nDesigning the UI\n\nDesigning the DB\n\nThe graph algorithms behind invalid move detection (Part 1, Part 2)\n\nNext, I'll write about Deep Wallwars, an alpha-zero-like AI made by a friend, as well as other interesting aspects of the app's implementation, like automatic puzzle generation.\n\nUltimately, this collection of posts should provide a playbook for building any multiplayer online game, not just the Wall Game.\n\nThe game dates back to my high school days, circa 2006, when my friends and I entertained ourselves with pen-and-paper games. Around that time, I played Quoridor once at a friend's house, and that inspired me to make a pen-and-paper game with similar ideas but with my own rules, like having two actions per move and unlimited walls. After some experimentation, we settled on a 10x12 board, with players starting at the top corners and having to move to their opposite corners (there was no \"mouse\" yet).\n\nThe game was a hit among my high-school friends, and I've basically been playing it and showing it to people ever since. For example, the name WallWars, which I used until the recent rebranding to the Wall Game, was coined by a PhD colleague in 2016 (let me know which name you like more).\n\nIn 2012, during college, I implemented a version of the game in Python (it's on GitHub):\n\nHowever, that version was not online, so, in 2020, I reimplemented it as a full-stack app to play with my friends during the Covid-19 lockdowns. It's currently live at wallwars.net. According to the DB, 421 online games have been played as of May 2025 (I'm the most active player by far).\n\nIn 2021, I started building a C++ minimax-based engine for the game, which you can play against on wallwars.net thanks to WebAssembly. Optimizing it was a challenge, as the branching factor is much higher than, e.g., in chess. Eventually, I got it to work well for small boards, but it was still not good enough for the exponential explosion that comes from bigger boards. That's when Thorben came to the rescue with the Deep Wallwars project, an alpha-zero-like engine that scales a lot better to bigger boards. This is not integrated on the site yet, but it's planned for the rebuild.\n\nIn 2023, I built a physical board to play in person:\n\nWe started experimenting with different variants, in part to accommodate 4 players, but also because we realized that exploring variants of the rule increased the game's replayability. As long as the same strategic and tactical patterns are present, variants are really fun, like playing a new level of a video game. This is also when I adopted the \"cat and mouse\" variant as the default.\n\nTwo of the main reasons I want to rebuild the site are to integrate Deep Wallwars and to support variants, as each of these would require a major overhaul.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-intro#backstory",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Iterative Tree Traversals: A Practical Guide",
      "content": "Iterative Tree Traversals: A Practical Guide\n\nIntroduction\n\nI don't know how often tree traversals come up in actual software projects, but they are popular in coding interviews and competitive programming. In this article, I share an approach for implementing tree traversal algorithms iteratively that I found to be simple to remember and implement, while being flexible enough to do anything that a recursive algorithm can (I also didn't like most suggestions I saw online). The main technique is given in section \"Iterative Postorder and Inorder Traversal\", but first I give some context. I also link to practice problems on leetcode.com for the reader to play with. I provide some solutions, but I suggest trying the problems out first. The code snippets are in C++, but leetcode accepts most languages.\n\nWhat are Tree Traversals\n\nMathematically, trees are just connected acyclic graphs. However, in the context of tree traversals, we are usually working with rooted trees represented with a recursive structure such as the following (which is the default definition in Leetcode for binary trees). A leaf is a node with two null pointers as children:\n\nA tree traversal is an algorithm that visits every node in a tree in a specific order (and does some computation with them, depending on the problem). For binary trees specifically, there are three important orders:\n\nPreorder: root before children. As we will see, this is the simplest to implement.\n\nInorder: left child, then root, then right child. This traversal is most often used on binary search trees (BST). A BST is a rooted binary tree with the additional property that every node in the left subtree has a smaller value than the root, and every node in the right subtree has a larger value than the root. This traversal is called \"inorder\" because, when used on a BST, it will visit the nodes from smallest to largest.\n\nPostorder: children before root. It comes up in problems where we have to aggregate information about the entire subtree rooted at each node. Classic examples are computing the size, the height, or the sum of values of the tree.\n\nBecause rooted trees are recursive data structures, algorithms on trees are most naturally expressed recursively. Here are the three traversals. I use the function process(node) as a placeholder for whatever computation the problem calls for.\n\nSide-note: in C++, pointers are implicitly converted to booleans: a pointer evaluates to true if and only if it is not null. So, in the code above, \"if (!root)\" is equivalent to \"if (root == NULL)\".\n\nTraversal problems on leetcode\n\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/\n\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/\n\nWhy / When to Use an Iterative Traversal\n\nIf the recursive implementation is so simple, why bother with an iterative one? Of course, to avoid stack overflow. Most runtime engines/compilers set a limit on how many nested calls a program can make. For example, according to this article:\n\nDefault stack size varies between 320k and 1024k depending on the version of Java and the system used. For a 64 bits Java 8 program with minimal stack usage, the maximum number of nested method calls is about 7000.\n\nDefault stack size varies between 320k and 1024k depending on the version of Java and the system used. For a 64 bits Java 8 program with minimal stack usage, the maximum number of nested method calls is about 7000.\n\nIf the height of the tree is larger than this limit, the program will crash with a stack overflow error. A recursive implementation is safe to use if:\n\nSomehow we know that the input trees will be small enough.\n\nThe tree is balanced, which means that, for each node, the left and right subtrees have roughly the same height. In a balanced tree, the height is guaranteed to be logarithmic on the number of nodes (indeed, that is why balanced BSTs guarantee O(log n) search time), so any tree that fits in RAM (or even disk) will require a tiny number of recursive calls.\n\nHowever, if we are not in either of the cases above, an iterative solution is safer.\n\nRecursive and iterative traversals have the same runtime complexity, so this is not a concern when choosing either (all the problems shown in this article can be solved in linear time using either).\n\nThe main approach for converting recursive implementations to iterative ones is to \"simulate\" the call stack with an actual stack where we push and pop the nodes explicitly. This works great \"out-of-the-box\" with preorder traversal.\n\nIncidentally, when implementing tree traversals we need to make an implementation choice about how to handle NULL pointers. We can be eager and filter them out before adding them to the stack, or we can be lazy and detect them once we extract them from the stack. Both are fine—what matters is to be deliberate and consistent about which approach we are using. I prefer the latter as it yields slightly shorter code, so I will use it in all the following examples. For comparison, here is the iterative preorder traversal with both approaches:\n\nNote that the right child is pushed to the stack before the left one. This is because we want the left child to be above in the stack so that it is processed first.\n\nPreorder traversal practice problems\n\nhttps://leetcode.com/problems/invert-binary-tree/\n\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/\n\nThis problem asks to find the depth of a binary tree (follow the link for the description and examples). It requires passing information from each node to its children. We can do this by changing the stack to stack<pair<TreeNode*, int>>, so that we can pass an int to each child, as in the solution below:\n\nIn the code above, the {} notation is used to create pairs (e.g., {root, 0}). If one is not familiar with pairs in C++, or is using a language without the equivalent, a simple alternative is to use two separate stacks, one for the nodes and one for the info.\n\nThe next two problems are similar:\n\nhttps://leetcode.com/problems/minimum-depth-of-binary-tree/\n\nhttps://leetcode.com/problems/path-sum/\n\nhttps://leetcode.com/problems/symmetric-tree/\n\nA solution for the last one, this time using a stack with a pair of nodes:\n\nIterative Postorder and Inorder Traversal\n\nWhile iterative preorder traversal is straightforward, with postorder and inorder we run into a complication: we cannot simply swap the order of the lines as with the recursive implementation. In other words, the following does not yield a postorder traversal:\n\nThe node is still processed before its children, which is not what we want.\n\nThe workaround, once again emulating the recursive implementation, is to visit each node twice. We consider postorder traversal first. In the first visit, we only push the children onto the stack. In the second visit, we do the actual processing. The simplest way to do this is to enhance the stack with a \"visit number flag\". Implementation-wise, we change the stack to stack<pair<TreeNode*, int>> so that we can pass the flag along with each node. The iterative postorder looks like this:\n\nNote the order in which the nodes are added to the stack when visit == 0. The parent ends up under its children, with the left child on top. Since it is the first time that the children are added to the stack, their visit-number flag is 0. For the parent, it is 1. For simplicity, I also follow the convention to always immediately call pop after extracting the top element from the stack.\n\nThe same approach also works for inorder traversal (that's the point). Here is a version where we visit each node three times: one to push the left child, one to process the node, and one to push the right child.\n\nIn fact, the second and third visits can be merged together: processing the node does not modify the stack, so the two visits are followed one after the other anyway. Here is my preferred version:\n\nFor completeness, here is the version found in most of my top Google hits (see this for a nice explanation):\n\nWhile it is shorter, it cannot be easily converted to postorder traversal, so it is not as flexible. Also, I find it easier to follow the execution flow with the visit-number flag.\n\nInorder traversal practice problems\n\nhttps://leetcode.com/problems/kth-smallest-element-in-a-bst/\n\nA solution (follow the link for the statement and examples):\n\nhttps://leetcode.com/problems/validate-binary-search-tree/\n\nA solution:\n\nPostorder traversal practice problems\n\nhttps://leetcode.com/problems/balanced-binary-tree/\n\nThis problem asks to check if a binary tree is balanced. It requires passing information back from the children to the parent node in a postorder traversal. Passing information from the children to the parent is easy with recursion. It can be done both with return values or with parameters passed by reference. For this problem we need to pass two things: a bool indicating if the subtree is balanced, and an int indicating its height. I use a reference parameter for the latter (returning a pair<bool,int> would be cleaner).\n\nPassing information from the children to the parent in an iterative implementation is more intricate. There are three general approaches:\n\nUse a hash table mapping each node to the information.\n\nThis is the easiest way, but also the most expensive. While the asymptotic runtime is still linear, hash tables generally have significant constant factors.\n\nAdd a field to the definition of the node structure for the information needed.\n\nThen, we can read it from the parent node by traversing the children's pointers. In Leetcode we cannot modify the TreeNode data structure so, to illustrate this approach, I build a new tree first with a new struct:\n\nPass the information through an additional stack.\n\nThis is the most efficient, but one must be careful to keep both stacks in synch. When processing a node, that node first pops the information from its children, and then pushes its own info for its parent. Here is a solution (with eager NULL-pointer detection):\n\nhttps://leetcode.com/problems/diameter-of-binary-tree/\n\nThis problem also requires passing information from the children to the parent in a postorder traversal. Here is a solution using the third approach again, but this time with lazy NULL-pointer detection. Note that we push a 0 to the depths stack when we extract a NULL pointer from the main stack, and during processing we always do two pops regardless of the number of non-NULL children:\n\nhttps://leetcode.com/problems/binary-tree-tilt/\n\nhttps://leetcode.com/problems/most-frequent-subtree-sum/\n\nhttps://leetcode.com/problems/maximum-product-of-splitted-binary-tree/\n\nTraversals in n-ary Trees\n\nSo far, we have looked at binary trees. In an n-ary tree, each node has an arbitrary number of children.\n\nFor n-ary trees, preorder traversal is also straightforward, and inorder traversal is not defined.\n\nFor postorder traversal, we can use a visit-number flag again. Two visits suffice for each node: one to push all the children into the stack, and another to process the node itself. I do not include the code here because it is very similar to the binary tree case.\n\nConsider a more complicated setting where we need to compute something at the node after visiting each child. Let's call this \"interleaved traversal\". I use process(node, i) as placeholder for the computation done before visiting the i-th child. Here is the recursive implementation and the corresponding iterative one using visit-number flags.\n\nN-ary tree practice problems\n\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/\n\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/\n\nAn Alternative Way of Passing the Visit Flag\n\nThe common framework to all our solutions has been to pass a visit-number flag along with the nodes on the stack. User \"heiswyd\" on leetcode posted here an alternative way to pass the flag implicitly: initially, it pushes each node on the stack twice. Then, it can distinguish between the first visit and the second visit by checking whether the node that has just been extracted from the stack matches the node on top of the stack. This happens only when we extract the first of the two occurrences. Post-order traversal looks like this:\n\nIt is cool, but I prefer passing the flag explicitly for clarity.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/iterativetreetraversal#iterative-postorder-and-inorder-traversal",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Single-Edge Cut Problem",
      "content": "Single-Edge Cut Problem\n\nIn this post, we'll solve a graph problem that comes up in the Wall Game.\n\nSee also the related, but harder, Double-Edge Cut Problem.\n\nThe single-edge cut problem\n\nYou are given an undirected, unweighted, connected graph G with V nodes and E edges, where each node is identified by an integer from 0 to V-1. You are also given a list, bonded_pairs, of k pairs of nodes.\n\nWe say an edge is essential if removing it from G disconnects a bonded pair.\n\nReturn a list of the essential edges.\n\nGiven this graph and the list bonded_pairs = [[0, 1], [1, 5], [5, 7]], the essential edges would be [[0, 1], [2, 4]]:\n\nremoving the edge [0, 1] disconnects the bonded pair [0, 1]\n\nremoving the edge [2, 4] disconnects the bonded pair [1, 5]\n\nthere is no way to disconnect the bonded pair [5, 7]\n\nThis is the key problem behind whether a wall can be added or not in the Wall Game. The board of the Wall Game may look something like the picture on the left:\n\nThe right picture is the board modeled as a graph. The cells become nodes and two adjacent nodes are connected if there is no wall between them.\n\nPlayers can build walls anywhere, which is like removing an edge. The only constraint is that they cannot fully block the opponent's path to their goal (or their own). Thus, each player and its goal form a bonded pair, and the essential edges are the walls that cannot be placed.\n\nIn the picture, the bonded pairs are [u, v] and [w, x], and the essential edges are shown in red.\n\nImagine that we want to implement a feature in the Wall Game website where, when you hover over a wall slot, it is highlighted in red if the move is invalid. To do this, we need to solve the single-edge cut problem. Beyond that, it could also be useful to program an engine, which needs to consider lots of moves.\n\nNote: the graph from the Wall Game may not be connected (see, e.g., the isolated connected component in the top-left corner)--all we are guaranteed is that each bonded pair is in the same connected component. In this blog post, we assume the graph is connected for simplicity, but it is not hard to extend the algorithm to the disconnected case. We just do an initial pass to find all the connected components, and then process each one separately.\n\nWhy do we frame the problem in terms of k pairs, and not just two? There are variants of the Wall Game with more than two players:\n\nIn this 4-player variant, Player 1 needs to catch Player 2 before they themselves are caught by Player 4, Player 2 needs to catch Player 3 before they are caught by Player 1, and so on. We can think of it as having four bonded pairs.\n\nBrute force solution\n\nThe naive solution is to consider each edge individually. For each edge e in E, we:\n\nRemove it from G (we denote the resulting graph as G - {e}).\n\nFind the connected components in G - {e}.\n\nIf two bonded nodes are in different connected components, e is essential.\n\nStep (1) takes O(1) time, Step (2) takes O(E) time (it can be done with a DFS or a BFS), and Step (3) takes O(k) time. The total runtime is O(E * (E+k)).\n\nEfficient solution\n\nIn this section, we'll solve the problem in O(E * k) time. In the next section, we'll see a more complicated but optimal O(E + k) algorithm.\n\nWe'll build up to it with a series of definitions and intermediate steps.\n\nDefinition: In a connected graph, a bridge is an edge which, if removed, disconnects the graph.\n\nIn the example above, the bridges are [0, 1], [2, 4], and [7, 8].\n\nDefinition: Given a pair of nodes in a connected graph, s and t, an st-bridge is an edge which, if removed, disconnects s and t.\n\nIn the context of our problem, an edge is essential if it is an st-bridge for some bonded pair [s, t].\n\nObservation 1: Every st-bridge is a bridge, but not necessarily the other way around.\n\nObservation 2: Given two nodes, s and t, take any path between them, P. Every st-bridge must be in P.\n\nObservation 2 is because if we remove any edge not in P, s and t will still be connected via P.\n\nMain result: Let P be any path between s and t. An edge is an st-bridge if and only if it is both a bridge and in P.\n\nWe can now formulate an algorithm based on this property:\n\nWe can find all the bridges in O(E) time using Tarjan's algorithm. We can find each path using DFS or BFS in O(E) time (interestingly, it doesn't matter how you find the path, as it can be any path). The total runtime is O(E + k * E) = O(E * k).\n\nHere's a TypeScript implementation.\n\nOptimal algorithm\n\nIf k is small, as in the Wall Game, the above algorithm is the most practical. In this section, we'll see a linear-time (O(E + k)) algorithm, which is asymptotically optimal for any k.\n\nThe bottleneck of the previous algorithm is finding the k paths between bonded pairs. To achieve linear time, we need to do this in a single pass.\n\nThe key property we'll use is that, in Observation 2 above, we can choose any path between each bonded pair. We can start by finding a spanning tree T of G, and focus only on the paths connecting the bonded pairs through T. We can find a spanning tree in O(E) time using a DFS or a BFS (it doesn't matter).\n\nIt will be convenient to think of T as a rooted tree, so that we can talk about node depths and lowest common ancestors. We can root it at any node.\n\nThe root is at depth 0, its children are at depth 1, and so on. The lowest common ancestor of a pair of nodes u and v in T, denoted LCA(u, v), is the node in T that is an ancestor of both nodes and has maximum depth.\n\nRecall that we want to identify all the edges in T that form paths between pairs of bonded nodes. Between any pair of nodes u and v, there is a unique path in T: the path that goes from u up to LCA(u, v) and from there down to v (note that LCA(u, v) could be u or v itself).\n\nWe can start by finding the LCA of each bonded pair in T. We can do this in linear time using Tarjan's off-line lowest common ancestors algorithm.\n\nHere is a tree for the example graph from above, rooted at 7:\n\nHenceforth, we say that a node u is bonded if it is bonded to at least one other node.\n\nFor each bonded node u, we define min_lca(u) as follows: among the LCA's of all bonded pairs involving u, min_lca(u) is the one with minimum depth.\n\nFor example, imagine that, in the tree above, node 1 is involved in 3 bonded pairs: [1, 3], [1, 0], and [1, 4]. The corresponding LCA's are 2 (at depth 2), 1 (at depth 3), and 4 (at depth 1). Of those, the one with minimum depth is 4, so min_lca(1) = 4.\n\nThe following observation characterizes the essential edges in terms of T:\n\nObservation 3: A bridge of G is essential if and only if it is between a bonded node u and min_lca(u).\n\nOn the one hand, if we removed a bridge between u and min_lca(u), the bonded pair consisting of u and the node v such that LCA(u, v) = min_lca(u) will become disconnected. On the other hand, if a bridge is not between any bonded node u and min_lca(u), every bonded pair has a path that doesn't go through it, so it is not essential.\n\nThe idea behind our linear-time algorithm is to do a traversal through T. At each node u, we want to find the LCA with minimum depth among all the bonded pairs with one node in subtree(u) (the subtree rooted at u), if any. That is, we want to find the minimum-depth node in T that is the min_lca(v) for some node v in subtree(u). We actually only care about its depth, which we call subtree_min_lca_depth(u). We can compute subtree_min_lca_depth(u) recursively, aggregating the results from each child as well as the depth of min_lca(u) itself if u is bonded:\n\nFinally, we can write a simple check for whether an edge in T is essential:\n\nObservation 4: If [w, u] is an edge in T, where w is the parent of u, [w, u] is essential if and only if (1) [w, u] is a bridge in G and (2) subtree_min_lca_depth(u) < depth(u).\n\nCondition (2) says that there is some node in the subtree rooted at u that is bonded to a node somewhere above u.\n\nHere is the full pseudocode:\n\nAs mentioned, finding bridges takes O(E) time, building a spanning tree takes O(E) time, and finding all k LCA's takes O(V + k) time; the remaining steps, including the main tree traversal, take O(V) time. Considering that the graph is connected, and thus V <= E, the total runtime is O(E + k).\n\nWant to leave a comment? You can post under the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/single-edge-cut-problem#the-single-edge-cut-problem",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Single-Edge Cut Problem",
      "content": "Single-Edge Cut Problem\n\nIn this post, we'll solve a graph problem that comes up in the Wall Game.\n\nSee also the related, but harder, Double-Edge Cut Problem.\n\nThe single-edge cut problem\n\nYou are given an undirected, unweighted, connected graph G with V nodes and E edges, where each node is identified by an integer from 0 to V-1. You are also given a list, bonded_pairs, of k pairs of nodes.\n\nWe say an edge is essential if removing it from G disconnects a bonded pair.\n\nReturn a list of the essential edges.\n\nGiven this graph and the list bonded_pairs = [[0, 1], [1, 5], [5, 7]], the essential edges would be [[0, 1], [2, 4]]:\n\nremoving the edge [0, 1] disconnects the bonded pair [0, 1]\n\nremoving the edge [2, 4] disconnects the bonded pair [1, 5]\n\nthere is no way to disconnect the bonded pair [5, 7]\n\nThis is the key problem behind whether a wall can be added or not in the Wall Game. The board of the Wall Game may look something like the picture on the left:\n\nThe right picture is the board modeled as a graph. The cells become nodes and two adjacent nodes are connected if there is no wall between them.\n\nPlayers can build walls anywhere, which is like removing an edge. The only constraint is that they cannot fully block the opponent's path to their goal (or their own). Thus, each player and its goal form a bonded pair, and the essential edges are the walls that cannot be placed.\n\nIn the picture, the bonded pairs are [u, v] and [w, x], and the essential edges are shown in red.\n\nImagine that we want to implement a feature in the Wall Game website where, when you hover over a wall slot, it is highlighted in red if the move is invalid. To do this, we need to solve the single-edge cut problem. Beyond that, it could also be useful to program an engine, which needs to consider lots of moves.\n\nNote: the graph from the Wall Game may not be connected (see, e.g., the isolated connected component in the top-left corner)--all we are guaranteed is that each bonded pair is in the same connected component. In this blog post, we assume the graph is connected for simplicity, but it is not hard to extend the algorithm to the disconnected case. We just do an initial pass to find all the connected components, and then process each one separately.\n\nWhy do we frame the problem in terms of k pairs, and not just two? There are variants of the Wall Game with more than two players:\n\nIn this 4-player variant, Player 1 needs to catch Player 2 before they themselves are caught by Player 4, Player 2 needs to catch Player 3 before they are caught by Player 1, and so on. We can think of it as having four bonded pairs.\n\nBrute force solution\n\nThe naive solution is to consider each edge individually. For each edge e in E, we:\n\nRemove it from G (we denote the resulting graph as G - {e}).\n\nFind the connected components in G - {e}.\n\nIf two bonded nodes are in different connected components, e is essential.\n\nStep (1) takes O(1) time, Step (2) takes O(E) time (it can be done with a DFS or a BFS), and Step (3) takes O(k) time. The total runtime is O(E * (E+k)).\n\nEfficient solution\n\nIn this section, we'll solve the problem in O(E * k) time. In the next section, we'll see a more complicated but optimal O(E + k) algorithm.\n\nWe'll build up to it with a series of definitions and intermediate steps.\n\nDefinition: In a connected graph, a bridge is an edge which, if removed, disconnects the graph.\n\nIn the example above, the bridges are [0, 1], [2, 4], and [7, 8].\n\nDefinition: Given a pair of nodes in a connected graph, s and t, an st-bridge is an edge which, if removed, disconnects s and t.\n\nIn the context of our problem, an edge is essential if it is an st-bridge for some bonded pair [s, t].\n\nObservation 1: Every st-bridge is a bridge, but not necessarily the other way around.\n\nObservation 2: Given two nodes, s and t, take any path between them, P. Every st-bridge must be in P.\n\nObservation 2 is because if we remove any edge not in P, s and t will still be connected via P.\n\nMain result: Let P be any path between s and t. An edge is an st-bridge if and only if it is both a bridge and in P.\n\nWe can now formulate an algorithm based on this property:\n\nWe can find all the bridges in O(E) time using Tarjan's algorithm. We can find each path using DFS or BFS in O(E) time (interestingly, it doesn't matter how you find the path, as it can be any path). The total runtime is O(E + k * E) = O(E * k).\n\nHere's a TypeScript implementation.\n\nOptimal algorithm\n\nIf k is small, as in the Wall Game, the above algorithm is the most practical. In this section, we'll see a linear-time (O(E + k)) algorithm, which is asymptotically optimal for any k.\n\nThe bottleneck of the previous algorithm is finding the k paths between bonded pairs. To achieve linear time, we need to do this in a single pass.\n\nThe key property we'll use is that, in Observation 2 above, we can choose any path between each bonded pair. We can start by finding a spanning tree T of G, and focus only on the paths connecting the bonded pairs through T. We can find a spanning tree in O(E) time using a DFS or a BFS (it doesn't matter).\n\nIt will be convenient to think of T as a rooted tree, so that we can talk about node depths and lowest common ancestors. We can root it at any node.\n\nThe root is at depth 0, its children are at depth 1, and so on. The lowest common ancestor of a pair of nodes u and v in T, denoted LCA(u, v), is the node in T that is an ancestor of both nodes and has maximum depth.\n\nRecall that we want to identify all the edges in T that form paths between pairs of bonded nodes. Between any pair of nodes u and v, there is a unique path in T: the path that goes from u up to LCA(u, v) and from there down to v (note that LCA(u, v) could be u or v itself).\n\nWe can start by finding the LCA of each bonded pair in T. We can do this in linear time using Tarjan's off-line lowest common ancestors algorithm.\n\nHere is a tree for the example graph from above, rooted at 7:\n\nHenceforth, we say that a node u is bonded if it is bonded to at least one other node.\n\nFor each bonded node u, we define min_lca(u) as follows: among the LCA's of all bonded pairs involving u, min_lca(u) is the one with minimum depth.\n\nFor example, imagine that, in the tree above, node 1 is involved in 3 bonded pairs: [1, 3], [1, 0], and [1, 4]. The corresponding LCA's are 2 (at depth 2), 1 (at depth 3), and 4 (at depth 1). Of those, the one with minimum depth is 4, so min_lca(1) = 4.\n\nThe following observation characterizes the essential edges in terms of T:\n\nObservation 3: A bridge of G is essential if and only if it is between a bonded node u and min_lca(u).\n\nOn the one hand, if we removed a bridge between u and min_lca(u), the bonded pair consisting of u and the node v such that LCA(u, v) = min_lca(u) will become disconnected. On the other hand, if a bridge is not between any bonded node u and min_lca(u), every bonded pair has a path that doesn't go through it, so it is not essential.\n\nThe idea behind our linear-time algorithm is to do a traversal through T. At each node u, we want to find the LCA with minimum depth among all the bonded pairs with one node in subtree(u) (the subtree rooted at u), if any. That is, we want to find the minimum-depth node in T that is the min_lca(v) for some node v in subtree(u). We actually only care about its depth, which we call subtree_min_lca_depth(u). We can compute subtree_min_lca_depth(u) recursively, aggregating the results from each child as well as the depth of min_lca(u) itself if u is bonded:\n\nFinally, we can write a simple check for whether an edge in T is essential:\n\nObservation 4: If [w, u] is an edge in T, where w is the parent of u, [w, u] is essential if and only if (1) [w, u] is a bridge in G and (2) subtree_min_lca_depth(u) < depth(u).\n\nCondition (2) says that there is some node in the subtree rooted at u that is bonded to a node somewhere above u.\n\nHere is the full pseudocode:\n\nAs mentioned, finding bridges takes O(E) time, building a spanning tree takes O(E) time, and finding all k LCA's takes O(V + k) time; the remaining steps, including the main tree traversal, take O(V) time. Considering that the graph is connected, and thus V <= E, the total runtime is O(E + k).\n\nWant to leave a comment? You can post under the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/single-edge-cut-problem#optimal-algorithm",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Single-Edge Cut Problem",
      "content": "Single-Edge Cut Problem\n\nIn this post, we'll solve a graph problem that comes up in the Wall Game.\n\nSee also the related, but harder, Double-Edge Cut Problem.\n\nThe single-edge cut problem\n\nYou are given an undirected, unweighted, connected graph G with V nodes and E edges, where each node is identified by an integer from 0 to V-1. You are also given a list, bonded_pairs, of k pairs of nodes.\n\nWe say an edge is essential if removing it from G disconnects a bonded pair.\n\nReturn a list of the essential edges.\n\nGiven this graph and the list bonded_pairs = [[0, 1], [1, 5], [5, 7]], the essential edges would be [[0, 1], [2, 4]]:\n\nremoving the edge [0, 1] disconnects the bonded pair [0, 1]\n\nremoving the edge [2, 4] disconnects the bonded pair [1, 5]\n\nthere is no way to disconnect the bonded pair [5, 7]\n\nThis is the key problem behind whether a wall can be added or not in the Wall Game. The board of the Wall Game may look something like the picture on the left:\n\nThe right picture is the board modeled as a graph. The cells become nodes and two adjacent nodes are connected if there is no wall between them.\n\nPlayers can build walls anywhere, which is like removing an edge. The only constraint is that they cannot fully block the opponent's path to their goal (or their own). Thus, each player and its goal form a bonded pair, and the essential edges are the walls that cannot be placed.\n\nIn the picture, the bonded pairs are [u, v] and [w, x], and the essential edges are shown in red.\n\nImagine that we want to implement a feature in the Wall Game website where, when you hover over a wall slot, it is highlighted in red if the move is invalid. To do this, we need to solve the single-edge cut problem. Beyond that, it could also be useful to program an engine, which needs to consider lots of moves.\n\nNote: the graph from the Wall Game may not be connected (see, e.g., the isolated connected component in the top-left corner)--all we are guaranteed is that each bonded pair is in the same connected component. In this blog post, we assume the graph is connected for simplicity, but it is not hard to extend the algorithm to the disconnected case. We just do an initial pass to find all the connected components, and then process each one separately.\n\nWhy do we frame the problem in terms of k pairs, and not just two? There are variants of the Wall Game with more than two players:\n\nIn this 4-player variant, Player 1 needs to catch Player 2 before they themselves are caught by Player 4, Player 2 needs to catch Player 3 before they are caught by Player 1, and so on. We can think of it as having four bonded pairs.\n\nBrute force solution\n\nThe naive solution is to consider each edge individually. For each edge e in E, we:\n\nRemove it from G (we denote the resulting graph as G - {e}).\n\nFind the connected components in G - {e}.\n\nIf two bonded nodes are in different connected components, e is essential.\n\nStep (1) takes O(1) time, Step (2) takes O(E) time (it can be done with a DFS or a BFS), and Step (3) takes O(k) time. The total runtime is O(E * (E+k)).\n\nEfficient solution\n\nIn this section, we'll solve the problem in O(E * k) time. In the next section, we'll see a more complicated but optimal O(E + k) algorithm.\n\nWe'll build up to it with a series of definitions and intermediate steps.\n\nDefinition: In a connected graph, a bridge is an edge which, if removed, disconnects the graph.\n\nIn the example above, the bridges are [0, 1], [2, 4], and [7, 8].\n\nDefinition: Given a pair of nodes in a connected graph, s and t, an st-bridge is an edge which, if removed, disconnects s and t.\n\nIn the context of our problem, an edge is essential if it is an st-bridge for some bonded pair [s, t].\n\nObservation 1: Every st-bridge is a bridge, but not necessarily the other way around.\n\nObservation 2: Given two nodes, s and t, take any path between them, P. Every st-bridge must be in P.\n\nObservation 2 is because if we remove any edge not in P, s and t will still be connected via P.\n\nMain result: Let P be any path between s and t. An edge is an st-bridge if and only if it is both a bridge and in P.\n\nWe can now formulate an algorithm based on this property:\n\nWe can find all the bridges in O(E) time using Tarjan's algorithm. We can find each path using DFS or BFS in O(E) time (interestingly, it doesn't matter how you find the path, as it can be any path). The total runtime is O(E + k * E) = O(E * k).\n\nHere's a TypeScript implementation.\n\nOptimal algorithm\n\nIf k is small, as in the Wall Game, the above algorithm is the most practical. In this section, we'll see a linear-time (O(E + k)) algorithm, which is asymptotically optimal for any k.\n\nThe bottleneck of the previous algorithm is finding the k paths between bonded pairs. To achieve linear time, we need to do this in a single pass.\n\nThe key property we'll use is that, in Observation 2 above, we can choose any path between each bonded pair. We can start by finding a spanning tree T of G, and focus only on the paths connecting the bonded pairs through T. We can find a spanning tree in O(E) time using a DFS or a BFS (it doesn't matter).\n\nIt will be convenient to think of T as a rooted tree, so that we can talk about node depths and lowest common ancestors. We can root it at any node.\n\nThe root is at depth 0, its children are at depth 1, and so on. The lowest common ancestor of a pair of nodes u and v in T, denoted LCA(u, v), is the node in T that is an ancestor of both nodes and has maximum depth.\n\nRecall that we want to identify all the edges in T that form paths between pairs of bonded nodes. Between any pair of nodes u and v, there is a unique path in T: the path that goes from u up to LCA(u, v) and from there down to v (note that LCA(u, v) could be u or v itself).\n\nWe can start by finding the LCA of each bonded pair in T. We can do this in linear time using Tarjan's off-line lowest common ancestors algorithm.\n\nHere is a tree for the example graph from above, rooted at 7:\n\nHenceforth, we say that a node u is bonded if it is bonded to at least one other node.\n\nFor each bonded node u, we define min_lca(u) as follows: among the LCA's of all bonded pairs involving u, min_lca(u) is the one with minimum depth.\n\nFor example, imagine that, in the tree above, node 1 is involved in 3 bonded pairs: [1, 3], [1, 0], and [1, 4]. The corresponding LCA's are 2 (at depth 2), 1 (at depth 3), and 4 (at depth 1). Of those, the one with minimum depth is 4, so min_lca(1) = 4.\n\nThe following observation characterizes the essential edges in terms of T:\n\nObservation 3: A bridge of G is essential if and only if it is between a bonded node u and min_lca(u).\n\nOn the one hand, if we removed a bridge between u and min_lca(u), the bonded pair consisting of u and the node v such that LCA(u, v) = min_lca(u) will become disconnected. On the other hand, if a bridge is not between any bonded node u and min_lca(u), every bonded pair has a path that doesn't go through it, so it is not essential.\n\nThe idea behind our linear-time algorithm is to do a traversal through T. At each node u, we want to find the LCA with minimum depth among all the bonded pairs with one node in subtree(u) (the subtree rooted at u), if any. That is, we want to find the minimum-depth node in T that is the min_lca(v) for some node v in subtree(u). We actually only care about its depth, which we call subtree_min_lca_depth(u). We can compute subtree_min_lca_depth(u) recursively, aggregating the results from each child as well as the depth of min_lca(u) itself if u is bonded:\n\nFinally, we can write a simple check for whether an edge in T is essential:\n\nObservation 4: If [w, u] is an edge in T, where w is the parent of u, [w, u] is essential if and only if (1) [w, u] is a bridge in G and (2) subtree_min_lca_depth(u) < depth(u).\n\nCondition (2) says that there is some node in the subtree rooted at u that is bonded to a node somewhere above u.\n\nHere is the full pseudocode:\n\nAs mentioned, finding bridges takes O(E) time, building a spanning tree takes O(E) time, and finding all k LCA's takes O(V + k) time; the remaining steps, including the main tree traversal, take O(V) time. Considering that the graph is connected, and thus V <= E, the total runtime is O(E + k).\n\nWant to leave a comment? You can post under the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/single-edge-cut-problem#efficient-solution",
      "author": "",
      "user_id": ""
    },
    {
      "title": "A topology/geometry puzzle",
      "content": "A topology/geometry puzzle\n\nIn this post, we'll study what kind of solids (3D shapes) we can get by taking a solid and merging two of its faces.\n\nThe goal of this project is to characterize every solid that can be created starting from a platonic solid (what that means, precisely, will be clear later). I'm ~40% of the way there.\n\nDisclaimer: I have not done any literature review for this post (I did enough of that in grad school!) so it is very likely that this space has already been explored. This is just for fun. If you happen to know of any related work, please let me know!\n\nLet's formalize what operations are valid. I'll start with (filled) 2D shapes, which are easier to visualize.\n\nIn topology, a cube, a sphere, and a sock are all the same thing because they can be deformed into one another without cutting or gluing. We say they are homeomorphic.\n\nWe have a similar concept here, but we also account for vertices and edges. These three 2D shapes are homeomorphic because they all have a face with 4 vertices and edges:\n\nIn contrast, a square is not homeomorphic with a triangle, because, even though both can be deformed into the same 'shape', the vertices and edges do not match.\n\nThe same applies to 3D solids, where two solids are homeomorphic if they can be deformed into one another without cutting or gluing, with matching faces, edges, and vertices. These two shapes are homeomorphic:\n\nThis is the only operation we can do which transforms a 2D shape (or 3D solid) into another shape/solid that is not homeomorphic to the original one. I'll start with 2D.\n\nIn 2D, we can merge pairs of edges. First, it must be possible to wiggle the shape until the two edges line up without anything in between them. Then, we 'merge' them by lining up the edges and removing the edges and the lined up vertices. The two faces of the edges become one if they weren't already.\n\nThis should be intuitive with an image. Given a square, we can merge opposite edges or adjacent edges:\n\nWhen we merge adjacent edges of a square, we can get a vertex that connects an edge to itself. We call this shape a 'pointy circle'.\n\nNote the requirement of \"without anything in between them\". This means that, for instance, we cannot merge the inner and outer edges of a 2D torus, because the torus itself is in between.\n\nMerging two faces of a triangle results in a circle.\n\nThere are some edge cases to address.\n\nEdge Case 1: Dangling Edge\n\nWhen merging two edges, we may end up with an edge that ends in the middle of a face. We call this a 'dangling edge'. By convention, we remove dangling edges as part of the merging operation, like e in the image below.\n\nThe remaining vertex, p, was not adjacent to either of the merged edges, so it stays.\n\nEdge Case 2: Surviving vertex\n\nWhen merging two edges, the aligned vertices usually disappear. However, if a vertex is also connected to another edge which is not merged (or dangling), it will stay, like p in the image below. Edges a and b are not merged, so p stays.\n\nMerging in 3D is the same as in 2D, but we merge faces instead of edges.\n\nIn order for two faces to be mergeable, they must be homeomorphic (same number of vertices and edges, same holes, etc) and it must be possible to wiggle them so they line up without anything in between them.\n\nTetrahedron\n\nCharacterizing the tetrahedron is trivial.\n\nI'll use gifs to show 3D solids. The gifs show the solid from the front (left) and the back (right). They were made with this Python app I vibe coded.\n\nMerging any two faces of a tetrahedron gives us an 'edged sphere' (a sphere with two faces, a single circular edge, and no vertices).\n\nWhen I say \"characterize the tetrahedron\", I mean constructing a directed acyclic graph (DAG) of all the possible solids we can get by merging faces starting from a tetrahedron.\n\nThe tetrahedron DAG just has two nodes:\n\nWe say a solid is irreducible if it cannot go through any more merging operations. Irreducible solids correspond to leaves in the DAG.\n\nThe cube is where things get interesting. For one, the cube DAG is infinite.\n\nCube branch 1: merging opposite faces\n\nAnalogously to how merging opposite edges of a square gives us a 2D torus, merging opposite faces of a cube results in a 3D torus with a square cross-section, which we call a 'square torus'.\n\nHowever, when we wiggle the cube, we can twist it before lining up the faces. This still results in a torus with a square cross-section, but one which is not homeomorphic to the non-twisted torus. In fact, the number of faces changes depending on how much we twist it.\n\nIf we twist it 90 degrees, we get a single face:\n\nIf we twist it 180 degrees, we get two faces:\n\nIf we twist it 270 degrees, we get a single face again:\n\nFrom that point on, the number of faces repeats. For instance, if we twist it 360 degrees, we get four faces again.\n\nIf we keep twisting it more, the number of faces repeats 4 -> 1 -> 2 -> 1 -> 4 -> 1 -> 2 -> 1 -> ..., but none of those solids are homeomorphic. So, by twisting, we can get an infinite number of different solids.\n\nIf we take the square torus without any twisting and merge adjacent faces, we get a torus where the cross-section is a pointy circle.\n\nIf we merge opposite faces instead, we get a torus with a torus cavity, i.e., a torus with a 2D-torus cross-section.\n\nThe square toruses that have 1 or 2 faces after twisting (e.g., with a 90 degree or 180 degree twist) are irreducible because there are not enough faces.\n\nThe square toruses that have 4 faces after twisting (e.g., with a 360 degree twist) are not irreducible, regardless of how much we twisted them:\n\nIf we merge opposite faces, we get the a torus with a hole again. Surprisingly, this merge \"undoes\" the twisting.\n\nIf we merge adjacent faces instead, we get a pointy-circle torus again, but this time the edge twists around the cross-section. The amount of twisting depends on how much we twisted the cube, so we can get an infinite number of different pointy-circle toruses. Here is the pointy-circle torus with 360 degree of twisting:\n\nThis covers every solid we can get from a cube by merging opposite faces.\n\nCube branch 2: merging adjacent faces\n\nStarting from a cube, if we merge adjacent faces, we get a cylinder with a pointy-circle cross-section.\n\nFrom there, we can merge the top and bottom faces of the cylinder to get a pointy-circle torus. When we do that, we can twist it to get all the same infinitely many pointy-circle toruses with twisting that we got from the square toruses.\n\nWe can now complete the cube DAG:\n\nPersonally, what I find interesting about the cube DAG is how it is possible to reach the solids that require two steps in multiple ways.\n\nCounting faces by cross-section sides and twists\n\nBefore getting to the other platonic solids, I'll go on a tangent to show a cute result:\n\nA torus with a k-gon cross-section and n 'face twists' has GCD(k, n) faces.\n\nGCD is the greatest common divisor\n\nA k-gon is a polygon with k sides\n\nA face twist is a twist of 360/k degrees. For instance, 1 face twist means that, in one full rotation of the torus, each face ends up one face over.\n\nWe already saw some examples with the square torus (a 4-gon torus):\n\n0 face twists (0 degrees): GCD(4, 0) = 4 faces\n\n1 face twist (90 degrees): GCD(4, 1) = 1 face\n\n2 face twists (180 degrees): GCD(4, 2) = 2 faces\n\n3 face twists (270 degrees): GCD(4, 3) = 1 face\n\n4 face twists (360 degrees): GCD(4, 4) = 4 faces\n\nThis result also explains why the number of faces repeats as we twist the square torus further.\n\nHere are some examples with a different k-gon, a 12-gon:\n\nIf you want to play with different k-gons and number of face twists, the source code for the Python app is here.\n\nThe argument for why the number of faces is GCD(k, n) is as follows:\n\nProof: Pick any cross-section of the torus, C. C is a k-gon, so we can label its edges with 0, 1, 2, ..., k-1 along the twist direction.\n\nIf we walk along a face of the torus, starting from C, edge 0, by the time we get back to C, we'll have moved n edges over in the twist direction. Since there are only k edges, that means we'll end up at edge n % k.\n\nIf we keep walking along the torus, we'll reach, edges 0, n % k, 2*n % k, 3*n % k, and so on, until we reach a number i*n that is a multiple of k and we get back to edge 0. All these edges belong to the same face of the torus. Thus, each face of the torus covers i edges of C, making the total number of faces k / i. Now we just need to see that k / i = GCD(k, n).\n\nThe number i*n is the first multiple of n that is also a multiple of k. In other words, i*n = LCM(k, n), where LCM is the least common multiple.\n\nRecall the GCD-LCM identity: GCD(a, b) * LCM(a, b) = a * b.\n\nUsing that LCM(k, n) = i*n, we get that GCD(k, n) * (i*n) = k * n, so k / i = GCD(k, n). ∎\n\nOctahedron (work in progress)\n\nAs of March 2025, I haven't finished the octahedron DAG yet.\n\nOctahedron branch 1: merging edge-adjacent faces\n\nIf we merge two faces sharing an edge, we get this shape with two triangle faces and two 2-gon or 'digon' faces (a closed shape with two edges) which I'll be calling 'eye' shapes:\n\nCan anyone suggest a good name for this shape? I'll go with 'Dorito' for now.\n\nIf we merge the two 'eye' faces of the 'dorito', we get a kind of torus with a single point in the center instead of a hole, and an edge along the outside of the torus. Since the two eyes share a vertex, no twisting is possible.\n\nUnfortunately, as I mentioned, I vibe coded the Python app to draw the 3D solids, and this is the limit of what I've managed to get Claude to draw. So, for the remaining faces I only have sketches or nothing at all.\n\nIf we merge the two triangle faces, it's hard to visualize what happens, but (I think) one of the eyes becomes an inner face and the other an outer face. The 'dorito' shape has a vertex shared by all four faces, so, since it is adjacent to the two 'eyes', which are not merged, it stays after the merge (see edge case 2 in merging). That means that the outer and inner face share a vertex.\n\nThe final shape looks like a 3D 'teardrop' solid with a 'teardrop' cavity, where both teardrops share the top vertex.\n\n~Insert joke here about how the eyes turned into teardrops.~\n\nThat's all we can do in the first branch of the octahedron DAG.\n\nOctahedron branch 2: merging vertex-adjacent faces\n\nIf we merge two faces sharing a vertex, we get this shape, which I'll call the 'petal'.\n\nThe only thing we can do with the petal is merging the two pointy-circle faces sharing a vertex, which results in a torus with a single vertex in the center instead of a hole.\n\nThat ends this branch.\n\nOctahedron branch 3: merging opposite faces\n\nThis is the most interesting branch. Anytime we merge two faces that don't share any edges or vertices, we form some kind of torus. In this case, I think it's a torus with a hexagonal cross-section, except for a single point in which three of the edges 'collapse' into vertices and the cross-section is a triangle (at least, that's one way to draw it -- it's not the only way). Here is my best attempt at sketching the 'collapse point':\n\nIf I counted correctly, this solid has 3 faces, 6 edges, and 3 vertices regardless of how much twisting we do. I'm not sure whether it is irreducible, and whether that depends on the amount of twisting.\n\nOctahedron DAG\n\nThis is what I have so far:\n\nUnlike the cube, we don't get any shared solids between the branches.\n\nWhat's next?\n\nI don't know much about the dodecahedron and icosahedron yet. What's clear is that I pushed the limit of both vibe coding and of the 2D drawing editor (the amazing Ipe). I think Blender is the right tool for this, and I'm actually curious enough about what these shapes look like that I started messing around with it. So far, I managed to make this (scuffed) two-faced solid, which I incorrectly thought could be obtained from the octahedron:\n\nThis project started from seeing this gif:\n\nThe concept of a solid mobius strip was new to me, and I started thinking about variations and how to construct them. That led me to the idea of starting with a cube and merging two faces. Then, I did something very common in math: I started thinking about possible generalizations.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/merging-geometry#merging",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game UI Design (+ Frontend Generators)",
      "content": "Wall Game UI Design (+ Frontend Generators)\n\nThis blog post is a design doc for the frontend of wallgame.io, a board game I'm making. However, something probably more interesting came out of it: an assessment of frontend generators' ability to one-shot a 6000-word design doc prompt. The results deeply impressed me. They are in an appendix at the bottom. Feel free to skip the design doc and check out the appendix.\n\nThis is the specification of the frontend for the Wall Game, an online strategy board game. It only specifies the logic/functionality. It is agnostic of the look.\n\nA first version of the game is already available at wallwars.net. This is a UI overhaul with the following goals:\n\nA smooth onboarding experience. It should be very clear how to navigate the site and in what order to do things.\n\nTeaching the game to new players in a structured way.\n\nExpansive solo modes so that players can have fun even if there is no one else online.\n\nImproving the user journey of inviting friends to play.\n\nSupporting game variants as a first-class feature (this was a key feature for replayability when playing with a physical board).\n\nSupporting game variants with a varying number of players.\n\nSupporting multiple bots, including custom bots to foster the \"engine dev\" community.\n\nClean interface to game data, like past games, player history, rankings, etc., by showing interlinked tables with SQL-like features like filtering.\n\nMore \"social\" features, like an in-game chat and the ability to watch live games.\n\nFrontend Overview\n\nThe site is a SPA (single page app). There are 9 main pages, all of which are accessible from the top navigation bar. If a screen is not wide enough to show all the tabs, they are collapsed as necessary into a hamburger menu icon. Tabs act as buttons to show the corresponding page. Pages are self-contained and have their own URL:\n\nIn order, the tabs are:\n\nPlay (default) - wallgame.io\n\nRanking - wallgame.io/ranking\n\nPast games - wallgame.io/past-games\n\nLive games - wallgame.io/live-games\n\nLearn - wallgame.io/learn\n\nAbout - wallgame.io/about\n\nSettings - wallgame.io/settings\n\nProfile (appears as Login if the user is not logged in) - wallgame.io/profile\n\nThe navigation bar is always visible, and the current tab is highlighted.\n\nWe'll first go over the basic concepts, then some of the basic components reused across multiple pages, and finally, we'll go over each page (out of order).\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nPlayer types: there are 5 player types in the context of a game created by a user: \"You\": the user itself. \"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.) \"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\"). \"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game. \"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nPlayer types: there are 5 player types in the context of a game created by a user:\n\n\"You\": the user itself.\n\n\"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.)\n\n\"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\").\n\n\"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game.\n\n\"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter): The user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win). The user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully. The user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter):\n\nThe user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win).\n\nThe user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully.\n\nThe user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nThis section describes specific high-level components of the UI, which are reused in various places.\n\nThis is the main component involved in playing the game.\n\nA rectangular grid of square cells, with thick margins between them (that's where the walls go).\n\nA cell may contain one or more pawns. There is no limit on how many pawns can be in the same cell.\n\nA staged or premoved pawn move is shown with an arrow. Arbitrary arrows can also be added as calculations. It should be clear which one is which.\n\nBetween every two cells adjacent vertically or horizontally, there is a space where a wall can be placed, staged, premoved, calculated, or missing.\n\nThe corner between four cells is called a \"pillar\" and is not an interactable element.\n\nPlaced walls are colored according to the color of the pawns of the player who placed them.\n\nSimilar to chess and checkers, the cells are colored alternatively, so that cells that are an even number of moves away from each other share a color. The contrast between the two colors is subtle.\n\nLike chess, rows are labeled with numbers (starting from 1 on the top) and columns are labeled with letters (starting from 'a' on the left). The first cell in each row is labeled with the corresponding row number. The first cell in each column is labeled with the corresponding column letter. The labels are subtle, taking only a corner of the cell.\n\nThe last move is highlighted so it is easy for players to see what the opponent just did.\n\nThis includes the board itself and surrounding elements for any related information and interactions:\n\nthe timers. The timer of the player to move is highlighted.\n\nthe player names and ELOs. The name of the player to move is highlighted.\n\nthe move history in standard notation, with buttons to go back and forth and buttons to go to the beginning and latest move.\n\nthe chat. The chat can have multiple \"channels\": the \"game chat\", seen by all the players but not the audience the \"team chat\", seen only by players on the same team the \"audience chat\", seen only by the audience\n\nthe \"game chat\", seen by all the players but not the audience\n\nthe \"team chat\", seen only by players on the same team\n\nthe \"audience chat\", seen only by the audience\n\nan indicator of whose turn it is\n\nonline indicators for each player (if a player does not have the game tab/app active, it shows as offline)\n\nmenus for out-of-game interactions: \"resign\", \"offer draw\", \"propose take back\", \"give time (1 min)\", \"rematch\"\n\na button to toggle sounds\n\ncontextual information: the game variant and parameters the time control rated status the match score whose turn it is the player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\") after the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\nthe game variant and parameters\n\nthe time control\n\nrated status\n\nthe match score\n\nwhose turn it is\n\nthe player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\")\n\nafter the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\na button to see/copy the game's replay notation and standard notation\n\nGame configuration panel\n\nThis includes all the configuration options for a game.\n\ntime control: a selector with the options \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\".\n\nrated status: yes/no. If the player is not logged in, the 'rated status' is set to \"no\" and grayed out. There should be an informational text that says that the user needs to be logged in to play rated games.\n\nvariant: a selector of supported variants.\n\nadditional parameters that depend on the variant. These parameters appear in a container, and the container changes depending on the variant.\n\nFor example, for the standard variant:\n\nBoard width: number. Default: 8\n\nBoard height: number. Default: 8\n\nPlayer configuration\n\nA little component that lets you configure how a player in a game will move. It consists of a selector with a few options, each of which has an informational text.\n\n\"You\": \"You'll make the moves.\"\n\n\"Friend\": \"You'll get a link to share with a friend to join the game.\"\n\n\"Matched user\": \"You'll be paired with a random player with compatible settings and similar rating.\"\n\n\"Easy Bot\": \"You'll play against an easy AI bot.\"\n\n\"Medium Bot\": \"You'll play against a medium AI bot.\"\n\n\"Hard Bot\": \"You'll play against a hard AI bot.\"\n\n\"Custom bot\": \"You'll get an access token so that you can connect your own bot. See here for more information.\" The text links to a blog post explaining how to make a custom bot and connect it to the game using the token.\n\nThere is no default. It depends on the context.\n\nGame setup page\n\nThis page has its own URL: wallgame.io/game-setup.\n\nIt has two sections:\n\nCreate game\n\nCreate game\n\nThis part has the following elements:\n\nA button: \"Create game\".\n\nA player configuration component for each player (which depends on the variant, as set in #4). The selectors are labeled \"Player 1\", \"Player 2\", and so on. The default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe selectors are labeled \"Player 1\", \"Player 2\", and so on.\n\nThe default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe game configuration panel. Choosing a variant with more than 2 players will affect the number of player configuration components in #2.\n\nThis part has the following elements:\n\nA heading \"Join game\"\n\nA table showing games from other players that are in the \"matching stage\" and waiting for someone to join.\n\nThe table has the following columns:\n\nJoin: a button which, when clicked, joins the game.\n\nRated: yes/no.\n\nTime control: a string formatted like \"blitz (3+2)\"\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height).\n\nPlayer: a string formatted like \"name1 (1200)\". The numbers in parentheses is the rating. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (XXX) & name2 (YYY) vs name3 (ZZZ)\".\n\nThe rows are ordered by ELO closest to the current user's ELO. If the user chose a variant, rated status, time control, or board size in the game configuration panel, rows matching those settings are prioritized. Games that have been in \"matching stage\" for longer are also prioritized.\n\nThe parameterized URL is wallgame.io/game/game-id\n\nThe game page shows a game, identified with a given game ID in the URL. The game could be in the \"matching stage\", ongoing, or finished (a past game) The URL can be shared to join the game (if it is in the \"matching stage\"), to spectate it live (if it is ongoing) or watch it as a past game (if it is finished).\n\nThe game page has one main component: the board view.\n\nDepending on the context, it could contain other elements. See, e.g., the case of the \"Solo campaign\" puzzles, which contain an additional explanation text. So far, this seems to be the only exception.\n\nMatching stage panel\n\nWhen a user creates a game from wallgame.io/game-setup, a game ID is generated and they are taken to the game page with that game ID.\n\nHowever, it is possible that not all players are ready. For instance, if one of the player types is \"friend\", the game cannot start until the friend joins the game.\n\nIf not all players are ready, a \"matching stage\" panel component is shown as a modal over a faded out version of the game page.\n\nThe modal has a title: \"Waiting for players\". It contains one row for each player. Each row contains:\n\nThe player type (e.g., \"You\", \"Friend\", \"Easy Bot\", \"Medium Bot\", \"Hard Bot\", \"Custom Bot\", \"Matched player\")\n\nAn indication of whether the player is ready.\n\nInstructions for how that player should join the game If the player is \"You\", the player is automatically ready. If the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard. If the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready. If the player is \"Custom Bot\", the instructions include an access token for a custom bot. If the player is \"Matched player\", the instructions are to wait for someone to join.\n\nIf the player is \"You\", the player is automatically ready.\n\nIf the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard.\n\nIf the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready.\n\nIf the player is \"Custom Bot\", the instructions include an access token for a custom bot.\n\nIf the player is \"Matched player\", the instructions are to wait for someone to join.\n\nA button to abort the game and return to the previous page.\n\nIf a player joins a game but there are other players that are not ready (in the case of variants with more than 2 players), they will also see the matching stage panel.\n\nTab 7: Settings\n\nSettings have three sections:\n\nUser settings\n\nVisual style\n\nDefault game parameters\n\nFor sections 2 and 3, there should be an information box indicating that if the user is not logged in, they are saved as local cookies in the web browser. If they are logged in, the settings are saved to their account instead.\n\n1. User settings\n\nThis has one field:\n\nDisplay name (text field)\n\nIt behaves a bit differently depending on if the user is logged in.\n\nFor logged in users, the display name shows their current name and it is editable.\n\nThere should be a button next to the \"display name\" text field that says \"Change if available\" and an informational text that says \"Names must be unique across the site (case insensitive). You can only switch to another name not already in use.\" The button should be grayed out if the text field matches their current name. Names including \"guest\" or \"deleted\" or \"bot\" are not allowed. If the user tries to change to such a name, it should be explained to them.\n\nIf the user is not logged in, the display name should be grayed out and fixed as: \"Guest\"\n\nThere should also be an indication that the user needs to be logged in to change their display name, with a button to the Profile page.\n\n2. Visual style\n\nDark theme: on/off. Default: on\n\nBoard theme: selector. Default: \"classic\".\n\nPawn color: selector. Default: default.\n\nCat pawn: selector.\n\nMouse pawn: selector.\n\n... (one selector for each pawn type that appears in any variant)\n\nThe pawn selectors are between icons/small images.\n\n3. Default game parameters.\n\nThis is the game configuration panel component.\n\nA text says, \"When setting up a game, these parameters will be used as default.\"\n\nTab 6: About\n\nThis contains short informational text. The text can be something like this:\n\n\"Wall Game is a board game about building walls and outsmarting your opponents. It is inspired by Quoridor (wiki link) and Blockade (wiki link). Basic instructions about navigating the website (where to find the rules etc). Created by Nil Mamano (link). For more, you can read the blog (link).\"\n\nTab 8: Profile\n\nThis page looks different depending on whether the user is logged in or not.\n\nNot logged in\n\nThe tab appears as \"Login\".\n\nThe page shows two main buttons: log in and sign up\n\nIt includes a bit of text: \"Log in or sign up to choose a name, play rated games, and see your game history.\"\n\nFor the login and sign up flows, the user is redirected to an external auth service, so they are not part of this UI.\n\nThe tab appears as \"Profile\".\n\nIt shows the user display name and rating at the top, followed by a series of buttons grouped in two groups:\n\nPast Games: takes you to the Past Games tab but with the user's name already set as filter.\n\nRanking: takes you to the Ranking tab but with the user's name already set as filter.\n\nSettings: takes you to the settings page.\n\nDelete account\n\nThe delete account button shows a confirmation dialog: \"Your email will be deleted from the DB and all games you played will appear as 'Deleted User' and you won't be able to play again with this account. Are you sure?\"\n\nTab 3: Past games\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default. Filters are added as query parameters to the URL, so they can be shared.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nPlayer: text field (empty field acts as \"all\")\n\nPlayer: text field (empty field acts as \"all\").\n\nTime period: a date range\n\nThe two player fields serve the same purpose. Filling only one gives you all games with that player. Filling both gives you all games including both players.\n\nGames with fewer than 2 moves are filtered out. Games aborted during the \"matching stage\" are not even stored.\n\nThe rows are ordered by date. The order cannot be changed.\n\nWatch: a button which, when clicked, takes you to see the past game.\n\nVariant: clicking on a variant sets the variant filter.\n\nRated: yes/no. Clicking on a rating sets the rated status filter.\n\nTime control: a string formatted like \"blitz (3+2)\". Clicking on a time control sets the time control filter.\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height). Clicking on a board size sets the board size filter.\n\nPlayers: a string formatted like \"name1 (1200) vs name2 (1234)\". The numbers in parentheses are the ratings at the start of the game. Clicking on a name sets the first player filter. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (1200) & name2 (1234) vs name3 (1234) & name4 (1234)\". Clicking on the \"vs\" sets both player filters, with slight tweaks depending on the variant.\n\nMoves: a number. The number of moves of the game.\n\nViews: a number. The number of views the game got.\n\ndate: date type. When the game was played.\n\nThe name of the winning player is highlighted. Draws are also indicated.\n\nPast game view\n\nWhen a user clicks the \"Watch\" button for a past game, they are taken to the \"game page\" for that game (e.g., wallgame.io/game/2ei3nd43).\n\nThe final position is shown by default.\n\nThe chat is grayed out with a message that says \"Chat is not preserved.\"\n\nTab 4: Live games\n\nSimilar to the \"Past games\" page, this page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nThe formatting of the columns is the same as for \"Past Games\".\n\nWatch: a button that takes you to spectate the game in real time.\n\nViewers: a number.\n\nVariant: see \"Past games\" table.\n\nRated: see \"Past games\" table.\n\nTime control: see \"Past games\" table.\n\nBoard size: see \"Past games\" table.\n\nPlayers: see \"Past games\" table.\n\nMoves: see \"Past games\" table.\n\nThe rows are sorted by viewers first, by max ELO second.\n\nWhen a game ends, the number of spectators becomes the initial number of views in the past games table.\n\nLive game view\n\nWhen a user clicks the \"Watch\" button for a live game, they are taken to the \"game page\" for that game (e.g., wallgame.io/live/2ei3nd43).\n\nThe latest state of the game is shown by default.\n\nAs players make moves, spectators receive and see real-time updates.\n\nSpectators see the \"Spectator chat\", which is different than the ones the players see.\n\nTab 2: Ranking\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe filters do not have an \"all\" option.\n\nVariant: default: standard\n\nTime control: default: rapid\n\nPlayer: text field. Default: empty. The player filter acts more like a search box. If filled and the player exists, it only shows the row corresponding to that player and a few rows before and after. If the player does not exist, it shows nothing.\n\nRank: number starting at 1\n\nPlayer: the display name. It updates whenever players change their names delete their accounts.\n\nRating: the ELO rating. These are numbers sorted in decreasing order.\n\nPeak rating: the max ELO rating that player has ever had.\n\nRecord: a string formatted like \"10-4\" indicating the number of points the player got and lost across all its games.\n\nFirst game: a date.\n\nLast game: a date.\n\nClicking anywhere on a row takes you to the \"Past games\" page with the variant, time control, and player filters set. The \"rated\" filter is also set to \"yes\".\n\nTab 5: Learn\n\nThis page contains only static content, in four sections:\n\nRules (standard)\n\nNotation (standard)\n\nLessons (standard)\n\nAll the sections may contain images.\n\nSections can be collapsed.\n\nThis contains a couple of paragraphs explaining the rules of the \"standard\" variant.\n\nIt ends with: \"You can now start the solo campaign.\", with a link to the play tab (wallgame.io).\n\nThis contains a couple of paragraphs explaining the standard notation. This is useful since it appears in the game history element of the \"board view\" component.\n\nThis contains a bullet point list of links to blog posts explaining strategic and tactical ideas. More lessons can be added over time.\n\nThis contains definitions and special rules for all the supported variants.\n\nTab 1: Play\n\nThis is the 'landing' page.\n\nIts main purpose is to easily access the 6 game modes:\n\nSolo campaign\n\nStudy board\n\nPlay with others\n\nInvite friend\n\nIt contains three sections:\n\nSingle-player fun\n\nPlay with others\n\nGame showcase\n\nThe first two contain various buttons to go to the various game modes. The final one is just decorative. It's not there because it's related to the \"Play\" theme, but because it's the landing page.\n\nSingle-player fun\n\nThis section contains the following buttons:\n\nSolo campaign. There is an annotation that says \"Start here!\"\n\nStudy board\n\nPlay with others\n\nThis section contains the following buttons:\n\nFind others\n\nInvite friend\n\nGame showcase\n\nThis section shows a board and autoplays random past games, at high speed (2 moves per second). Above the board, a text says: \"Game showcase: name1 (1200) vs name2 (1234) (DATE)\", with the players and date updating as the game changes. There should also be a button to stop the autoplay.\n\nClicking on it takes you to the \"game page\" to watch the game, analogous to the \"Past games\" page. The only difference is that the game starts at the position that last played automatically in the game showcase.\n\nGame mode 2: Puzzles\n\nThe URL is wallgame.io/puzzles\n\nThe puzzles page has a list of puzzles.\n\nEach puzzle has:\n\nplay button\n\ndifficulty rating\n\ncompleted: yes/no. An indication of whether the user already solved it\n\nIf the user is not logged in, the 'completed' status is grayed out. There should be an information box indicating that the user should log in to save their completion status.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/puzzles/1, where 1 is the puzzle number. This makes it so that the user can share a puzzle by sharing the route.\n\nGame mode 1: Solo campaign\n\nThe URL is wallgame.io/solo-campaign\n\nThe solo campaign menu consists of a list of puzzles just like the menu for puzzles.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/solo-campaign/1, where 1 is the puzzle number.\n\nUnlike in normal puzzles, in solo campaign puzzles:\n\nThere is a text above the board view indicating what to do to win.\n\nThe game is usually played until the end.\n\nGame mode 3: Play vs AI\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Easy Bot\".\n\nGame mode 5: Play with others\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Matched user\".\n\nGame mode 6: Invite friend\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Friend\".\n\nGame mode 4: Study board\n\nThis takes you to a special instance of the \"game page\" with route wallgame.io/study-board.\n\nThe design for the study board page is work in progress.\n\nFinal thoughts\n\nI usually figure out the shape of things as I build them, like I did for wallwars.net, instead of writing a long design doc upfront. However:\n\nTo justify a full rewrite, I wanted to make sure the new design would accomplish the improvements that I wanted to see on the original site (see the list at the beginning of this post).\n\nAI-assisted coding has made all coding easier, but it has improved new code generation more than it has improved refactoring. For me, this shifted the tradeoff to the point where it seemed worth it to try to preempt as many direction shifts as possible.\n\nIn any case, now that I have this doc, I think it's a good opportunity to test out the various frontend generators (lovable and company) and see what they spit out. I probably won't use any of them directly, but they should give me good ideas for the styling.\n\nI fed this whole blog post to v0.dev (free tier). The prompt was \"Create mocks for the attached design doc.\" + this blog post, which is about 6000 words (a 33kB attachment).\n\nApart from putting the files in the wrong directory, it one-shotted the whole app with great prompt adherence and, in my opinion, great taste to fill in the gaps (recall that this design doc says basically nothing about styling).\n\nYou can see the results below (I skipped the less interesting pages).\n\nI emphasize that I did not have to break down the prompt into smaller chunks, as I'm so used to with tools like Cursor or basically anything LLM-based. I did not have to go screen by screen. It generated about 20 files and 3000 lines of next.js, with all navigation working as expected and mock data. I did not have to carefully craft a prompt on top of the design doc (though you can argue that this blog post is a great prompt). As someone who uses vibe coding regularly, this truly impressed me.\n\nI tried other frontend generators with the same prompt. lovable.dev did OK with prompt adherence (some pages did not work), but it did not have the same taste as v0.dev. It looks like a generic corporate site. Lovable's board component also looks messed up.\n\nbolt.new had great prompt adherence, about the same as v0.dev, but the site looked generic like lovable's (and the board was also messed up). V0 had the best use of space.\n\nOther tools I tried had a prompt length limit, so I didn't bother.\n\nIn the end, I just went back to v0.dev and used the rest of my daily free credits to ask it for different color themes.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-ui#game-setup-page",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game UI Design (+ Frontend Generators)",
      "content": "Wall Game UI Design (+ Frontend Generators)\n\nThis blog post is a design doc for the frontend of wallgame.io, a board game I'm making. However, something probably more interesting came out of it: an assessment of frontend generators' ability to one-shot a 6000-word design doc prompt. The results deeply impressed me. They are in an appendix at the bottom. Feel free to skip the design doc and check out the appendix.\n\nThis is the specification of the frontend for the Wall Game, an online strategy board game. It only specifies the logic/functionality. It is agnostic of the look.\n\nA first version of the game is already available at wallwars.net. This is a UI overhaul with the following goals:\n\nA smooth onboarding experience. It should be very clear how to navigate the site and in what order to do things.\n\nTeaching the game to new players in a structured way.\n\nExpansive solo modes so that players can have fun even if there is no one else online.\n\nImproving the user journey of inviting friends to play.\n\nSupporting game variants as a first-class feature (this was a key feature for replayability when playing with a physical board).\n\nSupporting game variants with a varying number of players.\n\nSupporting multiple bots, including custom bots to foster the \"engine dev\" community.\n\nClean interface to game data, like past games, player history, rankings, etc., by showing interlinked tables with SQL-like features like filtering.\n\nMore \"social\" features, like an in-game chat and the ability to watch live games.\n\nFrontend Overview\n\nThe site is a SPA (single page app). There are 9 main pages, all of which are accessible from the top navigation bar. If a screen is not wide enough to show all the tabs, they are collapsed as necessary into a hamburger menu icon. Tabs act as buttons to show the corresponding page. Pages are self-contained and have their own URL:\n\nIn order, the tabs are:\n\nPlay (default) - wallgame.io\n\nRanking - wallgame.io/ranking\n\nPast games - wallgame.io/past-games\n\nLive games - wallgame.io/live-games\n\nLearn - wallgame.io/learn\n\nAbout - wallgame.io/about\n\nSettings - wallgame.io/settings\n\nProfile (appears as Login if the user is not logged in) - wallgame.io/profile\n\nThe navigation bar is always visible, and the current tab is highlighted.\n\nWe'll first go over the basic concepts, then some of the basic components reused across multiple pages, and finally, we'll go over each page (out of order).\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nPlayer types: there are 5 player types in the context of a game created by a user: \"You\": the user itself. \"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.) \"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\"). \"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game. \"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nPlayer types: there are 5 player types in the context of a game created by a user:\n\n\"You\": the user itself.\n\n\"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.)\n\n\"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\").\n\n\"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game.\n\n\"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter): The user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win). The user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully. The user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter):\n\nThe user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win).\n\nThe user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully.\n\nThe user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nThis section describes specific high-level components of the UI, which are reused in various places.\n\nThis is the main component involved in playing the game.\n\nA rectangular grid of square cells, with thick margins between them (that's where the walls go).\n\nA cell may contain one or more pawns. There is no limit on how many pawns can be in the same cell.\n\nA staged or premoved pawn move is shown with an arrow. Arbitrary arrows can also be added as calculations. It should be clear which one is which.\n\nBetween every two cells adjacent vertically or horizontally, there is a space where a wall can be placed, staged, premoved, calculated, or missing.\n\nThe corner between four cells is called a \"pillar\" and is not an interactable element.\n\nPlaced walls are colored according to the color of the pawns of the player who placed them.\n\nSimilar to chess and checkers, the cells are colored alternatively, so that cells that are an even number of moves away from each other share a color. The contrast between the two colors is subtle.\n\nLike chess, rows are labeled with numbers (starting from 1 on the top) and columns are labeled with letters (starting from 'a' on the left). The first cell in each row is labeled with the corresponding row number. The first cell in each column is labeled with the corresponding column letter. The labels are subtle, taking only a corner of the cell.\n\nThe last move is highlighted so it is easy for players to see what the opponent just did.\n\nThis includes the board itself and surrounding elements for any related information and interactions:\n\nthe timers. The timer of the player to move is highlighted.\n\nthe player names and ELOs. The name of the player to move is highlighted.\n\nthe move history in standard notation, with buttons to go back and forth and buttons to go to the beginning and latest move.\n\nthe chat. The chat can have multiple \"channels\": the \"game chat\", seen by all the players but not the audience the \"team chat\", seen only by players on the same team the \"audience chat\", seen only by the audience\n\nthe \"game chat\", seen by all the players but not the audience\n\nthe \"team chat\", seen only by players on the same team\n\nthe \"audience chat\", seen only by the audience\n\nan indicator of whose turn it is\n\nonline indicators for each player (if a player does not have the game tab/app active, it shows as offline)\n\nmenus for out-of-game interactions: \"resign\", \"offer draw\", \"propose take back\", \"give time (1 min)\", \"rematch\"\n\na button to toggle sounds\n\ncontextual information: the game variant and parameters the time control rated status the match score whose turn it is the player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\") after the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\nthe game variant and parameters\n\nthe time control\n\nrated status\n\nthe match score\n\nwhose turn it is\n\nthe player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\")\n\nafter the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\na button to see/copy the game's replay notation and standard notation\n\nGame configuration panel\n\nThis includes all the configuration options for a game.\n\ntime control: a selector with the options \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\".\n\nrated status: yes/no. If the player is not logged in, the 'rated status' is set to \"no\" and grayed out. There should be an informational text that says that the user needs to be logged in to play rated games.\n\nvariant: a selector of supported variants.\n\nadditional parameters that depend on the variant. These parameters appear in a container, and the container changes depending on the variant.\n\nFor example, for the standard variant:\n\nBoard width: number. Default: 8\n\nBoard height: number. Default: 8\n\nPlayer configuration\n\nA little component that lets you configure how a player in a game will move. It consists of a selector with a few options, each of which has an informational text.\n\n\"You\": \"You'll make the moves.\"\n\n\"Friend\": \"You'll get a link to share with a friend to join the game.\"\n\n\"Matched user\": \"You'll be paired with a random player with compatible settings and similar rating.\"\n\n\"Easy Bot\": \"You'll play against an easy AI bot.\"\n\n\"Medium Bot\": \"You'll play against a medium AI bot.\"\n\n\"Hard Bot\": \"You'll play against a hard AI bot.\"\n\n\"Custom bot\": \"You'll get an access token so that you can connect your own bot. See here for more information.\" The text links to a blog post explaining how to make a custom bot and connect it to the game using the token.\n\nThere is no default. It depends on the context.\n\nGame setup page\n\nThis page has its own URL: wallgame.io/game-setup.\n\nIt has two sections:\n\nCreate game\n\nCreate game\n\nThis part has the following elements:\n\nA button: \"Create game\".\n\nA player configuration component for each player (which depends on the variant, as set in #4). The selectors are labeled \"Player 1\", \"Player 2\", and so on. The default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe selectors are labeled \"Player 1\", \"Player 2\", and so on.\n\nThe default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe game configuration panel. Choosing a variant with more than 2 players will affect the number of player configuration components in #2.\n\nThis part has the following elements:\n\nA heading \"Join game\"\n\nA table showing games from other players that are in the \"matching stage\" and waiting for someone to join.\n\nThe table has the following columns:\n\nJoin: a button which, when clicked, joins the game.\n\nRated: yes/no.\n\nTime control: a string formatted like \"blitz (3+2)\"\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height).\n\nPlayer: a string formatted like \"name1 (1200)\". The numbers in parentheses is the rating. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (XXX) & name2 (YYY) vs name3 (ZZZ)\".\n\nThe rows are ordered by ELO closest to the current user's ELO. If the user chose a variant, rated status, time control, or board size in the game configuration panel, rows matching those settings are prioritized. Games that have been in \"matching stage\" for longer are also prioritized.\n\nThe parameterized URL is wallgame.io/game/game-id\n\nThe game page shows a game, identified with a given game ID in the URL. The game could be in the \"matching stage\", ongoing, or finished (a past game) The URL can be shared to join the game (if it is in the \"matching stage\"), to spectate it live (if it is ongoing) or watch it as a past game (if it is finished).\n\nThe game page has one main component: the board view.\n\nDepending on the context, it could contain other elements. See, e.g., the case of the \"Solo campaign\" puzzles, which contain an additional explanation text. So far, this seems to be the only exception.\n\nMatching stage panel\n\nWhen a user creates a game from wallgame.io/game-setup, a game ID is generated and they are taken to the game page with that game ID.\n\nHowever, it is possible that not all players are ready. For instance, if one of the player types is \"friend\", the game cannot start until the friend joins the game.\n\nIf not all players are ready, a \"matching stage\" panel component is shown as a modal over a faded out version of the game page.\n\nThe modal has a title: \"Waiting for players\". It contains one row for each player. Each row contains:\n\nThe player type (e.g., \"You\", \"Friend\", \"Easy Bot\", \"Medium Bot\", \"Hard Bot\", \"Custom Bot\", \"Matched player\")\n\nAn indication of whether the player is ready.\n\nInstructions for how that player should join the game If the player is \"You\", the player is automatically ready. If the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard. If the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready. If the player is \"Custom Bot\", the instructions include an access token for a custom bot. If the player is \"Matched player\", the instructions are to wait for someone to join.\n\nIf the player is \"You\", the player is automatically ready.\n\nIf the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard.\n\nIf the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready.\n\nIf the player is \"Custom Bot\", the instructions include an access token for a custom bot.\n\nIf the player is \"Matched player\", the instructions are to wait for someone to join.\n\nA button to abort the game and return to the previous page.\n\nIf a player joins a game but there are other players that are not ready (in the case of variants with more than 2 players), they will also see the matching stage panel.\n\nTab 7: Settings\n\nSettings have three sections:\n\nUser settings\n\nVisual style\n\nDefault game parameters\n\nFor sections 2 and 3, there should be an information box indicating that if the user is not logged in, they are saved as local cookies in the web browser. If they are logged in, the settings are saved to their account instead.\n\n1. User settings\n\nThis has one field:\n\nDisplay name (text field)\n\nIt behaves a bit differently depending on if the user is logged in.\n\nFor logged in users, the display name shows their current name and it is editable.\n\nThere should be a button next to the \"display name\" text field that says \"Change if available\" and an informational text that says \"Names must be unique across the site (case insensitive). You can only switch to another name not already in use.\" The button should be grayed out if the text field matches their current name. Names including \"guest\" or \"deleted\" or \"bot\" are not allowed. If the user tries to change to such a name, it should be explained to them.\n\nIf the user is not logged in, the display name should be grayed out and fixed as: \"Guest\"\n\nThere should also be an indication that the user needs to be logged in to change their display name, with a button to the Profile page.\n\n2. Visual style\n\nDark theme: on/off. Default: on\n\nBoard theme: selector. Default: \"classic\".\n\nPawn color: selector. Default: default.\n\nCat pawn: selector.\n\nMouse pawn: selector.\n\n... (one selector for each pawn type that appears in any variant)\n\nThe pawn selectors are between icons/small images.\n\n3. Default game parameters.\n\nThis is the game configuration panel component.\n\nA text says, \"When setting up a game, these parameters will be used as default.\"\n\nTab 6: About\n\nThis contains short informational text. The text can be something like this:\n\n\"Wall Game is a board game about building walls and outsmarting your opponents. It is inspired by Quoridor (wiki link) and Blockade (wiki link). Basic instructions about navigating the website (where to find the rules etc). Created by Nil Mamano (link). For more, you can read the blog (link).\"\n\nTab 8: Profile\n\nThis page looks different depending on whether the user is logged in or not.\n\nNot logged in\n\nThe tab appears as \"Login\".\n\nThe page shows two main buttons: log in and sign up\n\nIt includes a bit of text: \"Log in or sign up to choose a name, play rated games, and see your game history.\"\n\nFor the login and sign up flows, the user is redirected to an external auth service, so they are not part of this UI.\n\nThe tab appears as \"Profile\".\n\nIt shows the user display name and rating at the top, followed by a series of buttons grouped in two groups:\n\nPast Games: takes you to the Past Games tab but with the user's name already set as filter.\n\nRanking: takes you to the Ranking tab but with the user's name already set as filter.\n\nSettings: takes you to the settings page.\n\nDelete account\n\nThe delete account button shows a confirmation dialog: \"Your email will be deleted from the DB and all games you played will appear as 'Deleted User' and you won't be able to play again with this account. Are you sure?\"\n\nTab 3: Past games\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default. Filters are added as query parameters to the URL, so they can be shared.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nPlayer: text field (empty field acts as \"all\")\n\nPlayer: text field (empty field acts as \"all\").\n\nTime period: a date range\n\nThe two player fields serve the same purpose. Filling only one gives you all games with that player. Filling both gives you all games including both players.\n\nGames with fewer than 2 moves are filtered out. Games aborted during the \"matching stage\" are not even stored.\n\nThe rows are ordered by date. The order cannot be changed.\n\nWatch: a button which, when clicked, takes you to see the past game.\n\nVariant: clicking on a variant sets the variant filter.\n\nRated: yes/no. Clicking on a rating sets the rated status filter.\n\nTime control: a string formatted like \"blitz (3+2)\". Clicking on a time control sets the time control filter.\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height). Clicking on a board size sets the board size filter.\n\nPlayers: a string formatted like \"name1 (1200) vs name2 (1234)\". The numbers in parentheses are the ratings at the start of the game. Clicking on a name sets the first player filter. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (1200) & name2 (1234) vs name3 (1234) & name4 (1234)\". Clicking on the \"vs\" sets both player filters, with slight tweaks depending on the variant.\n\nMoves: a number. The number of moves of the game.\n\nViews: a number. The number of views the game got.\n\ndate: date type. When the game was played.\n\nThe name of the winning player is highlighted. Draws are also indicated.\n\nPast game view\n\nWhen a user clicks the \"Watch\" button for a past game, they are taken to the \"game page\" for that game (e.g., wallgame.io/game/2ei3nd43).\n\nThe final position is shown by default.\n\nThe chat is grayed out with a message that says \"Chat is not preserved.\"\n\nTab 4: Live games\n\nSimilar to the \"Past games\" page, this page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nThe formatting of the columns is the same as for \"Past Games\".\n\nWatch: a button that takes you to spectate the game in real time.\n\nViewers: a number.\n\nVariant: see \"Past games\" table.\n\nRated: see \"Past games\" table.\n\nTime control: see \"Past games\" table.\n\nBoard size: see \"Past games\" table.\n\nPlayers: see \"Past games\" table.\n\nMoves: see \"Past games\" table.\n\nThe rows are sorted by viewers first, by max ELO second.\n\nWhen a game ends, the number of spectators becomes the initial number of views in the past games table.\n\nLive game view\n\nWhen a user clicks the \"Watch\" button for a live game, they are taken to the \"game page\" for that game (e.g., wallgame.io/live/2ei3nd43).\n\nThe latest state of the game is shown by default.\n\nAs players make moves, spectators receive and see real-time updates.\n\nSpectators see the \"Spectator chat\", which is different than the ones the players see.\n\nTab 2: Ranking\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe filters do not have an \"all\" option.\n\nVariant: default: standard\n\nTime control: default: rapid\n\nPlayer: text field. Default: empty. The player filter acts more like a search box. If filled and the player exists, it only shows the row corresponding to that player and a few rows before and after. If the player does not exist, it shows nothing.\n\nRank: number starting at 1\n\nPlayer: the display name. It updates whenever players change their names delete their accounts.\n\nRating: the ELO rating. These are numbers sorted in decreasing order.\n\nPeak rating: the max ELO rating that player has ever had.\n\nRecord: a string formatted like \"10-4\" indicating the number of points the player got and lost across all its games.\n\nFirst game: a date.\n\nLast game: a date.\n\nClicking anywhere on a row takes you to the \"Past games\" page with the variant, time control, and player filters set. The \"rated\" filter is also set to \"yes\".\n\nTab 5: Learn\n\nThis page contains only static content, in four sections:\n\nRules (standard)\n\nNotation (standard)\n\nLessons (standard)\n\nAll the sections may contain images.\n\nSections can be collapsed.\n\nThis contains a couple of paragraphs explaining the rules of the \"standard\" variant.\n\nIt ends with: \"You can now start the solo campaign.\", with a link to the play tab (wallgame.io).\n\nThis contains a couple of paragraphs explaining the standard notation. This is useful since it appears in the game history element of the \"board view\" component.\n\nThis contains a bullet point list of links to blog posts explaining strategic and tactical ideas. More lessons can be added over time.\n\nThis contains definitions and special rules for all the supported variants.\n\nTab 1: Play\n\nThis is the 'landing' page.\n\nIts main purpose is to easily access the 6 game modes:\n\nSolo campaign\n\nStudy board\n\nPlay with others\n\nInvite friend\n\nIt contains three sections:\n\nSingle-player fun\n\nPlay with others\n\nGame showcase\n\nThe first two contain various buttons to go to the various game modes. The final one is just decorative. It's not there because it's related to the \"Play\" theme, but because it's the landing page.\n\nSingle-player fun\n\nThis section contains the following buttons:\n\nSolo campaign. There is an annotation that says \"Start here!\"\n\nStudy board\n\nPlay with others\n\nThis section contains the following buttons:\n\nFind others\n\nInvite friend\n\nGame showcase\n\nThis section shows a board and autoplays random past games, at high speed (2 moves per second). Above the board, a text says: \"Game showcase: name1 (1200) vs name2 (1234) (DATE)\", with the players and date updating as the game changes. There should also be a button to stop the autoplay.\n\nClicking on it takes you to the \"game page\" to watch the game, analogous to the \"Past games\" page. The only difference is that the game starts at the position that last played automatically in the game showcase.\n\nGame mode 2: Puzzles\n\nThe URL is wallgame.io/puzzles\n\nThe puzzles page has a list of puzzles.\n\nEach puzzle has:\n\nplay button\n\ndifficulty rating\n\ncompleted: yes/no. An indication of whether the user already solved it\n\nIf the user is not logged in, the 'completed' status is grayed out. There should be an information box indicating that the user should log in to save their completion status.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/puzzles/1, where 1 is the puzzle number. This makes it so that the user can share a puzzle by sharing the route.\n\nGame mode 1: Solo campaign\n\nThe URL is wallgame.io/solo-campaign\n\nThe solo campaign menu consists of a list of puzzles just like the menu for puzzles.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/solo-campaign/1, where 1 is the puzzle number.\n\nUnlike in normal puzzles, in solo campaign puzzles:\n\nThere is a text above the board view indicating what to do to win.\n\nThe game is usually played until the end.\n\nGame mode 3: Play vs AI\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Easy Bot\".\n\nGame mode 5: Play with others\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Matched user\".\n\nGame mode 6: Invite friend\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Friend\".\n\nGame mode 4: Study board\n\nThis takes you to a special instance of the \"game page\" with route wallgame.io/study-board.\n\nThe design for the study board page is work in progress.\n\nFinal thoughts\n\nI usually figure out the shape of things as I build them, like I did for wallwars.net, instead of writing a long design doc upfront. However:\n\nTo justify a full rewrite, I wanted to make sure the new design would accomplish the improvements that I wanted to see on the original site (see the list at the beginning of this post).\n\nAI-assisted coding has made all coding easier, but it has improved new code generation more than it has improved refactoring. For me, this shifted the tradeoff to the point where it seemed worth it to try to preempt as many direction shifts as possible.\n\nIn any case, now that I have this doc, I think it's a good opportunity to test out the various frontend generators (lovable and company) and see what they spit out. I probably won't use any of them directly, but they should give me good ideas for the styling.\n\nI fed this whole blog post to v0.dev (free tier). The prompt was \"Create mocks for the attached design doc.\" + this blog post, which is about 6000 words (a 33kB attachment).\n\nApart from putting the files in the wrong directory, it one-shotted the whole app with great prompt adherence and, in my opinion, great taste to fill in the gaps (recall that this design doc says basically nothing about styling).\n\nYou can see the results below (I skipped the less interesting pages).\n\nI emphasize that I did not have to break down the prompt into smaller chunks, as I'm so used to with tools like Cursor or basically anything LLM-based. I did not have to go screen by screen. It generated about 20 files and 3000 lines of next.js, with all navigation working as expected and mock data. I did not have to carefully craft a prompt on top of the design doc (though you can argue that this blog post is a great prompt). As someone who uses vibe coding regularly, this truly impressed me.\n\nI tried other frontend generators with the same prompt. lovable.dev did OK with prompt adherence (some pages did not work), but it did not have the same taste as v0.dev. It looks like a generic corporate site. Lovable's board component also looks messed up.\n\nbolt.new had great prompt adherence, about the same as v0.dev, but the site looked generic like lovable's (and the board was also messed up). V0 had the best use of space.\n\nOther tools I tried had a prompt length limit, so I didn't bother.\n\nIn the end, I just went back to v0.dev and used the rest of my daily free credits to ask it for different color themes.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-ui#concepts",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game UI Design (+ Frontend Generators)",
      "content": "Wall Game UI Design (+ Frontend Generators)\n\nThis blog post is a design doc for the frontend of wallgame.io, a board game I'm making. However, something probably more interesting came out of it: an assessment of frontend generators' ability to one-shot a 6000-word design doc prompt. The results deeply impressed me. They are in an appendix at the bottom. Feel free to skip the design doc and check out the appendix.\n\nThis is the specification of the frontend for the Wall Game, an online strategy board game. It only specifies the logic/functionality. It is agnostic of the look.\n\nA first version of the game is already available at wallwars.net. This is a UI overhaul with the following goals:\n\nA smooth onboarding experience. It should be very clear how to navigate the site and in what order to do things.\n\nTeaching the game to new players in a structured way.\n\nExpansive solo modes so that players can have fun even if there is no one else online.\n\nImproving the user journey of inviting friends to play.\n\nSupporting game variants as a first-class feature (this was a key feature for replayability when playing with a physical board).\n\nSupporting game variants with a varying number of players.\n\nSupporting multiple bots, including custom bots to foster the \"engine dev\" community.\n\nClean interface to game data, like past games, player history, rankings, etc., by showing interlinked tables with SQL-like features like filtering.\n\nMore \"social\" features, like an in-game chat and the ability to watch live games.\n\nFrontend Overview\n\nThe site is a SPA (single page app). There are 9 main pages, all of which are accessible from the top navigation bar. If a screen is not wide enough to show all the tabs, they are collapsed as necessary into a hamburger menu icon. Tabs act as buttons to show the corresponding page. Pages are self-contained and have their own URL:\n\nIn order, the tabs are:\n\nPlay (default) - wallgame.io\n\nRanking - wallgame.io/ranking\n\nPast games - wallgame.io/past-games\n\nLive games - wallgame.io/live-games\n\nLearn - wallgame.io/learn\n\nAbout - wallgame.io/about\n\nSettings - wallgame.io/settings\n\nProfile (appears as Login if the user is not logged in) - wallgame.io/profile\n\nThe navigation bar is always visible, and the current tab is highlighted.\n\nWe'll first go over the basic concepts, then some of the basic components reused across multiple pages, and finally, we'll go over each page (out of order).\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nPlayer types: there are 5 player types in the context of a game created by a user: \"You\": the user itself. \"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.) \"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\"). \"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game. \"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nPlayer types: there are 5 player types in the context of a game created by a user:\n\n\"You\": the user itself.\n\n\"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.)\n\n\"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\").\n\n\"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game.\n\n\"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter): The user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win). The user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully. The user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter):\n\nThe user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win).\n\nThe user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully.\n\nThe user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nThis section describes specific high-level components of the UI, which are reused in various places.\n\nThis is the main component involved in playing the game.\n\nA rectangular grid of square cells, with thick margins between them (that's where the walls go).\n\nA cell may contain one or more pawns. There is no limit on how many pawns can be in the same cell.\n\nA staged or premoved pawn move is shown with an arrow. Arbitrary arrows can also be added as calculations. It should be clear which one is which.\n\nBetween every two cells adjacent vertically or horizontally, there is a space where a wall can be placed, staged, premoved, calculated, or missing.\n\nThe corner between four cells is called a \"pillar\" and is not an interactable element.\n\nPlaced walls are colored according to the color of the pawns of the player who placed them.\n\nSimilar to chess and checkers, the cells are colored alternatively, so that cells that are an even number of moves away from each other share a color. The contrast between the two colors is subtle.\n\nLike chess, rows are labeled with numbers (starting from 1 on the top) and columns are labeled with letters (starting from 'a' on the left). The first cell in each row is labeled with the corresponding row number. The first cell in each column is labeled with the corresponding column letter. The labels are subtle, taking only a corner of the cell.\n\nThe last move is highlighted so it is easy for players to see what the opponent just did.\n\nThis includes the board itself and surrounding elements for any related information and interactions:\n\nthe timers. The timer of the player to move is highlighted.\n\nthe player names and ELOs. The name of the player to move is highlighted.\n\nthe move history in standard notation, with buttons to go back and forth and buttons to go to the beginning and latest move.\n\nthe chat. The chat can have multiple \"channels\": the \"game chat\", seen by all the players but not the audience the \"team chat\", seen only by players on the same team the \"audience chat\", seen only by the audience\n\nthe \"game chat\", seen by all the players but not the audience\n\nthe \"team chat\", seen only by players on the same team\n\nthe \"audience chat\", seen only by the audience\n\nan indicator of whose turn it is\n\nonline indicators for each player (if a player does not have the game tab/app active, it shows as offline)\n\nmenus for out-of-game interactions: \"resign\", \"offer draw\", \"propose take back\", \"give time (1 min)\", \"rematch\"\n\na button to toggle sounds\n\ncontextual information: the game variant and parameters the time control rated status the match score whose turn it is the player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\") after the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\nthe game variant and parameters\n\nthe time control\n\nrated status\n\nthe match score\n\nwhose turn it is\n\nthe player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\")\n\nafter the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\na button to see/copy the game's replay notation and standard notation\n\nGame configuration panel\n\nThis includes all the configuration options for a game.\n\ntime control: a selector with the options \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\".\n\nrated status: yes/no. If the player is not logged in, the 'rated status' is set to \"no\" and grayed out. There should be an informational text that says that the user needs to be logged in to play rated games.\n\nvariant: a selector of supported variants.\n\nadditional parameters that depend on the variant. These parameters appear in a container, and the container changes depending on the variant.\n\nFor example, for the standard variant:\n\nBoard width: number. Default: 8\n\nBoard height: number. Default: 8\n\nPlayer configuration\n\nA little component that lets you configure how a player in a game will move. It consists of a selector with a few options, each of which has an informational text.\n\n\"You\": \"You'll make the moves.\"\n\n\"Friend\": \"You'll get a link to share with a friend to join the game.\"\n\n\"Matched user\": \"You'll be paired with a random player with compatible settings and similar rating.\"\n\n\"Easy Bot\": \"You'll play against an easy AI bot.\"\n\n\"Medium Bot\": \"You'll play against a medium AI bot.\"\n\n\"Hard Bot\": \"You'll play against a hard AI bot.\"\n\n\"Custom bot\": \"You'll get an access token so that you can connect your own bot. See here for more information.\" The text links to a blog post explaining how to make a custom bot and connect it to the game using the token.\n\nThere is no default. It depends on the context.\n\nGame setup page\n\nThis page has its own URL: wallgame.io/game-setup.\n\nIt has two sections:\n\nCreate game\n\nCreate game\n\nThis part has the following elements:\n\nA button: \"Create game\".\n\nA player configuration component for each player (which depends on the variant, as set in #4). The selectors are labeled \"Player 1\", \"Player 2\", and so on. The default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe selectors are labeled \"Player 1\", \"Player 2\", and so on.\n\nThe default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe game configuration panel. Choosing a variant with more than 2 players will affect the number of player configuration components in #2.\n\nThis part has the following elements:\n\nA heading \"Join game\"\n\nA table showing games from other players that are in the \"matching stage\" and waiting for someone to join.\n\nThe table has the following columns:\n\nJoin: a button which, when clicked, joins the game.\n\nRated: yes/no.\n\nTime control: a string formatted like \"blitz (3+2)\"\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height).\n\nPlayer: a string formatted like \"name1 (1200)\". The numbers in parentheses is the rating. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (XXX) & name2 (YYY) vs name3 (ZZZ)\".\n\nThe rows are ordered by ELO closest to the current user's ELO. If the user chose a variant, rated status, time control, or board size in the game configuration panel, rows matching those settings are prioritized. Games that have been in \"matching stage\" for longer are also prioritized.\n\nThe parameterized URL is wallgame.io/game/game-id\n\nThe game page shows a game, identified with a given game ID in the URL. The game could be in the \"matching stage\", ongoing, or finished (a past game) The URL can be shared to join the game (if it is in the \"matching stage\"), to spectate it live (if it is ongoing) or watch it as a past game (if it is finished).\n\nThe game page has one main component: the board view.\n\nDepending on the context, it could contain other elements. See, e.g., the case of the \"Solo campaign\" puzzles, which contain an additional explanation text. So far, this seems to be the only exception.\n\nMatching stage panel\n\nWhen a user creates a game from wallgame.io/game-setup, a game ID is generated and they are taken to the game page with that game ID.\n\nHowever, it is possible that not all players are ready. For instance, if one of the player types is \"friend\", the game cannot start until the friend joins the game.\n\nIf not all players are ready, a \"matching stage\" panel component is shown as a modal over a faded out version of the game page.\n\nThe modal has a title: \"Waiting for players\". It contains one row for each player. Each row contains:\n\nThe player type (e.g., \"You\", \"Friend\", \"Easy Bot\", \"Medium Bot\", \"Hard Bot\", \"Custom Bot\", \"Matched player\")\n\nAn indication of whether the player is ready.\n\nInstructions for how that player should join the game If the player is \"You\", the player is automatically ready. If the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard. If the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready. If the player is \"Custom Bot\", the instructions include an access token for a custom bot. If the player is \"Matched player\", the instructions are to wait for someone to join.\n\nIf the player is \"You\", the player is automatically ready.\n\nIf the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard.\n\nIf the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready.\n\nIf the player is \"Custom Bot\", the instructions include an access token for a custom bot.\n\nIf the player is \"Matched player\", the instructions are to wait for someone to join.\n\nA button to abort the game and return to the previous page.\n\nIf a player joins a game but there are other players that are not ready (in the case of variants with more than 2 players), they will also see the matching stage panel.\n\nTab 7: Settings\n\nSettings have three sections:\n\nUser settings\n\nVisual style\n\nDefault game parameters\n\nFor sections 2 and 3, there should be an information box indicating that if the user is not logged in, they are saved as local cookies in the web browser. If they are logged in, the settings are saved to their account instead.\n\n1. User settings\n\nThis has one field:\n\nDisplay name (text field)\n\nIt behaves a bit differently depending on if the user is logged in.\n\nFor logged in users, the display name shows their current name and it is editable.\n\nThere should be a button next to the \"display name\" text field that says \"Change if available\" and an informational text that says \"Names must be unique across the site (case insensitive). You can only switch to another name not already in use.\" The button should be grayed out if the text field matches their current name. Names including \"guest\" or \"deleted\" or \"bot\" are not allowed. If the user tries to change to such a name, it should be explained to them.\n\nIf the user is not logged in, the display name should be grayed out and fixed as: \"Guest\"\n\nThere should also be an indication that the user needs to be logged in to change their display name, with a button to the Profile page.\n\n2. Visual style\n\nDark theme: on/off. Default: on\n\nBoard theme: selector. Default: \"classic\".\n\nPawn color: selector. Default: default.\n\nCat pawn: selector.\n\nMouse pawn: selector.\n\n... (one selector for each pawn type that appears in any variant)\n\nThe pawn selectors are between icons/small images.\n\n3. Default game parameters.\n\nThis is the game configuration panel component.\n\nA text says, \"When setting up a game, these parameters will be used as default.\"\n\nTab 6: About\n\nThis contains short informational text. The text can be something like this:\n\n\"Wall Game is a board game about building walls and outsmarting your opponents. It is inspired by Quoridor (wiki link) and Blockade (wiki link). Basic instructions about navigating the website (where to find the rules etc). Created by Nil Mamano (link). For more, you can read the blog (link).\"\n\nTab 8: Profile\n\nThis page looks different depending on whether the user is logged in or not.\n\nNot logged in\n\nThe tab appears as \"Login\".\n\nThe page shows two main buttons: log in and sign up\n\nIt includes a bit of text: \"Log in or sign up to choose a name, play rated games, and see your game history.\"\n\nFor the login and sign up flows, the user is redirected to an external auth service, so they are not part of this UI.\n\nThe tab appears as \"Profile\".\n\nIt shows the user display name and rating at the top, followed by a series of buttons grouped in two groups:\n\nPast Games: takes you to the Past Games tab but with the user's name already set as filter.\n\nRanking: takes you to the Ranking tab but with the user's name already set as filter.\n\nSettings: takes you to the settings page.\n\nDelete account\n\nThe delete account button shows a confirmation dialog: \"Your email will be deleted from the DB and all games you played will appear as 'Deleted User' and you won't be able to play again with this account. Are you sure?\"\n\nTab 3: Past games\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default. Filters are added as query parameters to the URL, so they can be shared.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nPlayer: text field (empty field acts as \"all\")\n\nPlayer: text field (empty field acts as \"all\").\n\nTime period: a date range\n\nThe two player fields serve the same purpose. Filling only one gives you all games with that player. Filling both gives you all games including both players.\n\nGames with fewer than 2 moves are filtered out. Games aborted during the \"matching stage\" are not even stored.\n\nThe rows are ordered by date. The order cannot be changed.\n\nWatch: a button which, when clicked, takes you to see the past game.\n\nVariant: clicking on a variant sets the variant filter.\n\nRated: yes/no. Clicking on a rating sets the rated status filter.\n\nTime control: a string formatted like \"blitz (3+2)\". Clicking on a time control sets the time control filter.\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height). Clicking on a board size sets the board size filter.\n\nPlayers: a string formatted like \"name1 (1200) vs name2 (1234)\". The numbers in parentheses are the ratings at the start of the game. Clicking on a name sets the first player filter. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (1200) & name2 (1234) vs name3 (1234) & name4 (1234)\". Clicking on the \"vs\" sets both player filters, with slight tweaks depending on the variant.\n\nMoves: a number. The number of moves of the game.\n\nViews: a number. The number of views the game got.\n\ndate: date type. When the game was played.\n\nThe name of the winning player is highlighted. Draws are also indicated.\n\nPast game view\n\nWhen a user clicks the \"Watch\" button for a past game, they are taken to the \"game page\" for that game (e.g., wallgame.io/game/2ei3nd43).\n\nThe final position is shown by default.\n\nThe chat is grayed out with a message that says \"Chat is not preserved.\"\n\nTab 4: Live games\n\nSimilar to the \"Past games\" page, this page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nThe formatting of the columns is the same as for \"Past Games\".\n\nWatch: a button that takes you to spectate the game in real time.\n\nViewers: a number.\n\nVariant: see \"Past games\" table.\n\nRated: see \"Past games\" table.\n\nTime control: see \"Past games\" table.\n\nBoard size: see \"Past games\" table.\n\nPlayers: see \"Past games\" table.\n\nMoves: see \"Past games\" table.\n\nThe rows are sorted by viewers first, by max ELO second.\n\nWhen a game ends, the number of spectators becomes the initial number of views in the past games table.\n\nLive game view\n\nWhen a user clicks the \"Watch\" button for a live game, they are taken to the \"game page\" for that game (e.g., wallgame.io/live/2ei3nd43).\n\nThe latest state of the game is shown by default.\n\nAs players make moves, spectators receive and see real-time updates.\n\nSpectators see the \"Spectator chat\", which is different than the ones the players see.\n\nTab 2: Ranking\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe filters do not have an \"all\" option.\n\nVariant: default: standard\n\nTime control: default: rapid\n\nPlayer: text field. Default: empty. The player filter acts more like a search box. If filled and the player exists, it only shows the row corresponding to that player and a few rows before and after. If the player does not exist, it shows nothing.\n\nRank: number starting at 1\n\nPlayer: the display name. It updates whenever players change their names delete their accounts.\n\nRating: the ELO rating. These are numbers sorted in decreasing order.\n\nPeak rating: the max ELO rating that player has ever had.\n\nRecord: a string formatted like \"10-4\" indicating the number of points the player got and lost across all its games.\n\nFirst game: a date.\n\nLast game: a date.\n\nClicking anywhere on a row takes you to the \"Past games\" page with the variant, time control, and player filters set. The \"rated\" filter is also set to \"yes\".\n\nTab 5: Learn\n\nThis page contains only static content, in four sections:\n\nRules (standard)\n\nNotation (standard)\n\nLessons (standard)\n\nAll the sections may contain images.\n\nSections can be collapsed.\n\nThis contains a couple of paragraphs explaining the rules of the \"standard\" variant.\n\nIt ends with: \"You can now start the solo campaign.\", with a link to the play tab (wallgame.io).\n\nThis contains a couple of paragraphs explaining the standard notation. This is useful since it appears in the game history element of the \"board view\" component.\n\nThis contains a bullet point list of links to blog posts explaining strategic and tactical ideas. More lessons can be added over time.\n\nThis contains definitions and special rules for all the supported variants.\n\nTab 1: Play\n\nThis is the 'landing' page.\n\nIts main purpose is to easily access the 6 game modes:\n\nSolo campaign\n\nStudy board\n\nPlay with others\n\nInvite friend\n\nIt contains three sections:\n\nSingle-player fun\n\nPlay with others\n\nGame showcase\n\nThe first two contain various buttons to go to the various game modes. The final one is just decorative. It's not there because it's related to the \"Play\" theme, but because it's the landing page.\n\nSingle-player fun\n\nThis section contains the following buttons:\n\nSolo campaign. There is an annotation that says \"Start here!\"\n\nStudy board\n\nPlay with others\n\nThis section contains the following buttons:\n\nFind others\n\nInvite friend\n\nGame showcase\n\nThis section shows a board and autoplays random past games, at high speed (2 moves per second). Above the board, a text says: \"Game showcase: name1 (1200) vs name2 (1234) (DATE)\", with the players and date updating as the game changes. There should also be a button to stop the autoplay.\n\nClicking on it takes you to the \"game page\" to watch the game, analogous to the \"Past games\" page. The only difference is that the game starts at the position that last played automatically in the game showcase.\n\nGame mode 2: Puzzles\n\nThe URL is wallgame.io/puzzles\n\nThe puzzles page has a list of puzzles.\n\nEach puzzle has:\n\nplay button\n\ndifficulty rating\n\ncompleted: yes/no. An indication of whether the user already solved it\n\nIf the user is not logged in, the 'completed' status is grayed out. There should be an information box indicating that the user should log in to save their completion status.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/puzzles/1, where 1 is the puzzle number. This makes it so that the user can share a puzzle by sharing the route.\n\nGame mode 1: Solo campaign\n\nThe URL is wallgame.io/solo-campaign\n\nThe solo campaign menu consists of a list of puzzles just like the menu for puzzles.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/solo-campaign/1, where 1 is the puzzle number.\n\nUnlike in normal puzzles, in solo campaign puzzles:\n\nThere is a text above the board view indicating what to do to win.\n\nThe game is usually played until the end.\n\nGame mode 3: Play vs AI\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Easy Bot\".\n\nGame mode 5: Play with others\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Matched user\".\n\nGame mode 6: Invite friend\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Friend\".\n\nGame mode 4: Study board\n\nThis takes you to a special instance of the \"game page\" with route wallgame.io/study-board.\n\nThe design for the study board page is work in progress.\n\nFinal thoughts\n\nI usually figure out the shape of things as I build them, like I did for wallwars.net, instead of writing a long design doc upfront. However:\n\nTo justify a full rewrite, I wanted to make sure the new design would accomplish the improvements that I wanted to see on the original site (see the list at the beginning of this post).\n\nAI-assisted coding has made all coding easier, but it has improved new code generation more than it has improved refactoring. For me, this shifted the tradeoff to the point where it seemed worth it to try to preempt as many direction shifts as possible.\n\nIn any case, now that I have this doc, I think it's a good opportunity to test out the various frontend generators (lovable and company) and see what they spit out. I probably won't use any of them directly, but they should give me good ideas for the styling.\n\nI fed this whole blog post to v0.dev (free tier). The prompt was \"Create mocks for the attached design doc.\" + this blog post, which is about 6000 words (a 33kB attachment).\n\nApart from putting the files in the wrong directory, it one-shotted the whole app with great prompt adherence and, in my opinion, great taste to fill in the gaps (recall that this design doc says basically nothing about styling).\n\nYou can see the results below (I skipped the less interesting pages).\n\nI emphasize that I did not have to break down the prompt into smaller chunks, as I'm so used to with tools like Cursor or basically anything LLM-based. I did not have to go screen by screen. It generated about 20 files and 3000 lines of next.js, with all navigation working as expected and mock data. I did not have to carefully craft a prompt on top of the design doc (though you can argue that this blog post is a great prompt). As someone who uses vibe coding regularly, this truly impressed me.\n\nI tried other frontend generators with the same prompt. lovable.dev did OK with prompt adherence (some pages did not work), but it did not have the same taste as v0.dev. It looks like a generic corporate site. Lovable's board component also looks messed up.\n\nbolt.new had great prompt adherence, about the same as v0.dev, but the site looked generic like lovable's (and the board was also messed up). V0 had the best use of space.\n\nOther tools I tried had a prompt length limit, so I didn't bother.\n\nIn the end, I just went back to v0.dev and used the rest of my daily free credits to ask it for different color themes.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-ui#components",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game UI Design (+ Frontend Generators)",
      "content": "Wall Game UI Design (+ Frontend Generators)\n\nThis blog post is a design doc for the frontend of wallgame.io, a board game I'm making. However, something probably more interesting came out of it: an assessment of frontend generators' ability to one-shot a 6000-word design doc prompt. The results deeply impressed me. They are in an appendix at the bottom. Feel free to skip the design doc and check out the appendix.\n\nThis is the specification of the frontend for the Wall Game, an online strategy board game. It only specifies the logic/functionality. It is agnostic of the look.\n\nA first version of the game is already available at wallwars.net. This is a UI overhaul with the following goals:\n\nA smooth onboarding experience. It should be very clear how to navigate the site and in what order to do things.\n\nTeaching the game to new players in a structured way.\n\nExpansive solo modes so that players can have fun even if there is no one else online.\n\nImproving the user journey of inviting friends to play.\n\nSupporting game variants as a first-class feature (this was a key feature for replayability when playing with a physical board).\n\nSupporting game variants with a varying number of players.\n\nSupporting multiple bots, including custom bots to foster the \"engine dev\" community.\n\nClean interface to game data, like past games, player history, rankings, etc., by showing interlinked tables with SQL-like features like filtering.\n\nMore \"social\" features, like an in-game chat and the ability to watch live games.\n\nFrontend Overview\n\nThe site is a SPA (single page app). There are 9 main pages, all of which are accessible from the top navigation bar. If a screen is not wide enough to show all the tabs, they are collapsed as necessary into a hamburger menu icon. Tabs act as buttons to show the corresponding page. Pages are self-contained and have their own URL:\n\nIn order, the tabs are:\n\nPlay (default) - wallgame.io\n\nRanking - wallgame.io/ranking\n\nPast games - wallgame.io/past-games\n\nLive games - wallgame.io/live-games\n\nLearn - wallgame.io/learn\n\nAbout - wallgame.io/about\n\nSettings - wallgame.io/settings\n\nProfile (appears as Login if the user is not logged in) - wallgame.io/profile\n\nThe navigation bar is always visible, and the current tab is highlighted.\n\nWe'll first go over the basic concepts, then some of the basic components reused across multiple pages, and finally, we'll go over each page (out of order).\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nPlayer types: there are 5 player types in the context of a game created by a user: \"You\": the user itself. \"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.) \"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\"). \"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game. \"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nPlayer types: there are 5 player types in the context of a game created by a user:\n\n\"You\": the user itself.\n\n\"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.)\n\n\"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\").\n\n\"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game.\n\n\"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter): The user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win). The user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully. The user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter):\n\nThe user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win).\n\nThe user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully.\n\nThe user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nThis section describes specific high-level components of the UI, which are reused in various places.\n\nThis is the main component involved in playing the game.\n\nA rectangular grid of square cells, with thick margins between them (that's where the walls go).\n\nA cell may contain one or more pawns. There is no limit on how many pawns can be in the same cell.\n\nA staged or premoved pawn move is shown with an arrow. Arbitrary arrows can also be added as calculations. It should be clear which one is which.\n\nBetween every two cells adjacent vertically or horizontally, there is a space where a wall can be placed, staged, premoved, calculated, or missing.\n\nThe corner between four cells is called a \"pillar\" and is not an interactable element.\n\nPlaced walls are colored according to the color of the pawns of the player who placed them.\n\nSimilar to chess and checkers, the cells are colored alternatively, so that cells that are an even number of moves away from each other share a color. The contrast between the two colors is subtle.\n\nLike chess, rows are labeled with numbers (starting from 1 on the top) and columns are labeled with letters (starting from 'a' on the left). The first cell in each row is labeled with the corresponding row number. The first cell in each column is labeled with the corresponding column letter. The labels are subtle, taking only a corner of the cell.\n\nThe last move is highlighted so it is easy for players to see what the opponent just did.\n\nThis includes the board itself and surrounding elements for any related information and interactions:\n\nthe timers. The timer of the player to move is highlighted.\n\nthe player names and ELOs. The name of the player to move is highlighted.\n\nthe move history in standard notation, with buttons to go back and forth and buttons to go to the beginning and latest move.\n\nthe chat. The chat can have multiple \"channels\": the \"game chat\", seen by all the players but not the audience the \"team chat\", seen only by players on the same team the \"audience chat\", seen only by the audience\n\nthe \"game chat\", seen by all the players but not the audience\n\nthe \"team chat\", seen only by players on the same team\n\nthe \"audience chat\", seen only by the audience\n\nan indicator of whose turn it is\n\nonline indicators for each player (if a player does not have the game tab/app active, it shows as offline)\n\nmenus for out-of-game interactions: \"resign\", \"offer draw\", \"propose take back\", \"give time (1 min)\", \"rematch\"\n\na button to toggle sounds\n\ncontextual information: the game variant and parameters the time control rated status the match score whose turn it is the player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\") after the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\nthe game variant and parameters\n\nthe time control\n\nrated status\n\nthe match score\n\nwhose turn it is\n\nthe player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\")\n\nafter the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\na button to see/copy the game's replay notation and standard notation\n\nGame configuration panel\n\nThis includes all the configuration options for a game.\n\ntime control: a selector with the options \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\".\n\nrated status: yes/no. If the player is not logged in, the 'rated status' is set to \"no\" and grayed out. There should be an informational text that says that the user needs to be logged in to play rated games.\n\nvariant: a selector of supported variants.\n\nadditional parameters that depend on the variant. These parameters appear in a container, and the container changes depending on the variant.\n\nFor example, for the standard variant:\n\nBoard width: number. Default: 8\n\nBoard height: number. Default: 8\n\nPlayer configuration\n\nA little component that lets you configure how a player in a game will move. It consists of a selector with a few options, each of which has an informational text.\n\n\"You\": \"You'll make the moves.\"\n\n\"Friend\": \"You'll get a link to share with a friend to join the game.\"\n\n\"Matched user\": \"You'll be paired with a random player with compatible settings and similar rating.\"\n\n\"Easy Bot\": \"You'll play against an easy AI bot.\"\n\n\"Medium Bot\": \"You'll play against a medium AI bot.\"\n\n\"Hard Bot\": \"You'll play against a hard AI bot.\"\n\n\"Custom bot\": \"You'll get an access token so that you can connect your own bot. See here for more information.\" The text links to a blog post explaining how to make a custom bot and connect it to the game using the token.\n\nThere is no default. It depends on the context.\n\nGame setup page\n\nThis page has its own URL: wallgame.io/game-setup.\n\nIt has two sections:\n\nCreate game\n\nCreate game\n\nThis part has the following elements:\n\nA button: \"Create game\".\n\nA player configuration component for each player (which depends on the variant, as set in #4). The selectors are labeled \"Player 1\", \"Player 2\", and so on. The default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe selectors are labeled \"Player 1\", \"Player 2\", and so on.\n\nThe default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe game configuration panel. Choosing a variant with more than 2 players will affect the number of player configuration components in #2.\n\nThis part has the following elements:\n\nA heading \"Join game\"\n\nA table showing games from other players that are in the \"matching stage\" and waiting for someone to join.\n\nThe table has the following columns:\n\nJoin: a button which, when clicked, joins the game.\n\nRated: yes/no.\n\nTime control: a string formatted like \"blitz (3+2)\"\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height).\n\nPlayer: a string formatted like \"name1 (1200)\". The numbers in parentheses is the rating. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (XXX) & name2 (YYY) vs name3 (ZZZ)\".\n\nThe rows are ordered by ELO closest to the current user's ELO. If the user chose a variant, rated status, time control, or board size in the game configuration panel, rows matching those settings are prioritized. Games that have been in \"matching stage\" for longer are also prioritized.\n\nThe parameterized URL is wallgame.io/game/game-id\n\nThe game page shows a game, identified with a given game ID in the URL. The game could be in the \"matching stage\", ongoing, or finished (a past game) The URL can be shared to join the game (if it is in the \"matching stage\"), to spectate it live (if it is ongoing) or watch it as a past game (if it is finished).\n\nThe game page has one main component: the board view.\n\nDepending on the context, it could contain other elements. See, e.g., the case of the \"Solo campaign\" puzzles, which contain an additional explanation text. So far, this seems to be the only exception.\n\nMatching stage panel\n\nWhen a user creates a game from wallgame.io/game-setup, a game ID is generated and they are taken to the game page with that game ID.\n\nHowever, it is possible that not all players are ready. For instance, if one of the player types is \"friend\", the game cannot start until the friend joins the game.\n\nIf not all players are ready, a \"matching stage\" panel component is shown as a modal over a faded out version of the game page.\n\nThe modal has a title: \"Waiting for players\". It contains one row for each player. Each row contains:\n\nThe player type (e.g., \"You\", \"Friend\", \"Easy Bot\", \"Medium Bot\", \"Hard Bot\", \"Custom Bot\", \"Matched player\")\n\nAn indication of whether the player is ready.\n\nInstructions for how that player should join the game If the player is \"You\", the player is automatically ready. If the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard. If the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready. If the player is \"Custom Bot\", the instructions include an access token for a custom bot. If the player is \"Matched player\", the instructions are to wait for someone to join.\n\nIf the player is \"You\", the player is automatically ready.\n\nIf the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard.\n\nIf the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready.\n\nIf the player is \"Custom Bot\", the instructions include an access token for a custom bot.\n\nIf the player is \"Matched player\", the instructions are to wait for someone to join.\n\nA button to abort the game and return to the previous page.\n\nIf a player joins a game but there are other players that are not ready (in the case of variants with more than 2 players), they will also see the matching stage panel.\n\nTab 7: Settings\n\nSettings have three sections:\n\nUser settings\n\nVisual style\n\nDefault game parameters\n\nFor sections 2 and 3, there should be an information box indicating that if the user is not logged in, they are saved as local cookies in the web browser. If they are logged in, the settings are saved to their account instead.\n\n1. User settings\n\nThis has one field:\n\nDisplay name (text field)\n\nIt behaves a bit differently depending on if the user is logged in.\n\nFor logged in users, the display name shows their current name and it is editable.\n\nThere should be a button next to the \"display name\" text field that says \"Change if available\" and an informational text that says \"Names must be unique across the site (case insensitive). You can only switch to another name not already in use.\" The button should be grayed out if the text field matches their current name. Names including \"guest\" or \"deleted\" or \"bot\" are not allowed. If the user tries to change to such a name, it should be explained to them.\n\nIf the user is not logged in, the display name should be grayed out and fixed as: \"Guest\"\n\nThere should also be an indication that the user needs to be logged in to change their display name, with a button to the Profile page.\n\n2. Visual style\n\nDark theme: on/off. Default: on\n\nBoard theme: selector. Default: \"classic\".\n\nPawn color: selector. Default: default.\n\nCat pawn: selector.\n\nMouse pawn: selector.\n\n... (one selector for each pawn type that appears in any variant)\n\nThe pawn selectors are between icons/small images.\n\n3. Default game parameters.\n\nThis is the game configuration panel component.\n\nA text says, \"When setting up a game, these parameters will be used as default.\"\n\nTab 6: About\n\nThis contains short informational text. The text can be something like this:\n\n\"Wall Game is a board game about building walls and outsmarting your opponents. It is inspired by Quoridor (wiki link) and Blockade (wiki link). Basic instructions about navigating the website (where to find the rules etc). Created by Nil Mamano (link). For more, you can read the blog (link).\"\n\nTab 8: Profile\n\nThis page looks different depending on whether the user is logged in or not.\n\nNot logged in\n\nThe tab appears as \"Login\".\n\nThe page shows two main buttons: log in and sign up\n\nIt includes a bit of text: \"Log in or sign up to choose a name, play rated games, and see your game history.\"\n\nFor the login and sign up flows, the user is redirected to an external auth service, so they are not part of this UI.\n\nThe tab appears as \"Profile\".\n\nIt shows the user display name and rating at the top, followed by a series of buttons grouped in two groups:\n\nPast Games: takes you to the Past Games tab but with the user's name already set as filter.\n\nRanking: takes you to the Ranking tab but with the user's name already set as filter.\n\nSettings: takes you to the settings page.\n\nDelete account\n\nThe delete account button shows a confirmation dialog: \"Your email will be deleted from the DB and all games you played will appear as 'Deleted User' and you won't be able to play again with this account. Are you sure?\"\n\nTab 3: Past games\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default. Filters are added as query parameters to the URL, so they can be shared.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nPlayer: text field (empty field acts as \"all\")\n\nPlayer: text field (empty field acts as \"all\").\n\nTime period: a date range\n\nThe two player fields serve the same purpose. Filling only one gives you all games with that player. Filling both gives you all games including both players.\n\nGames with fewer than 2 moves are filtered out. Games aborted during the \"matching stage\" are not even stored.\n\nThe rows are ordered by date. The order cannot be changed.\n\nWatch: a button which, when clicked, takes you to see the past game.\n\nVariant: clicking on a variant sets the variant filter.\n\nRated: yes/no. Clicking on a rating sets the rated status filter.\n\nTime control: a string formatted like \"blitz (3+2)\". Clicking on a time control sets the time control filter.\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height). Clicking on a board size sets the board size filter.\n\nPlayers: a string formatted like \"name1 (1200) vs name2 (1234)\". The numbers in parentheses are the ratings at the start of the game. Clicking on a name sets the first player filter. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (1200) & name2 (1234) vs name3 (1234) & name4 (1234)\". Clicking on the \"vs\" sets both player filters, with slight tweaks depending on the variant.\n\nMoves: a number. The number of moves of the game.\n\nViews: a number. The number of views the game got.\n\ndate: date type. When the game was played.\n\nThe name of the winning player is highlighted. Draws are also indicated.\n\nPast game view\n\nWhen a user clicks the \"Watch\" button for a past game, they are taken to the \"game page\" for that game (e.g., wallgame.io/game/2ei3nd43).\n\nThe final position is shown by default.\n\nThe chat is grayed out with a message that says \"Chat is not preserved.\"\n\nTab 4: Live games\n\nSimilar to the \"Past games\" page, this page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nThe formatting of the columns is the same as for \"Past Games\".\n\nWatch: a button that takes you to spectate the game in real time.\n\nViewers: a number.\n\nVariant: see \"Past games\" table.\n\nRated: see \"Past games\" table.\n\nTime control: see \"Past games\" table.\n\nBoard size: see \"Past games\" table.\n\nPlayers: see \"Past games\" table.\n\nMoves: see \"Past games\" table.\n\nThe rows are sorted by viewers first, by max ELO second.\n\nWhen a game ends, the number of spectators becomes the initial number of views in the past games table.\n\nLive game view\n\nWhen a user clicks the \"Watch\" button for a live game, they are taken to the \"game page\" for that game (e.g., wallgame.io/live/2ei3nd43).\n\nThe latest state of the game is shown by default.\n\nAs players make moves, spectators receive and see real-time updates.\n\nSpectators see the \"Spectator chat\", which is different than the ones the players see.\n\nTab 2: Ranking\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe filters do not have an \"all\" option.\n\nVariant: default: standard\n\nTime control: default: rapid\n\nPlayer: text field. Default: empty. The player filter acts more like a search box. If filled and the player exists, it only shows the row corresponding to that player and a few rows before and after. If the player does not exist, it shows nothing.\n\nRank: number starting at 1\n\nPlayer: the display name. It updates whenever players change their names delete their accounts.\n\nRating: the ELO rating. These are numbers sorted in decreasing order.\n\nPeak rating: the max ELO rating that player has ever had.\n\nRecord: a string formatted like \"10-4\" indicating the number of points the player got and lost across all its games.\n\nFirst game: a date.\n\nLast game: a date.\n\nClicking anywhere on a row takes you to the \"Past games\" page with the variant, time control, and player filters set. The \"rated\" filter is also set to \"yes\".\n\nTab 5: Learn\n\nThis page contains only static content, in four sections:\n\nRules (standard)\n\nNotation (standard)\n\nLessons (standard)\n\nAll the sections may contain images.\n\nSections can be collapsed.\n\nThis contains a couple of paragraphs explaining the rules of the \"standard\" variant.\n\nIt ends with: \"You can now start the solo campaign.\", with a link to the play tab (wallgame.io).\n\nThis contains a couple of paragraphs explaining the standard notation. This is useful since it appears in the game history element of the \"board view\" component.\n\nThis contains a bullet point list of links to blog posts explaining strategic and tactical ideas. More lessons can be added over time.\n\nThis contains definitions and special rules for all the supported variants.\n\nTab 1: Play\n\nThis is the 'landing' page.\n\nIts main purpose is to easily access the 6 game modes:\n\nSolo campaign\n\nStudy board\n\nPlay with others\n\nInvite friend\n\nIt contains three sections:\n\nSingle-player fun\n\nPlay with others\n\nGame showcase\n\nThe first two contain various buttons to go to the various game modes. The final one is just decorative. It's not there because it's related to the \"Play\" theme, but because it's the landing page.\n\nSingle-player fun\n\nThis section contains the following buttons:\n\nSolo campaign. There is an annotation that says \"Start here!\"\n\nStudy board\n\nPlay with others\n\nThis section contains the following buttons:\n\nFind others\n\nInvite friend\n\nGame showcase\n\nThis section shows a board and autoplays random past games, at high speed (2 moves per second). Above the board, a text says: \"Game showcase: name1 (1200) vs name2 (1234) (DATE)\", with the players and date updating as the game changes. There should also be a button to stop the autoplay.\n\nClicking on it takes you to the \"game page\" to watch the game, analogous to the \"Past games\" page. The only difference is that the game starts at the position that last played automatically in the game showcase.\n\nGame mode 2: Puzzles\n\nThe URL is wallgame.io/puzzles\n\nThe puzzles page has a list of puzzles.\n\nEach puzzle has:\n\nplay button\n\ndifficulty rating\n\ncompleted: yes/no. An indication of whether the user already solved it\n\nIf the user is not logged in, the 'completed' status is grayed out. There should be an information box indicating that the user should log in to save their completion status.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/puzzles/1, where 1 is the puzzle number. This makes it so that the user can share a puzzle by sharing the route.\n\nGame mode 1: Solo campaign\n\nThe URL is wallgame.io/solo-campaign\n\nThe solo campaign menu consists of a list of puzzles just like the menu for puzzles.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/solo-campaign/1, where 1 is the puzzle number.\n\nUnlike in normal puzzles, in solo campaign puzzles:\n\nThere is a text above the board view indicating what to do to win.\n\nThe game is usually played until the end.\n\nGame mode 3: Play vs AI\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Easy Bot\".\n\nGame mode 5: Play with others\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Matched user\".\n\nGame mode 6: Invite friend\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Friend\".\n\nGame mode 4: Study board\n\nThis takes you to a special instance of the \"game page\" with route wallgame.io/study-board.\n\nThe design for the study board page is work in progress.\n\nFinal thoughts\n\nI usually figure out the shape of things as I build them, like I did for wallwars.net, instead of writing a long design doc upfront. However:\n\nTo justify a full rewrite, I wanted to make sure the new design would accomplish the improvements that I wanted to see on the original site (see the list at the beginning of this post).\n\nAI-assisted coding has made all coding easier, but it has improved new code generation more than it has improved refactoring. For me, this shifted the tradeoff to the point where it seemed worth it to try to preempt as many direction shifts as possible.\n\nIn any case, now that I have this doc, I think it's a good opportunity to test out the various frontend generators (lovable and company) and see what they spit out. I probably won't use any of them directly, but they should give me good ideas for the styling.\n\nI fed this whole blog post to v0.dev (free tier). The prompt was \"Create mocks for the attached design doc.\" + this blog post, which is about 6000 words (a 33kB attachment).\n\nApart from putting the files in the wrong directory, it one-shotted the whole app with great prompt adherence and, in my opinion, great taste to fill in the gaps (recall that this design doc says basically nothing about styling).\n\nYou can see the results below (I skipped the less interesting pages).\n\nI emphasize that I did not have to break down the prompt into smaller chunks, as I'm so used to with tools like Cursor or basically anything LLM-based. I did not have to go screen by screen. It generated about 20 files and 3000 lines of next.js, with all navigation working as expected and mock data. I did not have to carefully craft a prompt on top of the design doc (though you can argue that this blog post is a great prompt). As someone who uses vibe coding regularly, this truly impressed me.\n\nI tried other frontend generators with the same prompt. lovable.dev did OK with prompt adherence (some pages did not work), but it did not have the same taste as v0.dev. It looks like a generic corporate site. Lovable's board component also looks messed up.\n\nbolt.new had great prompt adherence, about the same as v0.dev, but the site looked generic like lovable's (and the board was also messed up). V0 had the best use of space.\n\nOther tools I tried had a prompt length limit, so I didn't bother.\n\nIn the end, I just went back to v0.dev and used the rest of my daily free credits to ask it for different color themes.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-ui#appendix",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game UI Design (+ Frontend Generators)",
      "content": "Wall Game UI Design (+ Frontend Generators)\n\nThis blog post is a design doc for the frontend of wallgame.io, a board game I'm making. However, something probably more interesting came out of it: an assessment of frontend generators' ability to one-shot a 6000-word design doc prompt. The results deeply impressed me. They are in an appendix at the bottom. Feel free to skip the design doc and check out the appendix.\n\nThis is the specification of the frontend for the Wall Game, an online strategy board game. It only specifies the logic/functionality. It is agnostic of the look.\n\nA first version of the game is already available at wallwars.net. This is a UI overhaul with the following goals:\n\nA smooth onboarding experience. It should be very clear how to navigate the site and in what order to do things.\n\nTeaching the game to new players in a structured way.\n\nExpansive solo modes so that players can have fun even if there is no one else online.\n\nImproving the user journey of inviting friends to play.\n\nSupporting game variants as a first-class feature (this was a key feature for replayability when playing with a physical board).\n\nSupporting game variants with a varying number of players.\n\nSupporting multiple bots, including custom bots to foster the \"engine dev\" community.\n\nClean interface to game data, like past games, player history, rankings, etc., by showing interlinked tables with SQL-like features like filtering.\n\nMore \"social\" features, like an in-game chat and the ability to watch live games.\n\nFrontend Overview\n\nThe site is a SPA (single page app). There are 9 main pages, all of which are accessible from the top navigation bar. If a screen is not wide enough to show all the tabs, they are collapsed as necessary into a hamburger menu icon. Tabs act as buttons to show the corresponding page. Pages are self-contained and have their own URL:\n\nIn order, the tabs are:\n\nPlay (default) - wallgame.io\n\nRanking - wallgame.io/ranking\n\nPast games - wallgame.io/past-games\n\nLive games - wallgame.io/live-games\n\nLearn - wallgame.io/learn\n\nAbout - wallgame.io/about\n\nSettings - wallgame.io/settings\n\nProfile (appears as Login if the user is not logged in) - wallgame.io/profile\n\nThe navigation bar is always visible, and the current tab is highlighted.\n\nWe'll first go over the basic concepts, then some of the basic components reused across multiple pages, and finally, we'll go over each page (out of order).\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nPlayer types: there are 5 player types in the context of a game created by a user: \"You\": the user itself. \"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.) \"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\"). \"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game. \"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nPlayer types: there are 5 player types in the context of a game created by a user:\n\n\"You\": the user itself.\n\n\"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.)\n\n\"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\").\n\n\"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game.\n\n\"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter): The user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win). The user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully. The user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter):\n\nThe user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win).\n\nThe user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully.\n\nThe user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nThis section describes specific high-level components of the UI, which are reused in various places.\n\nThis is the main component involved in playing the game.\n\nA rectangular grid of square cells, with thick margins between them (that's where the walls go).\n\nA cell may contain one or more pawns. There is no limit on how many pawns can be in the same cell.\n\nA staged or premoved pawn move is shown with an arrow. Arbitrary arrows can also be added as calculations. It should be clear which one is which.\n\nBetween every two cells adjacent vertically or horizontally, there is a space where a wall can be placed, staged, premoved, calculated, or missing.\n\nThe corner between four cells is called a \"pillar\" and is not an interactable element.\n\nPlaced walls are colored according to the color of the pawns of the player who placed them.\n\nSimilar to chess and checkers, the cells are colored alternatively, so that cells that are an even number of moves away from each other share a color. The contrast between the two colors is subtle.\n\nLike chess, rows are labeled with numbers (starting from 1 on the top) and columns are labeled with letters (starting from 'a' on the left). The first cell in each row is labeled with the corresponding row number. The first cell in each column is labeled with the corresponding column letter. The labels are subtle, taking only a corner of the cell.\n\nThe last move is highlighted so it is easy for players to see what the opponent just did.\n\nThis includes the board itself and surrounding elements for any related information and interactions:\n\nthe timers. The timer of the player to move is highlighted.\n\nthe player names and ELOs. The name of the player to move is highlighted.\n\nthe move history in standard notation, with buttons to go back and forth and buttons to go to the beginning and latest move.\n\nthe chat. The chat can have multiple \"channels\": the \"game chat\", seen by all the players but not the audience the \"team chat\", seen only by players on the same team the \"audience chat\", seen only by the audience\n\nthe \"game chat\", seen by all the players but not the audience\n\nthe \"team chat\", seen only by players on the same team\n\nthe \"audience chat\", seen only by the audience\n\nan indicator of whose turn it is\n\nonline indicators for each player (if a player does not have the game tab/app active, it shows as offline)\n\nmenus for out-of-game interactions: \"resign\", \"offer draw\", \"propose take back\", \"give time (1 min)\", \"rematch\"\n\na button to toggle sounds\n\ncontextual information: the game variant and parameters the time control rated status the match score whose turn it is the player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\") after the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\nthe game variant and parameters\n\nthe time control\n\nrated status\n\nthe match score\n\nwhose turn it is\n\nthe player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\")\n\nafter the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\na button to see/copy the game's replay notation and standard notation\n\nGame configuration panel\n\nThis includes all the configuration options for a game.\n\ntime control: a selector with the options \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\".\n\nrated status: yes/no. If the player is not logged in, the 'rated status' is set to \"no\" and grayed out. There should be an informational text that says that the user needs to be logged in to play rated games.\n\nvariant: a selector of supported variants.\n\nadditional parameters that depend on the variant. These parameters appear in a container, and the container changes depending on the variant.\n\nFor example, for the standard variant:\n\nBoard width: number. Default: 8\n\nBoard height: number. Default: 8\n\nPlayer configuration\n\nA little component that lets you configure how a player in a game will move. It consists of a selector with a few options, each of which has an informational text.\n\n\"You\": \"You'll make the moves.\"\n\n\"Friend\": \"You'll get a link to share with a friend to join the game.\"\n\n\"Matched user\": \"You'll be paired with a random player with compatible settings and similar rating.\"\n\n\"Easy Bot\": \"You'll play against an easy AI bot.\"\n\n\"Medium Bot\": \"You'll play against a medium AI bot.\"\n\n\"Hard Bot\": \"You'll play against a hard AI bot.\"\n\n\"Custom bot\": \"You'll get an access token so that you can connect your own bot. See here for more information.\" The text links to a blog post explaining how to make a custom bot and connect it to the game using the token.\n\nThere is no default. It depends on the context.\n\nGame setup page\n\nThis page has its own URL: wallgame.io/game-setup.\n\nIt has two sections:\n\nCreate game\n\nCreate game\n\nThis part has the following elements:\n\nA button: \"Create game\".\n\nA player configuration component for each player (which depends on the variant, as set in #4). The selectors are labeled \"Player 1\", \"Player 2\", and so on. The default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe selectors are labeled \"Player 1\", \"Player 2\", and so on.\n\nThe default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe game configuration panel. Choosing a variant with more than 2 players will affect the number of player configuration components in #2.\n\nThis part has the following elements:\n\nA heading \"Join game\"\n\nA table showing games from other players that are in the \"matching stage\" and waiting for someone to join.\n\nThe table has the following columns:\n\nJoin: a button which, when clicked, joins the game.\n\nRated: yes/no.\n\nTime control: a string formatted like \"blitz (3+2)\"\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height).\n\nPlayer: a string formatted like \"name1 (1200)\". The numbers in parentheses is the rating. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (XXX) & name2 (YYY) vs name3 (ZZZ)\".\n\nThe rows are ordered by ELO closest to the current user's ELO. If the user chose a variant, rated status, time control, or board size in the game configuration panel, rows matching those settings are prioritized. Games that have been in \"matching stage\" for longer are also prioritized.\n\nThe parameterized URL is wallgame.io/game/game-id\n\nThe game page shows a game, identified with a given game ID in the URL. The game could be in the \"matching stage\", ongoing, or finished (a past game) The URL can be shared to join the game (if it is in the \"matching stage\"), to spectate it live (if it is ongoing) or watch it as a past game (if it is finished).\n\nThe game page has one main component: the board view.\n\nDepending on the context, it could contain other elements. See, e.g., the case of the \"Solo campaign\" puzzles, which contain an additional explanation text. So far, this seems to be the only exception.\n\nMatching stage panel\n\nWhen a user creates a game from wallgame.io/game-setup, a game ID is generated and they are taken to the game page with that game ID.\n\nHowever, it is possible that not all players are ready. For instance, if one of the player types is \"friend\", the game cannot start until the friend joins the game.\n\nIf not all players are ready, a \"matching stage\" panel component is shown as a modal over a faded out version of the game page.\n\nThe modal has a title: \"Waiting for players\". It contains one row for each player. Each row contains:\n\nThe player type (e.g., \"You\", \"Friend\", \"Easy Bot\", \"Medium Bot\", \"Hard Bot\", \"Custom Bot\", \"Matched player\")\n\nAn indication of whether the player is ready.\n\nInstructions for how that player should join the game If the player is \"You\", the player is automatically ready. If the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard. If the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready. If the player is \"Custom Bot\", the instructions include an access token for a custom bot. If the player is \"Matched player\", the instructions are to wait for someone to join.\n\nIf the player is \"You\", the player is automatically ready.\n\nIf the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard.\n\nIf the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready.\n\nIf the player is \"Custom Bot\", the instructions include an access token for a custom bot.\n\nIf the player is \"Matched player\", the instructions are to wait for someone to join.\n\nA button to abort the game and return to the previous page.\n\nIf a player joins a game but there are other players that are not ready (in the case of variants with more than 2 players), they will also see the matching stage panel.\n\nTab 7: Settings\n\nSettings have three sections:\n\nUser settings\n\nVisual style\n\nDefault game parameters\n\nFor sections 2 and 3, there should be an information box indicating that if the user is not logged in, they are saved as local cookies in the web browser. If they are logged in, the settings are saved to their account instead.\n\n1. User settings\n\nThis has one field:\n\nDisplay name (text field)\n\nIt behaves a bit differently depending on if the user is logged in.\n\nFor logged in users, the display name shows their current name and it is editable.\n\nThere should be a button next to the \"display name\" text field that says \"Change if available\" and an informational text that says \"Names must be unique across the site (case insensitive). You can only switch to another name not already in use.\" The button should be grayed out if the text field matches their current name. Names including \"guest\" or \"deleted\" or \"bot\" are not allowed. If the user tries to change to such a name, it should be explained to them.\n\nIf the user is not logged in, the display name should be grayed out and fixed as: \"Guest\"\n\nThere should also be an indication that the user needs to be logged in to change their display name, with a button to the Profile page.\n\n2. Visual style\n\nDark theme: on/off. Default: on\n\nBoard theme: selector. Default: \"classic\".\n\nPawn color: selector. Default: default.\n\nCat pawn: selector.\n\nMouse pawn: selector.\n\n... (one selector for each pawn type that appears in any variant)\n\nThe pawn selectors are between icons/small images.\n\n3. Default game parameters.\n\nThis is the game configuration panel component.\n\nA text says, \"When setting up a game, these parameters will be used as default.\"\n\nTab 6: About\n\nThis contains short informational text. The text can be something like this:\n\n\"Wall Game is a board game about building walls and outsmarting your opponents. It is inspired by Quoridor (wiki link) and Blockade (wiki link). Basic instructions about navigating the website (where to find the rules etc). Created by Nil Mamano (link). For more, you can read the blog (link).\"\n\nTab 8: Profile\n\nThis page looks different depending on whether the user is logged in or not.\n\nNot logged in\n\nThe tab appears as \"Login\".\n\nThe page shows two main buttons: log in and sign up\n\nIt includes a bit of text: \"Log in or sign up to choose a name, play rated games, and see your game history.\"\n\nFor the login and sign up flows, the user is redirected to an external auth service, so they are not part of this UI.\n\nThe tab appears as \"Profile\".\n\nIt shows the user display name and rating at the top, followed by a series of buttons grouped in two groups:\n\nPast Games: takes you to the Past Games tab but with the user's name already set as filter.\n\nRanking: takes you to the Ranking tab but with the user's name already set as filter.\n\nSettings: takes you to the settings page.\n\nDelete account\n\nThe delete account button shows a confirmation dialog: \"Your email will be deleted from the DB and all games you played will appear as 'Deleted User' and you won't be able to play again with this account. Are you sure?\"\n\nTab 3: Past games\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default. Filters are added as query parameters to the URL, so they can be shared.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nPlayer: text field (empty field acts as \"all\")\n\nPlayer: text field (empty field acts as \"all\").\n\nTime period: a date range\n\nThe two player fields serve the same purpose. Filling only one gives you all games with that player. Filling both gives you all games including both players.\n\nGames with fewer than 2 moves are filtered out. Games aborted during the \"matching stage\" are not even stored.\n\nThe rows are ordered by date. The order cannot be changed.\n\nWatch: a button which, when clicked, takes you to see the past game.\n\nVariant: clicking on a variant sets the variant filter.\n\nRated: yes/no. Clicking on a rating sets the rated status filter.\n\nTime control: a string formatted like \"blitz (3+2)\". Clicking on a time control sets the time control filter.\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height). Clicking on a board size sets the board size filter.\n\nPlayers: a string formatted like \"name1 (1200) vs name2 (1234)\". The numbers in parentheses are the ratings at the start of the game. Clicking on a name sets the first player filter. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (1200) & name2 (1234) vs name3 (1234) & name4 (1234)\". Clicking on the \"vs\" sets both player filters, with slight tweaks depending on the variant.\n\nMoves: a number. The number of moves of the game.\n\nViews: a number. The number of views the game got.\n\ndate: date type. When the game was played.\n\nThe name of the winning player is highlighted. Draws are also indicated.\n\nPast game view\n\nWhen a user clicks the \"Watch\" button for a past game, they are taken to the \"game page\" for that game (e.g., wallgame.io/game/2ei3nd43).\n\nThe final position is shown by default.\n\nThe chat is grayed out with a message that says \"Chat is not preserved.\"\n\nTab 4: Live games\n\nSimilar to the \"Past games\" page, this page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nThe formatting of the columns is the same as for \"Past Games\".\n\nWatch: a button that takes you to spectate the game in real time.\n\nViewers: a number.\n\nVariant: see \"Past games\" table.\n\nRated: see \"Past games\" table.\n\nTime control: see \"Past games\" table.\n\nBoard size: see \"Past games\" table.\n\nPlayers: see \"Past games\" table.\n\nMoves: see \"Past games\" table.\n\nThe rows are sorted by viewers first, by max ELO second.\n\nWhen a game ends, the number of spectators becomes the initial number of views in the past games table.\n\nLive game view\n\nWhen a user clicks the \"Watch\" button for a live game, they are taken to the \"game page\" for that game (e.g., wallgame.io/live/2ei3nd43).\n\nThe latest state of the game is shown by default.\n\nAs players make moves, spectators receive and see real-time updates.\n\nSpectators see the \"Spectator chat\", which is different than the ones the players see.\n\nTab 2: Ranking\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe filters do not have an \"all\" option.\n\nVariant: default: standard\n\nTime control: default: rapid\n\nPlayer: text field. Default: empty. The player filter acts more like a search box. If filled and the player exists, it only shows the row corresponding to that player and a few rows before and after. If the player does not exist, it shows nothing.\n\nRank: number starting at 1\n\nPlayer: the display name. It updates whenever players change their names delete their accounts.\n\nRating: the ELO rating. These are numbers sorted in decreasing order.\n\nPeak rating: the max ELO rating that player has ever had.\n\nRecord: a string formatted like \"10-4\" indicating the number of points the player got and lost across all its games.\n\nFirst game: a date.\n\nLast game: a date.\n\nClicking anywhere on a row takes you to the \"Past games\" page with the variant, time control, and player filters set. The \"rated\" filter is also set to \"yes\".\n\nTab 5: Learn\n\nThis page contains only static content, in four sections:\n\nRules (standard)\n\nNotation (standard)\n\nLessons (standard)\n\nAll the sections may contain images.\n\nSections can be collapsed.\n\nThis contains a couple of paragraphs explaining the rules of the \"standard\" variant.\n\nIt ends with: \"You can now start the solo campaign.\", with a link to the play tab (wallgame.io).\n\nThis contains a couple of paragraphs explaining the standard notation. This is useful since it appears in the game history element of the \"board view\" component.\n\nThis contains a bullet point list of links to blog posts explaining strategic and tactical ideas. More lessons can be added over time.\n\nThis contains definitions and special rules for all the supported variants.\n\nTab 1: Play\n\nThis is the 'landing' page.\n\nIts main purpose is to easily access the 6 game modes:\n\nSolo campaign\n\nStudy board\n\nPlay with others\n\nInvite friend\n\nIt contains three sections:\n\nSingle-player fun\n\nPlay with others\n\nGame showcase\n\nThe first two contain various buttons to go to the various game modes. The final one is just decorative. It's not there because it's related to the \"Play\" theme, but because it's the landing page.\n\nSingle-player fun\n\nThis section contains the following buttons:\n\nSolo campaign. There is an annotation that says \"Start here!\"\n\nStudy board\n\nPlay with others\n\nThis section contains the following buttons:\n\nFind others\n\nInvite friend\n\nGame showcase\n\nThis section shows a board and autoplays random past games, at high speed (2 moves per second). Above the board, a text says: \"Game showcase: name1 (1200) vs name2 (1234) (DATE)\", with the players and date updating as the game changes. There should also be a button to stop the autoplay.\n\nClicking on it takes you to the \"game page\" to watch the game, analogous to the \"Past games\" page. The only difference is that the game starts at the position that last played automatically in the game showcase.\n\nGame mode 2: Puzzles\n\nThe URL is wallgame.io/puzzles\n\nThe puzzles page has a list of puzzles.\n\nEach puzzle has:\n\nplay button\n\ndifficulty rating\n\ncompleted: yes/no. An indication of whether the user already solved it\n\nIf the user is not logged in, the 'completed' status is grayed out. There should be an information box indicating that the user should log in to save their completion status.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/puzzles/1, where 1 is the puzzle number. This makes it so that the user can share a puzzle by sharing the route.\n\nGame mode 1: Solo campaign\n\nThe URL is wallgame.io/solo-campaign\n\nThe solo campaign menu consists of a list of puzzles just like the menu for puzzles.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/solo-campaign/1, where 1 is the puzzle number.\n\nUnlike in normal puzzles, in solo campaign puzzles:\n\nThere is a text above the board view indicating what to do to win.\n\nThe game is usually played until the end.\n\nGame mode 3: Play vs AI\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Easy Bot\".\n\nGame mode 5: Play with others\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Matched user\".\n\nGame mode 6: Invite friend\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Friend\".\n\nGame mode 4: Study board\n\nThis takes you to a special instance of the \"game page\" with route wallgame.io/study-board.\n\nThe design for the study board page is work in progress.\n\nFinal thoughts\n\nI usually figure out the shape of things as I build them, like I did for wallwars.net, instead of writing a long design doc upfront. However:\n\nTo justify a full rewrite, I wanted to make sure the new design would accomplish the improvements that I wanted to see on the original site (see the list at the beginning of this post).\n\nAI-assisted coding has made all coding easier, but it has improved new code generation more than it has improved refactoring. For me, this shifted the tradeoff to the point where it seemed worth it to try to preempt as many direction shifts as possible.\n\nIn any case, now that I have this doc, I think it's a good opportunity to test out the various frontend generators (lovable and company) and see what they spit out. I probably won't use any of them directly, but they should give me good ideas for the styling.\n\nI fed this whole blog post to v0.dev (free tier). The prompt was \"Create mocks for the attached design doc.\" + this blog post, which is about 6000 words (a 33kB attachment).\n\nApart from putting the files in the wrong directory, it one-shotted the whole app with great prompt adherence and, in my opinion, great taste to fill in the gaps (recall that this design doc says basically nothing about styling).\n\nYou can see the results below (I skipped the less interesting pages).\n\nI emphasize that I did not have to break down the prompt into smaller chunks, as I'm so used to with tools like Cursor or basically anything LLM-based. I did not have to go screen by screen. It generated about 20 files and 3000 lines of next.js, with all navigation working as expected and mock data. I did not have to carefully craft a prompt on top of the design doc (though you can argue that this blog post is a great prompt). As someone who uses vibe coding regularly, this truly impressed me.\n\nI tried other frontend generators with the same prompt. lovable.dev did OK with prompt adherence (some pages did not work), but it did not have the same taste as v0.dev. It looks like a generic corporate site. Lovable's board component also looks messed up.\n\nbolt.new had great prompt adherence, about the same as v0.dev, but the site looked generic like lovable's (and the board was also messed up). V0 had the best use of space.\n\nOther tools I tried had a prompt length limit, so I didn't bother.\n\nIn the end, I just went back to v0.dev and used the rest of my daily free credits to ask it for different color themes.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-ui#game-page",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game DB Design",
      "content": "Wall Game DB Design\n\nThis blog post documents the initial design for the DB schema for the Wall Game, with commentary on the design choices.\n\nDisclaimer: I haven't tested any of the SQL. The site has not been built yet at the time of writing (March 2025). All the screenshots from the site are from a prototype made with v0.dev as explained in this post. As always, if you spot any mistakes or improvements, I'd love to know!\n\nThe DB is a PostgreSQL database, though I aim to keep the schema as dialect-agnostic as possible in case I want to migrate in the future. (You can see this post for a discussion on how I chose the tech stack.)\n\nWe'll start by designing all the tables, as shown in the diagram below, and then we'll write all the queries we need to support the frontend logic.\n\nThis is the main users table:\n\nFuture-proofing auth-provider changes\n\nI tried to future-proof it against auth-provider changes. The plan is to start using Kinde, which means that the only thing we need to store in the DB is a unique user ID provided by Kinde (it looks something like \"kp_a1b2c3d4e5\").\n\nTo avoid coupling, we don't want to use that as the user's primary id. A straightforward approach would be to put it in a separate field:\n\nHowever, in a migration, it may be tricky to coordinate the change of auth_user_id from the old auth provider to the new one. Instead, I decided to just indicate the auth_provider in the users table (e.g., \"kinde\") and put the auth_user_id in a separate table with primary key (user_id, auth_provider):\n\nThis way, a user can have, e.g., a Kinde key and an Auth0 key at the same time, and we can switch from Kinde to Auth0 by changing the auth_provider in the users table from \"kinde\" to \"auth0\" (without deleting the Kinde key yet).\n\nHandling unique usernames\n\nWe allow users to change their display name, and they are allowed to use uppercase letters, but, to avoid impersonation, we enforce that display name must be unique in a case-insensitive way.\n\nWe can think as the lowercase version of their display name as the \"canonical\" name, while the capitalized version is just an inconsequential styling choice. That's why we have both display_name and capitalized_display_name columns.\n\nIn general, the plan is to keep validation logic in the backend, not in the DB. However, I'm particularly concerned about uppercase letters slipping through to the display_name field, so I added the constraint:\n\nEncoding enum-like data\n\nI've considered multiple ways of storing \"enum-like\" data like auth providers, time controls (which can only be \"bullet\", \"blitz\", \"rapid\", or \"classical\") or variants (which will start with only two options, but more will be added over time).\n\nFor example, if we have a column, my_enum, that can only have values \"aa\" and \"bb\", we could do:\n\nPostgreSQL's ENUM type. This is efficient and straightforward, but it would be a bit annoying to add new fields (e.g., \"cc\"), as it would require a (small) schema change. It's also very Postgres specific.\n\nA VARCHAR with a CHECK constraint. This would still require a schema change to add a new value.\n\nA \"lookup table\". We store the allowed values as the primary key in a separate table, say allowed_values, and then have a foreign key constraint on the my_enum column. This allows us to add new values without a schema change.\n\nA \"lookup table\" with an auto-incremented integer primary key. Instead of making \"aa\" the primary key directly, we could make the primary key an auto-incremented integer. This is more flexible and avoids string-matching logic and duplicating strings. However, this requires joins to get the actual names, complicating queries.\n\nUse an integer, and have a convention between the backend and the DB about the mapping from those integers to the actual values. This is the most space- and time-efficient, but it's the most brittle.\n\nIn the end, I decided to KISS and use a plain string column, and just be careful when inserting values.\n\nELO ratings are specific to a variant and time control, so we can't keep them in the users table.\n\nOptimizing the Ranking page\n\nThe final four columns in the ratings table are needed for the Ranking page (the First Game column in the prototype below will be replaced by Join Date):\n\nThese columns are redundant, as they could be computed by aggregating information from the games table. However, it would be expensive to, e.g., look through all the games of a user to find its peak rating. Instead, the plan is to precompute these columns in the backend and update them whenever a user finishes a game.\n\nThe downside of this approach is that the games and ratings tables may be in an inconsistent state. For example, if a game somehow disappears from the games table, a player may end up with a \"3-0\" record even though they only have two games in the DB. I think this is OK. First, it's not clear what should happen if a game disappears--it doesn't retroactively change the fact that the player played three games. Second, we can always run a one-off query to fix the precomputed fields.\n\nInstead of having the backend compute these fields, an alternative approach would be to have a cron job that updates them periodically. However, when a user reaches a new peak rating, they probably want it to be reflected immediately in the Ranking.\n\nGames will only be stored in the DB when they are finished, which allows us to make more assumptions (all players joined, there is an outcome, etc.) and simplify the schema. The downside is that, if the server crashes, all on-going games will be lost. (I once mentioned this concern to a friend and he said, \"But the server shouldn't crash.\" Fair point...)\n\nOptimizing the Past Games page\n\nWe split the game data into two. The main table, games, has all the \"metadata\" about the game, while the game_details table has the actual list of moves and configuration parameters (e.g., variant-specific parameters):\n\nThe reason for the split is that the game details take a lot more space than the other fields, and the main use case for storing games is listing them on the \"Past Games\" page, which doesn't need the game details:\n\nThe query for this page can be based on the games table only. The game details only need to be brought in when the user watches a specific game.\n\nI'm really not sure if this is worth it, though. This may be a premature optimization that adds unnecessary complexity (the two tables now need to be kept in sync and updated together in transactions).\n\nAnother interesting decision was whether to store the moves in a SQL moves table or as a JSON blob. I decided to go with the latter because I don't have any need for querying individual moves within a game or across games. We'll always want either all the moves of a single game, or none. One downside is that we need to precompute the moves_count column in the games table.\n\nGame players\n\nAs you can see, the games table does not capture the players or the game outcome. The reason is that the number of players per game depends on the variant, so we couldn't simply have player1 and player2 columns. For the same reason, the outcome is not as simple as \"P1 won\" or \"P2 won\" or \"draw\". Instead, it makes more sense to think about per-player outcomes. Each player outcome consists of a placement and a reason. E.g., a player may have finished 3rd for the reason that the 4th player timed out.\n\nThe following table connects games and players:\n\nAs we discussed earlier, handling username changes is tricky. If you are watching a past game, do you want to see the current name or the name at the time of the game? In our case, we won't bother with historical names, so we don't need a player_name_at_the_time column. The same for the pawn color and shape they chose at the time. On the other hand, we do want to know their ELO at the time.\n\nLet's discuss the workflow for built-in bots. Besides the main backend, there is a bot service responsible for making bot moves. The main backend stays focused on I/O tasks and doesn't hang on long computations.\n\nThe steps go like this:\n\nThe user chooses the game parameters (e.g., the variant) and chooses to play against a built-in bot.\n\nThe backend asks the bot service for bots available given the game parameters.\n\nThe bot service responds with a list of bot names to display (e.g., \"Easy Bot\", \"Medium Bot\", \"Hard Bot\") along with their bot_id's.\n\nThe player chooses a bot and the game starts.\n\nThe backend asks the bot service for moves from the chosen bot by providing its bot_id.\n\nWhen the game ends, the backend uploads it to the DB. If the bot_id is not in the built_in_bots table, a new row is added:\n\nThe bot service is responsible for choosing and managing bot IDs. The idea is that they should identify a specific algorithm/implementation/binary/version. That is, if I train an improved version of the \"Hard Bot\", the display name can stay the same, but the bot_id should be different.\n\nThe backend and the DB don't need to know which bot_id's can play in which variants and things like that. The backend doesn't ask the DB for which bots are available--it asks the bot service. So, there is no variant column and such in the built_in_bots table.\n\nCustom bots\n\nCustom bots are not fully designed yet, but, for an initial design, we don't need a table for custom bots. When a user chooses to play against their own custom bot, the user is given a token to join the game from their bot client. The client only provides moves (as if it were a human), and does not have its own display name or bot id (to avoid having to deal with clashes with real users or built-in bots). The display name can always be \"Custom Bot\".\n\nIn a full-fledged custom bot system like the one on Lichess, custom bots are just like regular users (with some limitations). Anyone can list their bot, and then players can invite them to a game and they'll join just as if you invited a regular user. This is out of scope.\n\nA puzzle is a game that has been setup to a specific situation where there is a good move (or sequence of moves) that the user must find. Here is Puzzle 10 from the first version of the site, wallwars.net:\n\nHere is the main puzzles table. The specific initial configuration (pre-existing walls and player positions) is part of the game parameters.\n\nTo track completions:\n\nA complication with the Wall Game (compared to, e.g., chess) is that there are often many moves that achieve the same effect. E.g., if there is a long 'tunnel' that is one row wide, putting any wall along the tunnel has the same effect of blocking it. There can be 100's of equally good moves in realistic situations. Thus, we cannot simply check whether the user finds the \"correct\" move.\n\nInstead of \"hard-coding\" the solution, we can compare the user's move against the moves of a bot which is smart enough to solve the puzzle. If the bot scores the player's move as tangibly worse than its top choice, the move is considered wrong. The same bot also counters the player's moves. This goes on until the game ends (the player wins or draws) or until the user has made a predetermined number of moves (which can be specified in the puzzle_metadata). If necessary, we can experiment with fine-tuning the baseline AI to solve specific puzzles. We'll see.\n\nFor now, we don't support user-created puzzles.\n\nUser settings\n\nThe final tables store the user settings.\n\nThe following queries power the functionality we need for the site.\n\nGame showcase\n\nThe landing page shows a showcase from a past game, which autoplays the moves. This requires pulling a random game from the DB, including the moves.\n\nWe can get it with this query:\n\nTo reduce DB queries, the backend could send the same showcase game to multiple users.\n\nSolo campaign & Puzzles\n\nWhen the user goes to the 'Solo Campaign' page, they can see an ordered list of \"levels\" (i.e., puzzles) in order. Each level has a name, description, difficulty, and completion status.\n\nWe can pull them with this query:\n\nThe 'Puzzles' page is similar.\n\nWe include p.config_parameters and p.puzzle_metadata in the query so that, when the user clicks on a puzzle/level, we have everything we need to set it up and start playing.\n\nAvailable games\n\nPlayers can see a list of games in the matchmaking stage, where the user is waiting for an opponent.\n\nWe won't use SQL for this. These games haven't finished yet, so they are not in the DB--only in the backend.\n\nImplementing pagination and filtering\n\nThe 'Ranking' and 'Past Games' pages allow the user to essentially inspect the ranking and games tables, respectively, with pagination and filtering. This gives rise to a basic yet tricky software architecture question:\n\nSuppose you have a full-stack app and there is a large table in the DB, which the user can browse in the frontend. We show the user 100 rows at a time, and they can navigate to the next or previous 100 rows. How do you implement this pagination? (We could ask the same about filtering.)\n\nAssumptions:\n\nThe table is not just static data; it gets updates over time.\n\nThe rows must be shown to the user sorted by a specific column, say, 'rank'.\n\nThe backend runs on a single server.\n\nYou have 3 main options for where to implement pagination:\n\nAt the DB level: this is slow, as it requires a DB round-trip every time the user wants to see a new 100-row block, but it guarantees the data is never stale and the backend can remain stateless. We can add a table index on the 'rank' column to speed up the query.\n\nAt the DB level: this is slow, as it requires a DB round-trip every time the user wants to see a new 100-row block, but it guarantees the data is never stale and the backend can remain stateless. We can add a table index on the 'rank' column to speed up the query.\n\nAt the backend level: if the backend maintains a cached copy of the table (say, as an array), it can return the appropriate range of the array to the frontend, avoiding the DB. This introduces the problem of how to keep the backend's copy of the table always synced with the DB and sorted by 'rank'. For the former, the backend would need to do parallel updates to the DB and the cache. For the latter, if re-sorting on each update is too expensive, something like Redis could take care of it for us.\n\nAt the backend level: if the backend maintains a cached copy of the table (say, as an array), it can return the appropriate range of the array to the frontend, avoiding the DB. This introduces the problem of how to keep the backend's copy of the table always synced with the DB and sorted by 'rank'. For the former, the backend would need to do parallel updates to the DB and the cache. For the latter, if re-sorting on each update is too expensive, something like Redis could take care of it for us.\n\nAt the frontend level: whenever the user goes to the page, the backend sends the full table (or a big chunk of it), not just the first 100 rows (the backend either maintains a cached copy or queries the DB). This approach makes pagination the most responsive, involving no API calls, but it is also the most stale, as the data won't update until the user refreshes the page. In this case, whether the backend maintains a local copy or not only affects the initial load time.\n\nAt the frontend level: whenever the user goes to the page, the backend sends the full table (or a big chunk of it), not just the first 100 rows (the backend either maintains a cached copy or queries the DB). This approach makes pagination the most responsive, involving no API calls, but it is also the most stale, as the data won't update until the user refreshes the page. In this case, whether the backend maintains a local copy or not only affects the initial load time.\n\nEach approach has its pros and cons. It comes down to the numbers, like the number of rows, the size of each row, the frequency of updates, the duration of a round-trip, how often each feature is used, and so on.\n\nDid I miss any other options?\n\nUltimately, there's no right answer, as it also depends on subjective factors like how much you care about user experience vs data freshness, or how much you care about adding engineering complexity.\n\nThe same decision about where to do pagination also comes up with row filtering and ordering. It can be done in the DB, backend, or frontend.\n\nFor our site, we'll start with the slowest but simplest solution (DB round-trip each time), and we'll optimize as needed.\n\nThe 'Ranking' page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe mandatory filters are 'Variant' and 'Time control'.\n\nBy default, the ranking shows the top 100 players for that variant and time control. We can use pagination to see more.\n\nTo fill in each row, we need the following data: rank, player, rating, peak rating, record wins and losses, user creation date, and date of the user's last game.\n\nThere is also an optional 'Player' search box. If filled with a player name and the player exists, it jumps directly to the page (100-block) containing that player. If the player does not exist, it shows nothing.\n\nAs mentioned, we'll implement pagination and filtering in the DB. We can add a table index on the display_name column to speed up the \"player search\" query:\n\nHere is the full query:\n\nWe include deleted players in the ranking. They'll just show up as something like \"Deleted User 23\".\n\nWe already discussed the 'Past games' page in the Games section. All the filters have an \"all\" option which is the default:\n\nTime control\n\nBoard size: selector with (small / medium / large / all). Games are grouped by board size according to width x height: \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares).\n\nELO: a numerical range (missing from the 'Past games' page screenshot)\n\nTime period: a date range (missing from the 'Past games' page screenshot)\n\nTwo player filters: filling one gives you all games with that player. Filling both gives you all games including both players.\n\nWe also need pagination: we'll show up to 100 games per page and let the user navigate to the next/previous 100-block.\n\nTo fill in each row, we need the following data: variant, rated, time control, board width and height, names and ELOs of all the involved players (could be more than 2 depending on the variant), the number of moves, and the date when the game was played. We also need the game id in case the user wants to watch the game.\n\nWhen the user selects a game to watch, we need to get the moves and configuration parameters, as well as the players' chosen pawn colors and shapes, which we can pull from the user_settings table:\n\nUser settings\n\nWhen the user goes to the 'Settings' page, they can change the following settings, and this is stored in the DB:\n\nDisplay name\n\nBoard theme\n\nCat pawn shape\n\nMouse pawn shape\n\n... (one selector for each pawn type that appears in any variant)\n\nDefault variant\n\nDefault time control\n\nDefault rated status\n\nDefault parameters for each specific variant\n\nWe pull the settings with this query:\n\nTo guarantee unique usernames, a user can only change it to a username that does not appear in the DB. We can check this with this query:\n\nWe'd also need queries to update each user settings (changes take effect immediately--there's no final \"Update\" button in the UI), but these are straightforward.\n\nFinally, if a user chooses to delete their account, we need to rename them to \"Deleted User #\" where # is the next available number among deleted users, starting from 1. We can do this with this query:\n\nThe actual user record remains in the database to maintain game history and statistics, but the user can no longer log in and their personal information is removed.\n\nThis concludes the discussion of the DB schema for the Wall Game, a series of blog posts on building a multiplayer online board game. Next, we'll deep dive into how to train an alpha-zero-like AI for the Wall Game.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-db#games",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game DB Design",
      "content": "Wall Game DB Design\n\nThis blog post documents the initial design for the DB schema for the Wall Game, with commentary on the design choices.\n\nDisclaimer: I haven't tested any of the SQL. The site has not been built yet at the time of writing (March 2025). All the screenshots from the site are from a prototype made with v0.dev as explained in this post. As always, if you spot any mistakes or improvements, I'd love to know!\n\nThe DB is a PostgreSQL database, though I aim to keep the schema as dialect-agnostic as possible in case I want to migrate in the future. (You can see this post for a discussion on how I chose the tech stack.)\n\nWe'll start by designing all the tables, as shown in the diagram below, and then we'll write all the queries we need to support the frontend logic.\n\nThis is the main users table:\n\nFuture-proofing auth-provider changes\n\nI tried to future-proof it against auth-provider changes. The plan is to start using Kinde, which means that the only thing we need to store in the DB is a unique user ID provided by Kinde (it looks something like \"kp_a1b2c3d4e5\").\n\nTo avoid coupling, we don't want to use that as the user's primary id. A straightforward approach would be to put it in a separate field:\n\nHowever, in a migration, it may be tricky to coordinate the change of auth_user_id from the old auth provider to the new one. Instead, I decided to just indicate the auth_provider in the users table (e.g., \"kinde\") and put the auth_user_id in a separate table with primary key (user_id, auth_provider):\n\nThis way, a user can have, e.g., a Kinde key and an Auth0 key at the same time, and we can switch from Kinde to Auth0 by changing the auth_provider in the users table from \"kinde\" to \"auth0\" (without deleting the Kinde key yet).\n\nHandling unique usernames\n\nWe allow users to change their display name, and they are allowed to use uppercase letters, but, to avoid impersonation, we enforce that display name must be unique in a case-insensitive way.\n\nWe can think as the lowercase version of their display name as the \"canonical\" name, while the capitalized version is just an inconsequential styling choice. That's why we have both display_name and capitalized_display_name columns.\n\nIn general, the plan is to keep validation logic in the backend, not in the DB. However, I'm particularly concerned about uppercase letters slipping through to the display_name field, so I added the constraint:\n\nEncoding enum-like data\n\nI've considered multiple ways of storing \"enum-like\" data like auth providers, time controls (which can only be \"bullet\", \"blitz\", \"rapid\", or \"classical\") or variants (which will start with only two options, but more will be added over time).\n\nFor example, if we have a column, my_enum, that can only have values \"aa\" and \"bb\", we could do:\n\nPostgreSQL's ENUM type. This is efficient and straightforward, but it would be a bit annoying to add new fields (e.g., \"cc\"), as it would require a (small) schema change. It's also very Postgres specific.\n\nA VARCHAR with a CHECK constraint. This would still require a schema change to add a new value.\n\nA \"lookup table\". We store the allowed values as the primary key in a separate table, say allowed_values, and then have a foreign key constraint on the my_enum column. This allows us to add new values without a schema change.\n\nA \"lookup table\" with an auto-incremented integer primary key. Instead of making \"aa\" the primary key directly, we could make the primary key an auto-incremented integer. This is more flexible and avoids string-matching logic and duplicating strings. However, this requires joins to get the actual names, complicating queries.\n\nUse an integer, and have a convention between the backend and the DB about the mapping from those integers to the actual values. This is the most space- and time-efficient, but it's the most brittle.\n\nIn the end, I decided to KISS and use a plain string column, and just be careful when inserting values.\n\nELO ratings are specific to a variant and time control, so we can't keep them in the users table.\n\nOptimizing the Ranking page\n\nThe final four columns in the ratings table are needed for the Ranking page (the First Game column in the prototype below will be replaced by Join Date):\n\nThese columns are redundant, as they could be computed by aggregating information from the games table. However, it would be expensive to, e.g., look through all the games of a user to find its peak rating. Instead, the plan is to precompute these columns in the backend and update them whenever a user finishes a game.\n\nThe downside of this approach is that the games and ratings tables may be in an inconsistent state. For example, if a game somehow disappears from the games table, a player may end up with a \"3-0\" record even though they only have two games in the DB. I think this is OK. First, it's not clear what should happen if a game disappears--it doesn't retroactively change the fact that the player played three games. Second, we can always run a one-off query to fix the precomputed fields.\n\nInstead of having the backend compute these fields, an alternative approach would be to have a cron job that updates them periodically. However, when a user reaches a new peak rating, they probably want it to be reflected immediately in the Ranking.\n\nGames will only be stored in the DB when they are finished, which allows us to make more assumptions (all players joined, there is an outcome, etc.) and simplify the schema. The downside is that, if the server crashes, all on-going games will be lost. (I once mentioned this concern to a friend and he said, \"But the server shouldn't crash.\" Fair point...)\n\nOptimizing the Past Games page\n\nWe split the game data into two. The main table, games, has all the \"metadata\" about the game, while the game_details table has the actual list of moves and configuration parameters (e.g., variant-specific parameters):\n\nThe reason for the split is that the game details take a lot more space than the other fields, and the main use case for storing games is listing them on the \"Past Games\" page, which doesn't need the game details:\n\nThe query for this page can be based on the games table only. The game details only need to be brought in when the user watches a specific game.\n\nI'm really not sure if this is worth it, though. This may be a premature optimization that adds unnecessary complexity (the two tables now need to be kept in sync and updated together in transactions).\n\nAnother interesting decision was whether to store the moves in a SQL moves table or as a JSON blob. I decided to go with the latter because I don't have any need for querying individual moves within a game or across games. We'll always want either all the moves of a single game, or none. One downside is that we need to precompute the moves_count column in the games table.\n\nGame players\n\nAs you can see, the games table does not capture the players or the game outcome. The reason is that the number of players per game depends on the variant, so we couldn't simply have player1 and player2 columns. For the same reason, the outcome is not as simple as \"P1 won\" or \"P2 won\" or \"draw\". Instead, it makes more sense to think about per-player outcomes. Each player outcome consists of a placement and a reason. E.g., a player may have finished 3rd for the reason that the 4th player timed out.\n\nThe following table connects games and players:\n\nAs we discussed earlier, handling username changes is tricky. If you are watching a past game, do you want to see the current name or the name at the time of the game? In our case, we won't bother with historical names, so we don't need a player_name_at_the_time column. The same for the pawn color and shape they chose at the time. On the other hand, we do want to know their ELO at the time.\n\nLet's discuss the workflow for built-in bots. Besides the main backend, there is a bot service responsible for making bot moves. The main backend stays focused on I/O tasks and doesn't hang on long computations.\n\nThe steps go like this:\n\nThe user chooses the game parameters (e.g., the variant) and chooses to play against a built-in bot.\n\nThe backend asks the bot service for bots available given the game parameters.\n\nThe bot service responds with a list of bot names to display (e.g., \"Easy Bot\", \"Medium Bot\", \"Hard Bot\") along with their bot_id's.\n\nThe player chooses a bot and the game starts.\n\nThe backend asks the bot service for moves from the chosen bot by providing its bot_id.\n\nWhen the game ends, the backend uploads it to the DB. If the bot_id is not in the built_in_bots table, a new row is added:\n\nThe bot service is responsible for choosing and managing bot IDs. The idea is that they should identify a specific algorithm/implementation/binary/version. That is, if I train an improved version of the \"Hard Bot\", the display name can stay the same, but the bot_id should be different.\n\nThe backend and the DB don't need to know which bot_id's can play in which variants and things like that. The backend doesn't ask the DB for which bots are available--it asks the bot service. So, there is no variant column and such in the built_in_bots table.\n\nCustom bots\n\nCustom bots are not fully designed yet, but, for an initial design, we don't need a table for custom bots. When a user chooses to play against their own custom bot, the user is given a token to join the game from their bot client. The client only provides moves (as if it were a human), and does not have its own display name or bot id (to avoid having to deal with clashes with real users or built-in bots). The display name can always be \"Custom Bot\".\n\nIn a full-fledged custom bot system like the one on Lichess, custom bots are just like regular users (with some limitations). Anyone can list their bot, and then players can invite them to a game and they'll join just as if you invited a regular user. This is out of scope.\n\nA puzzle is a game that has been setup to a specific situation where there is a good move (or sequence of moves) that the user must find. Here is Puzzle 10 from the first version of the site, wallwars.net:\n\nHere is the main puzzles table. The specific initial configuration (pre-existing walls and player positions) is part of the game parameters.\n\nTo track completions:\n\nA complication with the Wall Game (compared to, e.g., chess) is that there are often many moves that achieve the same effect. E.g., if there is a long 'tunnel' that is one row wide, putting any wall along the tunnel has the same effect of blocking it. There can be 100's of equally good moves in realistic situations. Thus, we cannot simply check whether the user finds the \"correct\" move.\n\nInstead of \"hard-coding\" the solution, we can compare the user's move against the moves of a bot which is smart enough to solve the puzzle. If the bot scores the player's move as tangibly worse than its top choice, the move is considered wrong. The same bot also counters the player's moves. This goes on until the game ends (the player wins or draws) or until the user has made a predetermined number of moves (which can be specified in the puzzle_metadata). If necessary, we can experiment with fine-tuning the baseline AI to solve specific puzzles. We'll see.\n\nFor now, we don't support user-created puzzles.\n\nUser settings\n\nThe final tables store the user settings.\n\nThe following queries power the functionality we need for the site.\n\nGame showcase\n\nThe landing page shows a showcase from a past game, which autoplays the moves. This requires pulling a random game from the DB, including the moves.\n\nWe can get it with this query:\n\nTo reduce DB queries, the backend could send the same showcase game to multiple users.\n\nSolo campaign & Puzzles\n\nWhen the user goes to the 'Solo Campaign' page, they can see an ordered list of \"levels\" (i.e., puzzles) in order. Each level has a name, description, difficulty, and completion status.\n\nWe can pull them with this query:\n\nThe 'Puzzles' page is similar.\n\nWe include p.config_parameters and p.puzzle_metadata in the query so that, when the user clicks on a puzzle/level, we have everything we need to set it up and start playing.\n\nAvailable games\n\nPlayers can see a list of games in the matchmaking stage, where the user is waiting for an opponent.\n\nWe won't use SQL for this. These games haven't finished yet, so they are not in the DB--only in the backend.\n\nImplementing pagination and filtering\n\nThe 'Ranking' and 'Past Games' pages allow the user to essentially inspect the ranking and games tables, respectively, with pagination and filtering. This gives rise to a basic yet tricky software architecture question:\n\nSuppose you have a full-stack app and there is a large table in the DB, which the user can browse in the frontend. We show the user 100 rows at a time, and they can navigate to the next or previous 100 rows. How do you implement this pagination? (We could ask the same about filtering.)\n\nAssumptions:\n\nThe table is not just static data; it gets updates over time.\n\nThe rows must be shown to the user sorted by a specific column, say, 'rank'.\n\nThe backend runs on a single server.\n\nYou have 3 main options for where to implement pagination:\n\nAt the DB level: this is slow, as it requires a DB round-trip every time the user wants to see a new 100-row block, but it guarantees the data is never stale and the backend can remain stateless. We can add a table index on the 'rank' column to speed up the query.\n\nAt the DB level: this is slow, as it requires a DB round-trip every time the user wants to see a new 100-row block, but it guarantees the data is never stale and the backend can remain stateless. We can add a table index on the 'rank' column to speed up the query.\n\nAt the backend level: if the backend maintains a cached copy of the table (say, as an array), it can return the appropriate range of the array to the frontend, avoiding the DB. This introduces the problem of how to keep the backend's copy of the table always synced with the DB and sorted by 'rank'. For the former, the backend would need to do parallel updates to the DB and the cache. For the latter, if re-sorting on each update is too expensive, something like Redis could take care of it for us.\n\nAt the backend level: if the backend maintains a cached copy of the table (say, as an array), it can return the appropriate range of the array to the frontend, avoiding the DB. This introduces the problem of how to keep the backend's copy of the table always synced with the DB and sorted by 'rank'. For the former, the backend would need to do parallel updates to the DB and the cache. For the latter, if re-sorting on each update is too expensive, something like Redis could take care of it for us.\n\nAt the frontend level: whenever the user goes to the page, the backend sends the full table (or a big chunk of it), not just the first 100 rows (the backend either maintains a cached copy or queries the DB). This approach makes pagination the most responsive, involving no API calls, but it is also the most stale, as the data won't update until the user refreshes the page. In this case, whether the backend maintains a local copy or not only affects the initial load time.\n\nAt the frontend level: whenever the user goes to the page, the backend sends the full table (or a big chunk of it), not just the first 100 rows (the backend either maintains a cached copy or queries the DB). This approach makes pagination the most responsive, involving no API calls, but it is also the most stale, as the data won't update until the user refreshes the page. In this case, whether the backend maintains a local copy or not only affects the initial load time.\n\nEach approach has its pros and cons. It comes down to the numbers, like the number of rows, the size of each row, the frequency of updates, the duration of a round-trip, how often each feature is used, and so on.\n\nDid I miss any other options?\n\nUltimately, there's no right answer, as it also depends on subjective factors like how much you care about user experience vs data freshness, or how much you care about adding engineering complexity.\n\nThe same decision about where to do pagination also comes up with row filtering and ordering. It can be done in the DB, backend, or frontend.\n\nFor our site, we'll start with the slowest but simplest solution (DB round-trip each time), and we'll optimize as needed.\n\nThe 'Ranking' page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe mandatory filters are 'Variant' and 'Time control'.\n\nBy default, the ranking shows the top 100 players for that variant and time control. We can use pagination to see more.\n\nTo fill in each row, we need the following data: rank, player, rating, peak rating, record wins and losses, user creation date, and date of the user's last game.\n\nThere is also an optional 'Player' search box. If filled with a player name and the player exists, it jumps directly to the page (100-block) containing that player. If the player does not exist, it shows nothing.\n\nAs mentioned, we'll implement pagination and filtering in the DB. We can add a table index on the display_name column to speed up the \"player search\" query:\n\nHere is the full query:\n\nWe include deleted players in the ranking. They'll just show up as something like \"Deleted User 23\".\n\nWe already discussed the 'Past games' page in the Games section. All the filters have an \"all\" option which is the default:\n\nTime control\n\nBoard size: selector with (small / medium / large / all). Games are grouped by board size according to width x height: \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares).\n\nELO: a numerical range (missing from the 'Past games' page screenshot)\n\nTime period: a date range (missing from the 'Past games' page screenshot)\n\nTwo player filters: filling one gives you all games with that player. Filling both gives you all games including both players.\n\nWe also need pagination: we'll show up to 100 games per page and let the user navigate to the next/previous 100-block.\n\nTo fill in each row, we need the following data: variant, rated, time control, board width and height, names and ELOs of all the involved players (could be more than 2 depending on the variant), the number of moves, and the date when the game was played. We also need the game id in case the user wants to watch the game.\n\nWhen the user selects a game to watch, we need to get the moves and configuration parameters, as well as the players' chosen pawn colors and shapes, which we can pull from the user_settings table:\n\nUser settings\n\nWhen the user goes to the 'Settings' page, they can change the following settings, and this is stored in the DB:\n\nDisplay name\n\nBoard theme\n\nCat pawn shape\n\nMouse pawn shape\n\n... (one selector for each pawn type that appears in any variant)\n\nDefault variant\n\nDefault time control\n\nDefault rated status\n\nDefault parameters for each specific variant\n\nWe pull the settings with this query:\n\nTo guarantee unique usernames, a user can only change it to a username that does not appear in the DB. We can check this with this query:\n\nWe'd also need queries to update each user settings (changes take effect immediately--there's no final \"Update\" button in the UI), but these are straightforward.\n\nFinally, if a user chooses to delete their account, we need to rename them to \"Deleted User #\" where # is the next available number among deleted users, starting from 1. We can do this with this query:\n\nThe actual user record remains in the database to maintain game history and statistics, but the user can no longer log in and their personal information is removed.\n\nThis concludes the discussion of the DB schema for the Wall Game, a series of blog posts on building a multiplayer online board game. Next, we'll deep dive into how to train an alpha-zero-like AI for the Wall Game.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-db#handling-unique-usernames",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game UI Design (+ Frontend Generators)",
      "content": "Wall Game UI Design (+ Frontend Generators)\n\nThis blog post is a design doc for the frontend of wallgame.io, a board game I'm making. However, something probably more interesting came out of it: an assessment of frontend generators' ability to one-shot a 6000-word design doc prompt. The results deeply impressed me. They are in an appendix at the bottom. Feel free to skip the design doc and check out the appendix.\n\nThis is the specification of the frontend for the Wall Game, an online strategy board game. It only specifies the logic/functionality. It is agnostic of the look.\n\nA first version of the game is already available at wallwars.net. This is a UI overhaul with the following goals:\n\nA smooth onboarding experience. It should be very clear how to navigate the site and in what order to do things.\n\nTeaching the game to new players in a structured way.\n\nExpansive solo modes so that players can have fun even if there is no one else online.\n\nImproving the user journey of inviting friends to play.\n\nSupporting game variants as a first-class feature (this was a key feature for replayability when playing with a physical board).\n\nSupporting game variants with a varying number of players.\n\nSupporting multiple bots, including custom bots to foster the \"engine dev\" community.\n\nClean interface to game data, like past games, player history, rankings, etc., by showing interlinked tables with SQL-like features like filtering.\n\nMore \"social\" features, like an in-game chat and the ability to watch live games.\n\nFrontend Overview\n\nThe site is a SPA (single page app). There are 9 main pages, all of which are accessible from the top navigation bar. If a screen is not wide enough to show all the tabs, they are collapsed as necessary into a hamburger menu icon. Tabs act as buttons to show the corresponding page. Pages are self-contained and have their own URL:\n\nIn order, the tabs are:\n\nPlay (default) - wallgame.io\n\nRanking - wallgame.io/ranking\n\nPast games - wallgame.io/past-games\n\nLive games - wallgame.io/live-games\n\nLearn - wallgame.io/learn\n\nAbout - wallgame.io/about\n\nSettings - wallgame.io/settings\n\nProfile (appears as Login if the user is not logged in) - wallgame.io/profile\n\nThe navigation bar is always visible, and the current tab is highlighted.\n\nWe'll first go over the basic concepts, then some of the basic components reused across multiple pages, and finally, we'll go over each page (out of order).\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nPlayer types: there are 5 player types in the context of a game created by a user: \"You\": the user itself. \"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.) \"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\"). \"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game. \"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nPlayer types: there are 5 player types in the context of a game created by a user:\n\n\"You\": the user itself.\n\n\"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.)\n\n\"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\").\n\n\"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game.\n\n\"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter): The user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win). The user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully. The user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter):\n\nThe user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win).\n\nThe user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully.\n\nThe user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nThis section describes specific high-level components of the UI, which are reused in various places.\n\nThis is the main component involved in playing the game.\n\nA rectangular grid of square cells, with thick margins between them (that's where the walls go).\n\nA cell may contain one or more pawns. There is no limit on how many pawns can be in the same cell.\n\nA staged or premoved pawn move is shown with an arrow. Arbitrary arrows can also be added as calculations. It should be clear which one is which.\n\nBetween every two cells adjacent vertically or horizontally, there is a space where a wall can be placed, staged, premoved, calculated, or missing.\n\nThe corner between four cells is called a \"pillar\" and is not an interactable element.\n\nPlaced walls are colored according to the color of the pawns of the player who placed them.\n\nSimilar to chess and checkers, the cells are colored alternatively, so that cells that are an even number of moves away from each other share a color. The contrast between the two colors is subtle.\n\nLike chess, rows are labeled with numbers (starting from 1 on the top) and columns are labeled with letters (starting from 'a' on the left). The first cell in each row is labeled with the corresponding row number. The first cell in each column is labeled with the corresponding column letter. The labels are subtle, taking only a corner of the cell.\n\nThe last move is highlighted so it is easy for players to see what the opponent just did.\n\nThis includes the board itself and surrounding elements for any related information and interactions:\n\nthe timers. The timer of the player to move is highlighted.\n\nthe player names and ELOs. The name of the player to move is highlighted.\n\nthe move history in standard notation, with buttons to go back and forth and buttons to go to the beginning and latest move.\n\nthe chat. The chat can have multiple \"channels\": the \"game chat\", seen by all the players but not the audience the \"team chat\", seen only by players on the same team the \"audience chat\", seen only by the audience\n\nthe \"game chat\", seen by all the players but not the audience\n\nthe \"team chat\", seen only by players on the same team\n\nthe \"audience chat\", seen only by the audience\n\nan indicator of whose turn it is\n\nonline indicators for each player (if a player does not have the game tab/app active, it shows as offline)\n\nmenus for out-of-game interactions: \"resign\", \"offer draw\", \"propose take back\", \"give time (1 min)\", \"rematch\"\n\na button to toggle sounds\n\ncontextual information: the game variant and parameters the time control rated status the match score whose turn it is the player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\") after the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\nthe game variant and parameters\n\nthe time control\n\nrated status\n\nthe match score\n\nwhose turn it is\n\nthe player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\")\n\nafter the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\na button to see/copy the game's replay notation and standard notation\n\nGame configuration panel\n\nThis includes all the configuration options for a game.\n\ntime control: a selector with the options \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\".\n\nrated status: yes/no. If the player is not logged in, the 'rated status' is set to \"no\" and grayed out. There should be an informational text that says that the user needs to be logged in to play rated games.\n\nvariant: a selector of supported variants.\n\nadditional parameters that depend on the variant. These parameters appear in a container, and the container changes depending on the variant.\n\nFor example, for the standard variant:\n\nBoard width: number. Default: 8\n\nBoard height: number. Default: 8\n\nPlayer configuration\n\nA little component that lets you configure how a player in a game will move. It consists of a selector with a few options, each of which has an informational text.\n\n\"You\": \"You'll make the moves.\"\n\n\"Friend\": \"You'll get a link to share with a friend to join the game.\"\n\n\"Matched user\": \"You'll be paired with a random player with compatible settings and similar rating.\"\n\n\"Easy Bot\": \"You'll play against an easy AI bot.\"\n\n\"Medium Bot\": \"You'll play against a medium AI bot.\"\n\n\"Hard Bot\": \"You'll play against a hard AI bot.\"\n\n\"Custom bot\": \"You'll get an access token so that you can connect your own bot. See here for more information.\" The text links to a blog post explaining how to make a custom bot and connect it to the game using the token.\n\nThere is no default. It depends on the context.\n\nGame setup page\n\nThis page has its own URL: wallgame.io/game-setup.\n\nIt has two sections:\n\nCreate game\n\nCreate game\n\nThis part has the following elements:\n\nA button: \"Create game\".\n\nA player configuration component for each player (which depends on the variant, as set in #4). The selectors are labeled \"Player 1\", \"Player 2\", and so on. The default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe selectors are labeled \"Player 1\", \"Player 2\", and so on.\n\nThe default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe game configuration panel. Choosing a variant with more than 2 players will affect the number of player configuration components in #2.\n\nThis part has the following elements:\n\nA heading \"Join game\"\n\nA table showing games from other players that are in the \"matching stage\" and waiting for someone to join.\n\nThe table has the following columns:\n\nJoin: a button which, when clicked, joins the game.\n\nRated: yes/no.\n\nTime control: a string formatted like \"blitz (3+2)\"\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height).\n\nPlayer: a string formatted like \"name1 (1200)\". The numbers in parentheses is the rating. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (XXX) & name2 (YYY) vs name3 (ZZZ)\".\n\nThe rows are ordered by ELO closest to the current user's ELO. If the user chose a variant, rated status, time control, or board size in the game configuration panel, rows matching those settings are prioritized. Games that have been in \"matching stage\" for longer are also prioritized.\n\nThe parameterized URL is wallgame.io/game/game-id\n\nThe game page shows a game, identified with a given game ID in the URL. The game could be in the \"matching stage\", ongoing, or finished (a past game) The URL can be shared to join the game (if it is in the \"matching stage\"), to spectate it live (if it is ongoing) or watch it as a past game (if it is finished).\n\nThe game page has one main component: the board view.\n\nDepending on the context, it could contain other elements. See, e.g., the case of the \"Solo campaign\" puzzles, which contain an additional explanation text. So far, this seems to be the only exception.\n\nMatching stage panel\n\nWhen a user creates a game from wallgame.io/game-setup, a game ID is generated and they are taken to the game page with that game ID.\n\nHowever, it is possible that not all players are ready. For instance, if one of the player types is \"friend\", the game cannot start until the friend joins the game.\n\nIf not all players are ready, a \"matching stage\" panel component is shown as a modal over a faded out version of the game page.\n\nThe modal has a title: \"Waiting for players\". It contains one row for each player. Each row contains:\n\nThe player type (e.g., \"You\", \"Friend\", \"Easy Bot\", \"Medium Bot\", \"Hard Bot\", \"Custom Bot\", \"Matched player\")\n\nAn indication of whether the player is ready.\n\nInstructions for how that player should join the game If the player is \"You\", the player is automatically ready. If the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard. If the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready. If the player is \"Custom Bot\", the instructions include an access token for a custom bot. If the player is \"Matched player\", the instructions are to wait for someone to join.\n\nIf the player is \"You\", the player is automatically ready.\n\nIf the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard.\n\nIf the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready.\n\nIf the player is \"Custom Bot\", the instructions include an access token for a custom bot.\n\nIf the player is \"Matched player\", the instructions are to wait for someone to join.\n\nA button to abort the game and return to the previous page.\n\nIf a player joins a game but there are other players that are not ready (in the case of variants with more than 2 players), they will also see the matching stage panel.\n\nTab 7: Settings\n\nSettings have three sections:\n\nUser settings\n\nVisual style\n\nDefault game parameters\n\nFor sections 2 and 3, there should be an information box indicating that if the user is not logged in, they are saved as local cookies in the web browser. If they are logged in, the settings are saved to their account instead.\n\n1. User settings\n\nThis has one field:\n\nDisplay name (text field)\n\nIt behaves a bit differently depending on if the user is logged in.\n\nFor logged in users, the display name shows their current name and it is editable.\n\nThere should be a button next to the \"display name\" text field that says \"Change if available\" and an informational text that says \"Names must be unique across the site (case insensitive). You can only switch to another name not already in use.\" The button should be grayed out if the text field matches their current name. Names including \"guest\" or \"deleted\" or \"bot\" are not allowed. If the user tries to change to such a name, it should be explained to them.\n\nIf the user is not logged in, the display name should be grayed out and fixed as: \"Guest\"\n\nThere should also be an indication that the user needs to be logged in to change their display name, with a button to the Profile page.\n\n2. Visual style\n\nDark theme: on/off. Default: on\n\nBoard theme: selector. Default: \"classic\".\n\nPawn color: selector. Default: default.\n\nCat pawn: selector.\n\nMouse pawn: selector.\n\n... (one selector for each pawn type that appears in any variant)\n\nThe pawn selectors are between icons/small images.\n\n3. Default game parameters.\n\nThis is the game configuration panel component.\n\nA text says, \"When setting up a game, these parameters will be used as default.\"\n\nTab 6: About\n\nThis contains short informational text. The text can be something like this:\n\n\"Wall Game is a board game about building walls and outsmarting your opponents. It is inspired by Quoridor (wiki link) and Blockade (wiki link). Basic instructions about navigating the website (where to find the rules etc). Created by Nil Mamano (link). For more, you can read the blog (link).\"\n\nTab 8: Profile\n\nThis page looks different depending on whether the user is logged in or not.\n\nNot logged in\n\nThe tab appears as \"Login\".\n\nThe page shows two main buttons: log in and sign up\n\nIt includes a bit of text: \"Log in or sign up to choose a name, play rated games, and see your game history.\"\n\nFor the login and sign up flows, the user is redirected to an external auth service, so they are not part of this UI.\n\nThe tab appears as \"Profile\".\n\nIt shows the user display name and rating at the top, followed by a series of buttons grouped in two groups:\n\nPast Games: takes you to the Past Games tab but with the user's name already set as filter.\n\nRanking: takes you to the Ranking tab but with the user's name already set as filter.\n\nSettings: takes you to the settings page.\n\nDelete account\n\nThe delete account button shows a confirmation dialog: \"Your email will be deleted from the DB and all games you played will appear as 'Deleted User' and you won't be able to play again with this account. Are you sure?\"\n\nTab 3: Past games\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default. Filters are added as query parameters to the URL, so they can be shared.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nPlayer: text field (empty field acts as \"all\")\n\nPlayer: text field (empty field acts as \"all\").\n\nTime period: a date range\n\nThe two player fields serve the same purpose. Filling only one gives you all games with that player. Filling both gives you all games including both players.\n\nGames with fewer than 2 moves are filtered out. Games aborted during the \"matching stage\" are not even stored.\n\nThe rows are ordered by date. The order cannot be changed.\n\nWatch: a button which, when clicked, takes you to see the past game.\n\nVariant: clicking on a variant sets the variant filter.\n\nRated: yes/no. Clicking on a rating sets the rated status filter.\n\nTime control: a string formatted like \"blitz (3+2)\". Clicking on a time control sets the time control filter.\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height). Clicking on a board size sets the board size filter.\n\nPlayers: a string formatted like \"name1 (1200) vs name2 (1234)\". The numbers in parentheses are the ratings at the start of the game. Clicking on a name sets the first player filter. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (1200) & name2 (1234) vs name3 (1234) & name4 (1234)\". Clicking on the \"vs\" sets both player filters, with slight tweaks depending on the variant.\n\nMoves: a number. The number of moves of the game.\n\nViews: a number. The number of views the game got.\n\ndate: date type. When the game was played.\n\nThe name of the winning player is highlighted. Draws are also indicated.\n\nPast game view\n\nWhen a user clicks the \"Watch\" button for a past game, they are taken to the \"game page\" for that game (e.g., wallgame.io/game/2ei3nd43).\n\nThe final position is shown by default.\n\nThe chat is grayed out with a message that says \"Chat is not preserved.\"\n\nTab 4: Live games\n\nSimilar to the \"Past games\" page, this page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nThe formatting of the columns is the same as for \"Past Games\".\n\nWatch: a button that takes you to spectate the game in real time.\n\nViewers: a number.\n\nVariant: see \"Past games\" table.\n\nRated: see \"Past games\" table.\n\nTime control: see \"Past games\" table.\n\nBoard size: see \"Past games\" table.\n\nPlayers: see \"Past games\" table.\n\nMoves: see \"Past games\" table.\n\nThe rows are sorted by viewers first, by max ELO second.\n\nWhen a game ends, the number of spectators becomes the initial number of views in the past games table.\n\nLive game view\n\nWhen a user clicks the \"Watch\" button for a live game, they are taken to the \"game page\" for that game (e.g., wallgame.io/live/2ei3nd43).\n\nThe latest state of the game is shown by default.\n\nAs players make moves, spectators receive and see real-time updates.\n\nSpectators see the \"Spectator chat\", which is different than the ones the players see.\n\nTab 2: Ranking\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe filters do not have an \"all\" option.\n\nVariant: default: standard\n\nTime control: default: rapid\n\nPlayer: text field. Default: empty. The player filter acts more like a search box. If filled and the player exists, it only shows the row corresponding to that player and a few rows before and after. If the player does not exist, it shows nothing.\n\nRank: number starting at 1\n\nPlayer: the display name. It updates whenever players change their names delete their accounts.\n\nRating: the ELO rating. These are numbers sorted in decreasing order.\n\nPeak rating: the max ELO rating that player has ever had.\n\nRecord: a string formatted like \"10-4\" indicating the number of points the player got and lost across all its games.\n\nFirst game: a date.\n\nLast game: a date.\n\nClicking anywhere on a row takes you to the \"Past games\" page with the variant, time control, and player filters set. The \"rated\" filter is also set to \"yes\".\n\nTab 5: Learn\n\nThis page contains only static content, in four sections:\n\nRules (standard)\n\nNotation (standard)\n\nLessons (standard)\n\nAll the sections may contain images.\n\nSections can be collapsed.\n\nThis contains a couple of paragraphs explaining the rules of the \"standard\" variant.\n\nIt ends with: \"You can now start the solo campaign.\", with a link to the play tab (wallgame.io).\n\nThis contains a couple of paragraphs explaining the standard notation. This is useful since it appears in the game history element of the \"board view\" component.\n\nThis contains a bullet point list of links to blog posts explaining strategic and tactical ideas. More lessons can be added over time.\n\nThis contains definitions and special rules for all the supported variants.\n\nTab 1: Play\n\nThis is the 'landing' page.\n\nIts main purpose is to easily access the 6 game modes:\n\nSolo campaign\n\nStudy board\n\nPlay with others\n\nInvite friend\n\nIt contains three sections:\n\nSingle-player fun\n\nPlay with others\n\nGame showcase\n\nThe first two contain various buttons to go to the various game modes. The final one is just decorative. It's not there because it's related to the \"Play\" theme, but because it's the landing page.\n\nSingle-player fun\n\nThis section contains the following buttons:\n\nSolo campaign. There is an annotation that says \"Start here!\"\n\nStudy board\n\nPlay with others\n\nThis section contains the following buttons:\n\nFind others\n\nInvite friend\n\nGame showcase\n\nThis section shows a board and autoplays random past games, at high speed (2 moves per second). Above the board, a text says: \"Game showcase: name1 (1200) vs name2 (1234) (DATE)\", with the players and date updating as the game changes. There should also be a button to stop the autoplay.\n\nClicking on it takes you to the \"game page\" to watch the game, analogous to the \"Past games\" page. The only difference is that the game starts at the position that last played automatically in the game showcase.\n\nGame mode 2: Puzzles\n\nThe URL is wallgame.io/puzzles\n\nThe puzzles page has a list of puzzles.\n\nEach puzzle has:\n\nplay button\n\ndifficulty rating\n\ncompleted: yes/no. An indication of whether the user already solved it\n\nIf the user is not logged in, the 'completed' status is grayed out. There should be an information box indicating that the user should log in to save their completion status.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/puzzles/1, where 1 is the puzzle number. This makes it so that the user can share a puzzle by sharing the route.\n\nGame mode 1: Solo campaign\n\nThe URL is wallgame.io/solo-campaign\n\nThe solo campaign menu consists of a list of puzzles just like the menu for puzzles.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/solo-campaign/1, where 1 is the puzzle number.\n\nUnlike in normal puzzles, in solo campaign puzzles:\n\nThere is a text above the board view indicating what to do to win.\n\nThe game is usually played until the end.\n\nGame mode 3: Play vs AI\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Easy Bot\".\n\nGame mode 5: Play with others\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Matched user\".\n\nGame mode 6: Invite friend\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Friend\".\n\nGame mode 4: Study board\n\nThis takes you to a special instance of the \"game page\" with route wallgame.io/study-board.\n\nThe design for the study board page is work in progress.\n\nFinal thoughts\n\nI usually figure out the shape of things as I build them, like I did for wallwars.net, instead of writing a long design doc upfront. However:\n\nTo justify a full rewrite, I wanted to make sure the new design would accomplish the improvements that I wanted to see on the original site (see the list at the beginning of this post).\n\nAI-assisted coding has made all coding easier, but it has improved new code generation more than it has improved refactoring. For me, this shifted the tradeoff to the point where it seemed worth it to try to preempt as many direction shifts as possible.\n\nIn any case, now that I have this doc, I think it's a good opportunity to test out the various frontend generators (lovable and company) and see what they spit out. I probably won't use any of them directly, but they should give me good ideas for the styling.\n\nI fed this whole blog post to v0.dev (free tier). The prompt was \"Create mocks for the attached design doc.\" + this blog post, which is about 6000 words (a 33kB attachment).\n\nApart from putting the files in the wrong directory, it one-shotted the whole app with great prompt adherence and, in my opinion, great taste to fill in the gaps (recall that this design doc says basically nothing about styling).\n\nYou can see the results below (I skipped the less interesting pages).\n\nI emphasize that I did not have to break down the prompt into smaller chunks, as I'm so used to with tools like Cursor or basically anything LLM-based. I did not have to go screen by screen. It generated about 20 files and 3000 lines of next.js, with all navigation working as expected and mock data. I did not have to carefully craft a prompt on top of the design doc (though you can argue that this blog post is a great prompt). As someone who uses vibe coding regularly, this truly impressed me.\n\nI tried other frontend generators with the same prompt. lovable.dev did OK with prompt adherence (some pages did not work), but it did not have the same taste as v0.dev. It looks like a generic corporate site. Lovable's board component also looks messed up.\n\nbolt.new had great prompt adherence, about the same as v0.dev, but the site looked generic like lovable's (and the board was also messed up). V0 had the best use of space.\n\nOther tools I tried had a prompt length limit, so I didn't bother.\n\nIn the end, I just went back to v0.dev and used the rest of my daily free credits to ask it for different color themes.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-ui?category=wallgame#appendix",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Choosing a tech stack in 2025",
      "content": "Choosing a tech stack in 2025\n\nI'm rebuilding one of my side projects from scratch, the Wall Game. The first version is playable at wallwars.net.\n\nOne of the first choices for a new project is the tech stack, so this blog post will go over my choice for this project and the thought process behind it.\n\nRequirements\n\nTo choose a tech stack, we should start from the features we need.\n\nIn this case, the easiest way to think about the feature set is that we are building a Lichess clone (lichess.org), except for a different board game.\n\nI'll list here the main features and their implications about the tech we need.\n\nReal-time turn-based multiplayer games. Implications: This means using websockets, the main networking protocol for this use case. This also means that \"serverless\" backends are out of the question.\n\nImplications: This means using websockets, the main networking protocol for this use case. This also means that \"serverless\" backends are out of the question.\n\nMatchmaking: people can broadcast if they are looking for someone to play, and everyone online should be able to see it. Implications: This requires a broadcasting mechanism. Websockets also handle this use case.\n\nImplications: This requires a broadcasting mechanism. Websockets also handle this use case.\n\nHuman-level bots running Deep WallWars, an Alpha-Zero-like AI. Implications: The AI requires a beefy CPU (for the MCTS) and GPU (for ML model inferences) per move. This means that either the server needs access to GPUs (which would be very expensive in a cloud provider) or, the AI needs to be self-hosted. The current version of the game has a C++, minimax-based bot that runs on the frontend. This requires transpiling C++ to WASM, which hasn't worked well in every browser/device. After dealing with that, I think it's not worth it, so this time I'm only considering bots that run on the backend.\n\nImplications: The AI requires a beefy CPU (for the MCTS) and GPU (for ML model inferences) per move. This means that either the server needs access to GPUs (which would be very expensive in a cloud provider) or, the AI needs to be self-hosted.\n\nThe current version of the game has a C++, minimax-based bot that runs on the frontend. This requires transpiling C++ to WASM, which hasn't worked well in every browser/device. After dealing with that, I think it's not worth it, so this time I'm only considering bots that run on the backend.\n\nUser accounts. We want to handle a mix of non-logged-in and logged-in players seamlessly. Ideally, we want to support something like Google log-in. Implications: This means either implementing authorization from scratch (this would be my first time) or using an auth provider.\n\nIdeally, we want to support something like Google log-in.\n\nImplications: This means either implementing authorization from scratch (this would be my first time) or using an auth provider.\n\nSatisfying visuals and animations. Implications: We need a modern UI library that supports animations without requiring being an expert (which I'm not). As much as I love Lichess, I want the game to have more dynamic visuals and animations.\n\nImplications: We need a modern UI library that supports animations without requiring being an expert (which I'm not). As much as I love Lichess, I want the game to have more dynamic visuals and animations.\n\nPhone and tablet support. A native phone app may come later, but for now I want the website to work well on every device. Implications: A mature UI library that supports responsive design.\n\nImplications: A mature UI library that supports responsive design.\n\nDB for things like finding recent games, your game history, leaderboards, etc. Implications: We don't have any need for NoSQL features. A SQL DB should do just fine.\n\nImplications: We don't have any need for NoSQL features. A SQL DB should do just fine.\n\nAllowing users to provide their own AIs. Implications: We will have to provide a game client as a separate repo which people can clone to run their own AI locally and connect to the site. I considered the option of letting users upload their AI code to the backend, but I don't want to deal with the server costs or security concerns.\n\nImplications: We will have to provide a game client as a separate repo which people can clone to run their own AI locally and connect to the site.\n\nI considered the option of letting users upload their AI code to the backend, but I don't want to deal with the server costs or security concerns.\n\nA blog for dev journaling--you are probably reading it. Implications: An SSG (static-site generator) is a good fit for this.\n\nImplications: An SSG (static-site generator) is a good fit for this.\n\nA community space to discuss the game. Implications: I already set up a discord server for the first version of the game: discord.gg/6XFsZHGZ. :)\n\nImplications: I already set up a discord server for the first version of the game: discord.gg/6XFsZHGZ. :)\n\nThe following features have no additional implications on the tech stack, as far as I can tell, meaning that any stack should be able to handle them more or less equally well:\n\nSingle player modes: playing vs bots, puzzles, and analysis board.\n\nELO system and rating-based matchmaking.\n\nIn-game chat (this is handled by websockets).\n\nSpectating on-going games (this is handled by websocket broadcasting).\n\nSound effects and music.\n\nKeyboard support.\n\nModel training for the AI. This will be an offline process based on PyTorch, independent of the app's tech stack.\n\nPuzzle generation. The puzzles will be generated and uploaded to the DB as part of an offline process.\n\nNon-functional requirements\n\nThis app will be heavy on business logic, both in the frontend and the backend. Implication: It would be great if the stack used the same language for frontend and backend to allow us to share business-logic code between them. However, LLMs have made code translation pretty trivial, so this is not a hard requirement.\n\nImplication: It would be great if the stack used the same language for frontend and backend to allow us to share business-logic code between them. However, LLMs have made code translation pretty trivial, so this is not a hard requirement.\n\nUsually, apps have minimal business logic in the frontend, but for a real-time game it is not ideal. For instance:\n\nWe want move legality checks to be instantaneous: if the user hovers over a wall slot, we want to indicate to them if they can place it or not, and this requires bridge-detection graph algorithms. We don't want to add server lag for such things.\n\nPremoves are frontend-only and require graph algorithms like bridge detection to do properly.\n\nSmall storage needs (compared to a media-centered app). All games should be stored but they shouldn't take much space. We don't have to deal with heavy data like images or video. Implications: We don't need some kind of CDN.\n\nImplications: We don't need some kind of CDN.\n\nTests. Implications: I like to keep testing infrastructure to a minimum, so I won't add testing framework as a requirement.\n\nImplications: I like to keep testing infrastructure to a minimum, so I won't add testing framework as a requirement.\n\nSafe rollouts. Implications: We need a cloud provider for the backend that supports CI/CD and a dev environment.\n\nImplications: We need a cloud provider for the backend that supports CI/CD and a dev environment.\n\nLow budget. Since there is no plan to monetize the game, at least initially, we want to keep costs low. Implications: we will try to leverage free-tier plans where possible for cloud services (DB, auth, etc.).\n\nImplications: we will try to leverage free-tier plans where possible for cloud services (DB, auth, etc.).\n\nLLM-friendly stack. I want to be able to do CHOP (chat-oriented programming). Implications: This means that popular frameworks and tools are preferred. Maybe more importantly, stable frameworks are preferred. (It is a pain to work with an LLM with a knowledge cutoff date earlier than the version of a framework you are using.)\n\nImplications: This means that popular frameworks and tools are preferred. Maybe more importantly, stable frameworks are preferred. (It is a pain to work with an LLM with a knowledge cutoff date earlier than the version of a framework you are using.)\n\nBig and stable (i.e., boring) ecosystem. We don't want simple integrations to become an adventure.\n\nMinimize dependencies.\n\nwallwars.net was my first project using npm and I was not mindful to vet dependencies, and it's been a drag to keep them updated. For instance, I used a \"React wrapper\" around Material UI which was not updated when a new React version came out, and it was a pain to migrate out of it (I'm sure js devs can relate). The new philosophy will be to avoid dependencies as much as possible.\n\nAvoid framework and hosting provider lock in.\n\nAt some point, Heroku suddenly removed the free tier that wallwars.net was on. So, the new philosophy will be to try to avoid getting locked in into specific tech or services. Here are some implications of this goal:\n\nThis pushes me away from next.js because of how it subtly and not so subtly pushes you into hosting on Vercel.\n\nI'd rather avoid ORMs (Object-Relational Mappers), or, if I do use one, it should be a thin wrapper around SQL and not use features specific to that ORM.\n\nRolling out my own authentication becomes a lot more appealing, as this can be particularly hard to migrate.\n\nAvoid the complexity of microservices. Exception: it seems like a good idea to have a separate service for computing bot moves, so the main service can stay responsive by avoiding compute-heavy tasks.\n\nException: it seems like a good idea to have a separate service for computing bot moves, so the main service can stay responsive by avoiding compute-heavy tasks.\n\nAvoid slow languages. I'd be concerned about running the game logic in a language like Python.\n\nI'd be concerned about running the game logic in a language like Python.\n\nNon-MVP features\n\nAll of these probably make sense at some point, but that's a problem for future me. The initial scope is just to make the web experience great.\n\nMobile app.\n\nMailing list (to announce things like tournaments).\n\nIn-game purchases.\n\nSubjective preferences\n\nAfter the requirements, a less important factor is the developer's (i.e., my) experience and preferences.\n\nI favor plain old procedural programming, with strong typing. I try to keep as much logic as possible in pure functions, but I don't like when functional languages are forcefully strict about it (e.g., Haskell). I'm allergic to OOP.\n\nI'd probably rank the languages I've used by preference like this: Go > TS > Python > JS > C++ > Java. I like languages a bit on the lower level, so the \"modern C++ replacements\" like Rust and Zig seem appealing if I were to use a new language.\n\nFor this project, I'm not counting \"learning new things\" as a goal. Otherwise, I might prioritize something like Rust for the backend.\n\nAs you can see, the goals are often contradictory. For instance:\n\nDjango is a very stable and mature framework, which is a plus, but it is Python-based, and I want a fast language.\n\nWanting a stable ecosystem would mean avoiding the mess that is the JS ecosystem, but using TypeScript for both the frontend and backend seems like the easiest way of reusing business logic code between them.\n\nWanting a type-safe and fast language points to Rust, but I'm not sure how good LLM completions would be compared to, e.g., TS.\n\nEvery tech has trade-offs, and I'm sure each dev would reach a different conclusion about the right stack based on these requirements. What would you use?\n\nBefore we get to my choice, I'll go over the Lichess stack and the current wallwars.net stack.\n\nLichess stack\n\nLichess is a free open-source online chess platform with a significant share of online chess, only second to chess.com. The Lichess case study should be very interesting to any solo builders: it was built by basically one person, Thibault Duplessis, and it has hosted over 6 billion games. I highly recommend the video, \"How 1 Software Engineer Outperforms 138 - Lichess Case Study\" by Tom Delalande.\n\nLuckily, Thibault has given talks and written about the Lichess stack and the thought process behind it (see his blog and his Reddit AMA).\n\nThibault's philosophy is based on simplicity and minimalism, prioritizing cleaning up tech debt over adding new features. Here's an excerpt from We don't want all the features:\n\nLines of code are not valuable. They are a cost, that is not paid while writing them, but while maintaining them. Sometimes years later. And they pile up.\n\nLines of code are not valuable. They are a cost, that is not paid while writing them, but while maintaining them. Sometimes years later. And they pile up.\n\nHere is the stack:\n\nBidirectional communication: WebSocket\n\nFrontend: Type: SPA Language: TypeScript Framework: Snabbdom CSS framework: Sass\n\nLanguage: TypeScript\n\nFramework: Snabbdom\n\nCSS framework: Sass\n\nBackend: Type: \"Monolith with satellites\" Language: Scala (+ other languages like Rust for special tasks) Framework: Play Framework Ecosystem: Java/JVM Database: MongoDB DB cache: Redis\n\nType: \"Monolith with satellites\"\n\nLanguage: Scala (+ other languages like Rust for special tasks)\n\nFramework: Play Framework\n\nEcosystem: Java/JVM\n\nDatabase: MongoDB\n\nDB cache: Redis\n\nDeployment: Backend host: self-hosted Authentication service: Custom Database host: MongoDB Atlas\n\nBackend host: self-hosted\n\nAuthentication service: Custom\n\nDatabase host: MongoDB Atlas\n\nPhone app: Flutter (Android and iOS)\n\nComments (mostly based on Tom Delalande's video):\n\nScala: Thibault chose it because it is functional, high-level, and, even though it is not popular, it can leverage the JVM ecosystem. That last point is why he chose it over other functional languages like Haskell.\n\nPlay Framework: Thibault says the framework sped up the initial development, but now he would prefer to ditch it and use \"smaller independent libraries that we can swap as needed\" for things like HTTP, routing, JSON, etc.\n\nMongoDB: Thibault would now probably go for PostgreSQL because it's open source and cheaper.\n\nSnabbdom: this is a minimalistic virtual DOM library. Thibault chose it because of its simplicity compared to something like React.\n\nSass: Thibault said \"Sass is annoying, but that's just because CSS is annoying.\"\n\nOne reason why I'm not considering Lichess' stack is that I want the website to have an engaging look and feel, complete with animations and cool visual effects. Thibault said on Reddit:\n\nI'm a programmer, not a designer, that's why it's always been quite bland, with no images and very little colors. I made up for my lack of UI skills by focusing on UX (user experience) and I think it paid out. There's lots to improve, though...\n\nI'm a programmer, not a designer, that's why it's always been quite bland, with no images and very little colors. I made up for my lack of UI skills by focusing on UX (user experience) and I think it paid out. There's lots to improve, though...\n\nwallwars.net stack\n\nThe current site (wallwars.net) was built in 2019. It is based on the popular web stack at the time: MERN (MongoDB, Express, React, Node.js). I actually chose the stack first, because my goal was to learn full-stack development, and then chose the Wall Game as the project to learn on.\n\nContainerization: None\n\nLanguage: JS, latter ported to TypeScript (frontend and backend)\n\nPackage manager: npm\n\nBidirectional communication: Websocket\n\nFrontend: Type: SPA Build tool: the default for CRA (Create React App) Framework: React CSS framework: None, just plain CSS Component library: Material UI Router: React Router AI: C++17 -> LLVM -> WASM (running in the browser)\n\nBuild tool: the default for CRA (Create React App)\n\nFramework: React\n\nCSS framework: None, just plain CSS\n\nComponent library: Material UI\n\nRouter: React Router\n\nAI: C++17 -> LLVM -> WASM (running in the browser)\n\nBackend: Runtime: Node.js Web server: Express Database: MongoDB DB wrapper: Mongoose\n\nRuntime: Node.js\n\nWeb server: Express\n\nDatabase: MongoDB\n\nDB wrapper: Mongoose\n\nDeployment: Backend host: Heroku Authentication service: Auth0 Database host: MongoDB Atlas\n\nBackend host: Heroku\n\nAuthentication service: Auth0\n\nDatabase host: MongoDB Atlas\n\nA lot of the stack is considered fairly outdated now. You can see the replacements in the next section.\n\nTwo special callouts for things I want to change:\n\nMongoDB: NoSQL was a mistake for this application. Everything I need from the DB is easily expressed in SQL.\n\nHeroku: it rug-pulled the free tier, costing $5/month now.\n\nMy choice: modern JS ecosystem\n\nI decided to stick with the JS ecosystem, as it seems to be consolidating around a more stable and sane set of tools.\n\nI'll include this section of the blog post in the system prompt (e.g., \"cursor rules\") when building the game. It will provide useful context for the LLM.\n\nAs discussed in the Requirements section, the main reasons are:\n\n(My impression that) JS frontend frameworks can more easily create slick interactive UIs than other languages because they are closer to the browser. If that's incorrect, let me know!\n\nFactoring out and reusing business logic across frontend and backend.\n\nFrontend-backend communication may work better if they are implemented in the same language. E.g.: Type checking and autocomplete across API boundaries. socket.io is a JS/TS WebSocket implementation with client and server components. The fact that the two sides are built by the same team means it will probably work better out of the box.\n\nType checking and autocomplete across API boundaries.\n\nsocket.io is a JS/TS WebSocket implementation with client and server components. The fact that the two sides are built by the same team means it will probably work better out of the box.\n\nIt's popular, so I'm hoping I'll have an easier time integrating services like authentication, DBs, etc.\n\nLLM friendly-ish. The best frontend generator I know, v0.dev, outputs TS. (Though it will be annoying to deal with evolving APIs.)\n\nAn alright language I'm already familiar with, TS: it's type-safe(ish), fast(ish), and has good DX(ish).\n\nMaybe in the future, the react frontend can become the basis for react native mobile apps.\n\nI used the Youtube video, \"The React, Bun & Hono Tutorial 2024 - Drizzle, Kinde, Tanstack, Tailwind, TypeScript, RPC, & more\" by Sam Meech-Ward as a baseline for the stack. I highly recommend this video!\n\nI found Sam's choices and explanations reasonable and clear, so I didn't change much and didn't do much additional research beyond that. (Any bad choices will be found by the tried-and-true FAFO method.)\n\nType: Monorepo\n\nContainerization: Docker\n\nLanguage: TypeScript (both frontend and backend)\n\nPackage manager: Bun (both frontend and backend)\n\nBidirectional communication: Socket.io\n\nFrontend: Type: SPA (single-page application with client-side rendering) Build tool: Vite Framework: React CSS framework: Tailwind Component library: Shadcn/ui Router: TanStack Router\n\nType: SPA (single-page application with client-side rendering)\n\nBuild tool: Vite\n\nFramework: React\n\nCSS framework: Tailwind\n\nComponent library: Shadcn/ui\n\nRouter: TanStack Router\n\nBackend: Type: Monolith with an external service for bot moves Runtime: Bun Web server: Hono Database: PostgreSQL ORM: Drizzle Bot service: some minimalistic web server (TBD) running the bot (C++, CUDA & TensorRT for inference).\n\nType: Monolith with an external service for bot moves\n\nRuntime: Bun\n\nWeb server: Hono\n\nDatabase: PostgreSQL\n\nORM: Drizzle\n\nBot service: some minimalistic web server (TBD) running the bot (C++, CUDA & TensorRT for inference).\n\nDeployment: Backend host: Fly.io (with self-hosting for the bot service) Authentication service: Kinde Database host: Neon\n\nBackend host: Fly.io (with self-hosting for the bot service)\n\nAuthentication service: Kinde\n\nDatabase host: Neon\n\nDocker should help with things like migrating hosting providers if necessary.\n\nVite is a modern alternative to CRA that covers a lot of functionality, reducing dependencies. For local development, it allows hot reloading/HMR and running TS and JSX code natively. For production, it \"builds\" the frontend (removing TS and JSX, tree shaking, bundling, minification). Vite also allows importing node modules directly in the frontend, which may be useful for sharing code between the frontend and backend.\n\nBun acts as both a package manager and a runtime, replacing both npm and Node. Deno would also work.\n\nInstead of using an SSG like 11ty (eleventy) for the blog, I'm thinking of just using my personal blog, but with a post filter to include only posts related to the game: nilmamano.com/blog/category/wallgame.\n\nHono seems to be recommended over Express because it is more lightweight (it is built directly on top of browser standards, without additional dependencies), at the cost of less available middleware. It has a frontend client which can import the API types, adding type checking between the frontend and backend (in both directions).\n\nDrizzle adds type safety to the database layer. I'm not interested in ORM abstractions/features beyond that, but Drizzle can be used as a thin wrapper around SQL queries.\n\nTanstack Router adds type safety over the normal React Router. It also does file-based routing (à la next.js) instead of code-based routing.\n\nFly.io has a usage-based plan, which means that, if nobody is playing, I don't pay anything. Details: fly.io/pricing.\n\nKinde has a free plan with up to 10500 MAU (monthly active users). After that, it increases steeply. I decided to use an authentication provider to move faster at the start. I may regret this.\n\nNeon has a free plan with only 0.5GB of storage. After that, it is $19/month for 10GB. This seems borderline unacceptable, so I'm happy to hear any suggestions. Maybe Supabase?\n\nRequest-response flow diagram\n\nReact Query (also known as Tanstack Query) is an optional dependency--we could use a raw useEffect hook to fetch data. But it seems like a helpful wrapper around it for handling the data fetching lifecycle of API requests (caching, authentication, loading states, errors).\n\nZod is another optional dependency. Together with Hono's compile-time type checking, it adds defense in depth in ensuring frontend and backend types match. It makes it easier to add runtime validations on data received by the backend. I decided to add it because I hope it will surface tricky bugs earlier. Zod can also be used to validate data sent from the backend to the frontend, but since we have full control over backend responses, compile-time type checking is probably enough.\n\nThe steps for WebSocket messages would be similar.\n\nLocal development with Vite Server Proxy\n\nThis setup is explained by Sam in the video linked above.\n\nIn production, Vite builds the frontend, and the same server that runs the backend also serves the frontend (e.g., wallgame.io/ serves you the frontend and wallgame.io/api/ allows you to call the backend). This simplifies deployment and helps remove CORS issues.\n\nThe question then is: how do we match this situation when developing locally and make it so both frontend and backend share the same port?\n\nLocally, we don't want to use a built/bundled version of the frontend served through the backend. We want to run the frontend directly with Vite to leverage features like \"hot reloading\" and having useful error messages right in the browser during a crash. So, we can get the frontend running (usually on port 5173 for Vite) in parallel to the backend (usually on port 3000). But if we go to http://localhost:5173/api/, we won't get to the backend.\n\nTo fix that, we use Vite Server Proxy. It is a configuration that automatically redirects calls to http://localhost:5173/api/ to http://localhost:3000/api/.\n\nSo, locally, everything goes through the frontend (due to the Vite Server Proxy), while in production, everything goes through the backend. What matters is that, in both cases, the same origin serves the frontend and the backend.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/2025-stack#requirements",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Double-Edge Cut Problem",
      "content": "Double-Edge Cut Problem\n\nIn this post, we'll solve a graph problem that comes up in the Wall Game.\n\nSee also the related, but easier, Single-Edge Cut Problem.\n\nThe double-edge cut problem\n\nYou are given an undirected, unweighted graph G with V nodes and E edges, where each node is identified by an integer from 0 to V - 1. You are also given a pair of distinct nodes, s and t, in the same connected component of G.\n\nWe say a pair of edges (e1, e2) is essential if removing e1 and e2 from G disconnects s and t.\n\nImplement a data structure that takes G, s, and t at construction time, and then can answer queries of the form \"Is a given pair of edges essential?\"\n\nIn this post, we'll see how to construct such a data structure in linear time and space (O(V + E)) and answer queries in constant time.\n\nIn this graph, if s is 0 and t is 6, the essential pairs are ((0, 1), (0, 3)), ((2, 4), (3, 8)), and ((2, 4), (7, 8)).\n\nAny other pair of edges can be removed and s and t will remain in the same connected component, even if the graph itself is disconnected. For instance, if we remove (4, 5) and (5, 6), node 5 ends in its own connected component, but s and t are still connected.\n\nBrute force solution\n\nThe brute force solution is to do nothing at construction time. For each query, take each pair of edges, remove them, and then use a graph traversal to see if s and t are still connected. This takes O(E) time per query.\n\nThe brute force implementation is on github. We'll compare it against the optimized solution in the benchmark at the end.\n\nThis is the key problem behind whether a double-wall move is valid or not in the Wall Game. The board of the Wall Game may look something like the picture on the left:\n\nThe right picture is the board modeled as a graph. The cells become nodes and two adjacent nodes are connected if there is no wall between them.\n\nDuring their turn, players can build up to two walls anywhere, which is like removing two edges. The only constraint is that they cannot fully block the opponent's path to their goal (or their own). In this setting, each player forms an s-t pair with their goal, and the essential edge pairs correspond to invalid double-wall moves.\n\nIn the picture, the red player and goal are labeled s and t, and one essential pair is shown in red. There are many more essential pairs.\n\nImagine that you want to implement an engine for the Wall Game. One question you'll probably have to answer frequently is, \"Given a position, is a given move valid?\" The hardest type of move to check is a double wall move (the single-wall move case is handled by the single-edge cut problem). To answer this question efficiently, we can solve the double-edge cut problem and build one data structure for each player; we can query them to check if a double wall move disconnects any player from their goal.\n\nI got nerd-sniped by this problem in 2021, when I was coding an engine for the Wall Game (it's on github; it's in C++ but you can play against it on wallwars.net thanks to WebAssembly). The engine is based on negamax with alpha-beta pruning, and the bottleneck is generating all the valid double-wall moves from a position.\n\nThe move generation implementation from back then already uses some of the ideas we'll see in this post, like the fact that we can precompute two node-disjoint paths for each biconnected component, and two walls can only be an invalid if they are in the same biconnected component and there is one wall in each path (this will make sense later).\n\nHowever, I couldn't figure out how to handle the case of two walls in the same biconnected component and in the two precomputed paths in constant time, defaulting to a full graph traversal for that case (here).\n\nI revisited the problem in 2025 because I'm rebuilding the game. The key new insight is the construction of the path-segment graph, which we'll get to below. Something that was very helpful in this breakthrough was vibe coding a tool to visualize the various graph transformations (we'll see screenshots of it in this post).\n\nYes, I could have coded the visualization tool myself back then, but vibe coding removed the friction. Ironically, vibe coding has a rep for only being good at starting projects and then abandoning them, but here it helped me pick up an abandoned project and finish it.\n\nPreliminary definitions\n\nThe algorithm relies heavily on the concepts of articulation points and biconnected components, so we'll need the following definitions:\n\nA biconnected graph is a graph that remains connected even if any single node is removed.\n\nAn articulation point is a node whose removal increases the number of connected components. A graph is biconnected if and only if it has no articulation points.\n\nA biconnected component is a maximal biconnected subgraph.\n\nA bridge is an edge whose removal increases the number of connected components.\n\nIn a connected graph with at least two nodes, every node is in at least one biconnected component. The graph can be decomposed into what is called the block-cut tree of the graph, which has one node per biconnected component and biconnected components are connected by articulation points. For example:\n\nThis graph on the left has four articulation points: 2, 4, 6, and 7. It has six biconnected components (shown in different colors). The bridges are (7, 9), (7, 8), and (6, 12).\n\nThe block-cut tree is a tree in the sense that there cannot be a cycle of biconnected components--the cycle would collapse into a single biconnected component.\n\nHere are some additional well known properties:\n\nAn articulation point is always in more than one biconnected component. For instance, node 7 in the picture above is in three biconnected components. An edge is always in a single biconnected component.\n\nNot every edge between articulation points is a bridge. For instance, (2, 4) in the graph above is not a bridge.\n\nEvery node adjacent to a bridge is an articulation point with the exception of degree-1 nodes (like 9 in the picture above).\n\nAn edge is a bridge if and only if it is the only edge in a biconnected component.\n\nIn a biconnected component that is not a single edge, there are two node-disjoint paths between any two nodes. For instance, in the blue biconnected component, there are two paths from 2 to 4 that don't share any nodes: 2 -> 4 and 2 -> 10 -> 11 -> 4.\n\nTwo biconnected components can only have one articulation point in common. Otherwise, the two biconnected components would collapse into a single one.\n\nThere cannot be a cycle that is not fully contained in a single biconnected component. Otherwise, all the biconnected components in the cycle would collapse into a single one. (That's why the block-cut tree is called a tree.)\n\nIf a simple path (path with no repeated nodes) leaves a biconnected component, it cannot return to it (for similar reasons).\n\nReduction to biconnected graphs\n\nIn this section, we'll reduce the original problem to the case where the graph is biconnected, which we'll tackle in the next section.\n\nNote that the graph from the Wall Game may not be biconnected. It may not even be connected--see, e.g., the isolated connected component in the top-left corner above. All we are guaranteed is that each player is in the same connected component as their goal.\n\nFirst, we'll get an edge case out of the way: if s and t are neighbors and connected by a bridge, then an edge pair is essential if and only if it contains that bridge.\n\nNext, consider the case where s and t are in the same biconnected component, C (which is not just a bridge). Any edge pair where at least one edge is in another biconnected component is not essential. Thus, we can focus on edge pairs inside C. In fact, when analyzing if an edge pair in C is essential, we can completely ignore the rest of the graph (we can literally remove nodes and edges outside of C). That is because any simple path from s to t must be fully contained in C (Property 8).\n\nIf s and t are not already in the same biconnected component, any path from s to t must go through the exact same sequence of articulation points and biconnected components. Otherwise, there would be a cycle of biconnected components, which is impossible (Property 7).\n\nLet C1, C2, ..., Ck be the sequence of biconnected components that any s-t path must go through. In fact, not only is the sequence of biconnected components fixed, but also the entry and exit nodes of each biconnected component. The entry and exit nodes must be an articulation point, except for C1, where the entry node is s, and Ck, where the exit node is t. This is because there cannot be two articulation points from Ci to Ci+1 (Property 6).\n\nAmong the biconnected components between s and t, there may be one or more consisting of a single edge (i.e., a bridge). Removing that bridge disconnects s and t by itself, so any edge pair containing it is automatically essential.\n\nAside from the specific case of bridge-only biconnected components, there is no way to disconnect s and t by removing two edges from different biconnected components.\n\nWhat that means is that we can tackle each biconnected component C1, C2, ..., Ck independently, and then combine the results.\n\nWe can start by finding the biconnected components of the graph and any s-t path. From there, we can decompose the input graph into C1, C2, ..., Ck, and solve the problem for each of them. Instead of s and t, for each biconnected component, we use the path's entry and exit nodes as the new s and t.\n\nThis all can be done in linear time, and allows us to reduce the general case to a number of instances of the biconnected case, all of which combined have an equal or smaller size than the original graph.\n\nNext, we'll focus exclusively on the special case where the input graph is biconnected.\n\nBiconnected graphs\n\nIn this section, we assume that G is biconnected.\n\nOne obstacle we'll need to overcome is that we cannot possibly store every essential pair in our data structure given the time and space constraints. The worst case for the number of essential pairs in a biconnected graph is about (V^2)/4, which happens when the graph forms a single cycle, and s and t are as far apart as possible in the cycle, with (V - 2)/2 edges between them on each side. In this case, each edge on one side of the cycle forms an essential pair with each edge on the other side of the cycle, for a total of ((V - 2)/2)^2 pairs. Since we want a data structure that takes O(V+E) space, we'll need to store some information that uses less space than the essential pairs themselves, but still allows us to answer queries in constant time.\n\nFinding two node-disjoint paths\n\nIn the algorithm, we'll need to find two node-disjoint paths between s and t, which we know exist because the graph is biconnected.\n\nThe naive approach of finding a simple path, removing the nodes, and then looking for a second path doesn't work, like in this case:\n\nFor example, in this graph, there are two node-disjoint paths from 3 to 2: 3 -> 1 -> 0 -> 2 and 3 -> 4 -> 5 -> 2. However, if we start by finding the path 3 -> 4 -> 0 -> 2 and remove nodes 4 and 0, we won't be able to find a second path.\n\nInstead, we can use the following approach:\n\n1. Take the undirected graph and convert it into a directed graph with the following transformation:\n\nEach node u becomes a pair of nodes, u_in and u_out, connected by an edge u_in -> u_out.\n\nEach undirected edge (u, v) becomes two directed edges, u_out -> v_in and v_out -> u_in. Note that the \"out\" nodes are always connected to \"in\" nodes. The only way to get to u_out is to come from u_in.\n\n2. Next, we need to find two edge-disjoint paths from s_out to t_in in this directed graph. These two paths can be mapped to two node-disjoint paths in the original graph because, for each node u in the original graph, they can't both go through the edge u_in -> u_out in the directed graph.\n\nThis image shows a biconnected graph with two node-disjoint paths from 0 to 5:\n\nFinding two edge-disjoint paths in a directed graph can be done with two iterations of the Ford-Fulkerson algorithm. Essentially, we can think of the directed graph as a flow network, where each edge has a capacity of 1. We then need to be able to send two units of flow from s to t. The paths of the flow form two edge-disjoint paths in the directed graph.\n\nBuilding the directed graph takes linear time, and each iteration of Ford-Fulkerson algorithm requires a linear-time graph traversal. Thus, this all takes linear time (see the TypeScript implementation).\n\nEssential edge candidates\n\nAmong all the edges in the biconnected graph, we will start by filtering down the edges that can be part of an essential pair to a smaller set of candidates.\n\nWe start by finding any two node-disjoint paths from s to t, as described above. Which we'll call the red path (R) and the blue path (B). We'll call the edges in R red edges and the edges in B blue edges.\n\nAn edge pair can only be essential if it has one red edge and one blue edge (otherwise, s and t remain connected via one of the two paths). Thus, we can narrow down the set of candidate edges to those in R and B.\n\nWe can narrow the candidate edges further. Consider a red edge, e1. We know that if e1 is part of an essential pair, (e1, e2), then e2 must be a blue edge. So, if s and t remain connected even after removing e1 and all the blue edges, then we can safely say that e1 can never be part of an essential pair. That is, e1 is not a candidate.\n\nWe can find all the red candidates, which we'll call RC = (r1, r2, ..., rk), in linear time, as follows:\n\nRemove all the blue edges from G.\n\nFind all the bridges in the remaining graph.\n\nRC is the list of red bridges.\n\nSimilarly, we can find all the blue candidates, which we'll call BC = (b1, b2, ..., bk'), by removing all the red edges from G and finding the bridges in the remaining graph that overlap with B:\n\nAn edge pair can only be essential if it contains an edge from RC and an edge from BC.\n\nHowever, not every edge pair with one edge in RC and one edge in RB is essential. For example:\n\nIn this graph, the essential pairs are (r1, b1), (r2, b2), and (r3, b2). Other pairs of candidates, like (r1, b2), are not essential. Intuitively, a pair of candidates is not essential when we can stich together parts of the red and blue paths together that avoid the candidates.\n\nThings will get a bit complicated from now on, so it's worth mentioning that, if we wanted to settle for not-always-constant-time queries, we could simply store the sets of red and blue candidates, and only do an s-t reachability check when we get a query with one red candidate and one blue candidate. For every other edge pair, we can simply return False in O(1) time.\n\nThe path-segment graph\n\nWe'll assume that RC and BC are both non-empty from now on (otherwise, we can just return False for every query).\n\nTo achieve worst-case constant-time queries, we'll need to construct what I call the path-segment graph:\n\nThis is an undirected graph that has one node for each disconnected segment of the red path after removing the red candidates, and one node for each disconnected segment of the blue path after removing the blue candidates.\n\nIn the path-segment graph, we call the nodes for the red segments rs_0, rs_1, ..., rs_k and the nodes for the blue segments bs_0, bs_1, ..., bs_k'. We'll also call them red-segment nodes and blue-segment nodes, respectively.\n\nThe nodes rs_0 and rs_1 are connected by an edge, which we call r1, just like in the original graph. Similarly, rs_1 and rs_2 are connected by r2, and so on, up to rs_k-1 and rs_k, which are connected by rk. The same applies to the blue-segment nodes, so every edge in RC and BC is \"present\" in the path-segment graph.\n\nBesides the RC and BC edges, which connect the nodes of the red-segment nodes and blue-segment nodes in two separate paths, there are also cross edges between red-segment and blue-segment nodes. Intuitively, these edges denote that we can go from one segment of the red path to a segment of the blue path without crossing any of the candidate edges.\n\nHere is the path-segment graph for the example above:\n\nThe red path is broken into four segments: rs_0 is just s, rs_1 is just the node between r1 and r2, rs_2 is the segment up to r3, and rs_3 is the final edge of the red path. Similarly, the blue path is broken into three segments.\n\nIn the path-segment graph, there is always a cross edge between rs_0 and bs_0 because they share the node s. Similarly, there is always a cross edge between rs_k and bs_k' because they share the node t. For this specific example, there is also a cross edge between rs_1 and bs_1 because we can walk from the node to the right of s to the segment of B that starts at the node below s without crossing any of the candidate edges.\n\nNext, we'll describe how to compute the cross edges.\n\nIf we take the original graph and remove all the red candidates and all the blue edges (G - RC - B), we are left with a sequence of connected components, each of which contains one of the red-path segments, and perhaps additional connected components that don't contain any of the red-path segments.\n\nWe call RCC_i the connected component in G - RC - B that contains the red segment rs_i. Thus, the red path traverses RCC_0, RCC_1, ..., RCC_k, in this order. We also do the same for the blue path, and call the components BCC_0, BCC_1, ..., BCC_k'.\n\nHere we can see the two sets of connected components for the example above (shown in different colors):\n\nTo compute the cross edges in the path-segment graph, we first label all the nodes in the original graph according to which RCC_i and BCC_j connected components they belong to. Then, we add a cross edge between rs_i and bs_j in the path-segment graph if and only if there is a node in the original graph that is in both RCC_i and BCC_j.\n\nHere is another example of path-segment graph:\n\nIn this graph, the essential pairs are (r1, b1), (r1, b2), (r4, b3), and (r4, b4).\n\nThis example shows that there can be candidates that are not part of any essential pair (r2 and r3 in this case).\n\nYou can create the visualizations above for any grid graph with a visualization tool I vibe coded: https://github.com/nmamano/two-edge-removal-problem/tree/main/python_visualization\n\nThe path-segment graph can be computed in linear time. In particular, it has at most V cross edges, since each cross edge (rs_i, bs_j) requires a node in the original graph contained in both RCC_i and BCC_j.\n\nReducing connectivity in the original graph to connectivity in the path-segment graph\n\nStarting from this section, we need one more bit of notation: we use the subindex >=i to indicate \"all subindices greater than or equal to i\" and the subindex <i to indicate \"all subindices less than i\".\n\nThe following lemma shows that instead of checking if a candidate pair, (ri, bj), disconnects s and t in the original graph, we can check if it disconnects rs_0 and rs_k in the path-segment graph. This makes our job easier since the path-segment graph is structurally simpler than the original graph.\n\nLemma 1: A candidate pair (ri, bj) is essential if and only if it disconnects rs_0 and rs_k in the path-segment graph.\n\nIn other words:\n\nIf removing (ri, bj) disconnects rs_0 and rs_k in the path-segment graph, then it disconnects s and t in the original graph.\n\nIf removing (ri, bj) does not disconnect rs_0 and rs_k in the path-segment graph, then it does not disconnect s and t in the original graph.\n\nStarting with (2), if there is a path from rs_0 to rs_k in the path-segment graph that does not use ri or bj, we can turn it into an s-t path in the original graph that does not use ri or bj either: we follow one of the paths, say R, until we have to use a cross edge in the path-segment graph, say, (rs_x, bs_y). We know that RCC_x and BCC_y share at least a node, v, so we can find a path from one of the nodes in the path segment for rs_x to v and from v to one of the nodes in the path segment for bs_y. We can then continue following the other path, B, until we reach t or need to use another cross edge, which we can handle in the same way.\n\nFor (1), we want to show that there is no s-t path in the original graph without ri and bj.\n\nBy definition, without ri, there is no way to get to RCC_>=i without using blue edges. However, using blue edges before bj still does not allow us to reach any nodes in RCC_>=i (otherwise, rs_0 and rs_k would still be connected in the path-segment graph thanks to a cross edge).\n\n(The proof for (1) is admittedly hand-wavy, I may have to revisit it.)\n\nCompressing the path-segment graph\n\nThe following lemma will allow us to do a final transformation to the path-segment graph to further simplify its structure (the exact reason will be clear later).\n\nLemma 2: The following two statements are equivalent: (a) A candidate pair (ri, bj) is essential; (b) for every cross edge (rs_x, bs_y) in the path-segment graph, ri and bj are both on the same side of that cross edge (i <= x and j <= y, or i > x and j > y).\n\n(a) => (b) direction: Assume, for the sake of contradiction, that (ri, bj) is essential but there is a cross edge (rs_x, bs_y) such that i <= x and j > y. Then, we can go from rs_0 to bs_0, from bs_0 to bs_y, from bs_y to rs_x, and from rs_x to rs_k. This contradicts that (ri, bj) is essential. The other case is symmetric.\n\n(b) => (a) direction: cross edges of the form (s1_<i, s2_<j) do not allow us to \"skip\" over ri and bj. Cross edges of the form (s1_>=i, s2_>=j) have two endpoints neither of which can be reached from rs_0 in the first place.\n\nLemma 2 is important for the following reason:\n\nIf we have a chain of edges in the path-segment graph, rx, ..., ry, without any cross edges coming out of the nodes between them, then all the edges in the chain have all the same cross edges on each side. A corollary of Lemma 2 is that combining any of these edges with a blue candidate, bj, has exactly the same effect on whether rs_0 and rs_k stay connected. Thus, we can compress the chain into a single edge, r_x,y, as shown in the figure:\n\nIn this path-segment graph, we compressed r1, r2, and r3 into r_1,3, left r4 alone (relabeled as r_4,4), and compressed r5 and r6 into r_5,6. The blue candidates got compressed similarly.\n\nThe result is a new graph, which we call the compressed path-segment graph. It is similar to the path-segment graph, but with potentially fewer nodes and edges.\n\nWe call a pair of edges in the compressed path-segment graph, (r_x,y, b_z,w), essential if they disconnect r_0 and r_k. What that means is that any red candidate compressed into r_x,y forms an essential pair with any blue candidate compressed into b_z,w.\n\nThe compressed path-segment graph has the property that every node is adjacent to at least one cross edge. This is important for one reason:\n\nIn the normal path-segment graph, an edge in the top path could form an essential pair with many edges in the bottom path, leading to a potentially quadratic number of essential pairs. In the compressed path-segment graph, each edge in the top path can only form an essential pair with at most one edge in the bottom path. This is because of Lemma 2: there are cross edges between every pair of edges in the bottom path, so only one of them can match the position of the top edge relative to all the cross edges.\n\nFinally, we reached a point where we can store all the essential pairs in O(V) space. We can only do this because each edge of the compressed path-segment graph represents potentially many candidates in the original graph.\n\nNow, we just need to compute them in linear time.\n\nComputing essential pairs in the compressed path-segment graph\n\nWe can use a straightforward two-pointer algorithm, with one pointer for each path. The red pointer starts at the edge r_1,x and the blue pointer starts at the edge b_1,y. For each pointer, we keep track of which cross edges we've already passed. Then, we have a case analysis:\n\nIf both pointers have passed the same cross edges, mark the current edge pair as essential, and advance both pointers.\n\nIf the red pointer has passed any cross edges that the blue pointer hasn't passed, advance the blue pointer.\n\nIf the blue pointer has passed any cross edges that the red pointer hasn't passed, advance the red pointer.\n\nWith this method, we can find and store all the essential pairs in the compressed path-segment graph in O(V) time.\n\nTo know if a pair of candidates (ri, bj) in G is essential, we check if the compressed edges they belong to form an essential pair in the compressed path-segment graph.\n\nImplementation\n\nIn this section, we'll see how all the pieces fit together by designing the full data structure as described at the beginning of the post.\n\nThe data structure is implemented in TypeScript here. There is also the brute-force solution, tests, the visualization tool (in Python), and a little benchmark we'll use for the next section.\n\nConstruction:\n\nThe only constraint on G is that s and t are connected and different.\n\nTime and space: O(V + E).\n\nTime and space: O(1).\n\nI generated 10 random 30x30 grid graphs, where each edge is present with probability 0.5. For each graph, I picked s and t randomly, making sure that s and t were connected.\n\nI then initialized the data structure for each graph and queried it with every edge pair in the graph. I also ran all the queries with the brute-force solution.\n\nHere are the results:\n\nThe bigger the graph, the more queries we can do, and thus the more the preprocessing pays off. With 11x11 grid graphs, which is the standard size for the Wall Game, we do only ~15k queries per graph, and the speedup is only about 6x.\n\nFor both 30x30 and 11x11 grid graphs, the construction of the data structures is about 3 orders of magnitude slower than solving a single query directly with a graph traversal. This is surprising, given the optimized data structure only does a constant number of graph traversals (about 10). My theory is that the overhead comes from allocating memory (e.g., for the various derived graphs; the keyword new appears ~30 times in the code) and from the use of hash sets and maps.\n\nOptimizing the code was not the main point of this post. It can be optimized further by doing things like:\n\nPre-allocating and reusing the visited and stack arrays across all the functions that need to do some kind of graph traversal.\n\nNot explicitly constructing the directed graph in findTwoNodeDisjointPaths().\n\nNot explicitly constructing graphs like G - R, G - B, G - R - BC, and G - B - RC. Instead, we can pass around a set of \"disallowed\" edges. (The path-segment graph and the compressed path-segment graphs are already not constructed explicitly.)\n\nAvoiding hash sets and maps with edges as keys. Instead, edges could be mapped to contiguous integers from 0 to E - 1 (I already avoided using sets and maps when the keys are integers starting at 0, like node indices).\n\nChoosing a better language for low-level optimizations...\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/double-edge-cut-problem#motivation",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Double-Edge Cut Problem",
      "content": "Double-Edge Cut Problem\n\nIn this post, we'll solve a graph problem that comes up in the Wall Game.\n\nSee also the related, but easier, Single-Edge Cut Problem.\n\nThe double-edge cut problem\n\nYou are given an undirected, unweighted graph G with V nodes and E edges, where each node is identified by an integer from 0 to V - 1. You are also given a pair of distinct nodes, s and t, in the same connected component of G.\n\nWe say a pair of edges (e1, e2) is essential if removing e1 and e2 from G disconnects s and t.\n\nImplement a data structure that takes G, s, and t at construction time, and then can answer queries of the form \"Is a given pair of edges essential?\"\n\nIn this post, we'll see how to construct such a data structure in linear time and space (O(V + E)) and answer queries in constant time.\n\nIn this graph, if s is 0 and t is 6, the essential pairs are ((0, 1), (0, 3)), ((2, 4), (3, 8)), and ((2, 4), (7, 8)).\n\nAny other pair of edges can be removed and s and t will remain in the same connected component, even if the graph itself is disconnected. For instance, if we remove (4, 5) and (5, 6), node 5 ends in its own connected component, but s and t are still connected.\n\nBrute force solution\n\nThe brute force solution is to do nothing at construction time. For each query, take each pair of edges, remove them, and then use a graph traversal to see if s and t are still connected. This takes O(E) time per query.\n\nThe brute force implementation is on github. We'll compare it against the optimized solution in the benchmark at the end.\n\nThis is the key problem behind whether a double-wall move is valid or not in the Wall Game. The board of the Wall Game may look something like the picture on the left:\n\nThe right picture is the board modeled as a graph. The cells become nodes and two adjacent nodes are connected if there is no wall between them.\n\nDuring their turn, players can build up to two walls anywhere, which is like removing two edges. The only constraint is that they cannot fully block the opponent's path to their goal (or their own). In this setting, each player forms an s-t pair with their goal, and the essential edge pairs correspond to invalid double-wall moves.\n\nIn the picture, the red player and goal are labeled s and t, and one essential pair is shown in red. There are many more essential pairs.\n\nImagine that you want to implement an engine for the Wall Game. One question you'll probably have to answer frequently is, \"Given a position, is a given move valid?\" The hardest type of move to check is a double wall move (the single-wall move case is handled by the single-edge cut problem). To answer this question efficiently, we can solve the double-edge cut problem and build one data structure for each player; we can query them to check if a double wall move disconnects any player from their goal.\n\nI got nerd-sniped by this problem in 2021, when I was coding an engine for the Wall Game (it's on github; it's in C++ but you can play against it on wallwars.net thanks to WebAssembly). The engine is based on negamax with alpha-beta pruning, and the bottleneck is generating all the valid double-wall moves from a position.\n\nThe move generation implementation from back then already uses some of the ideas we'll see in this post, like the fact that we can precompute two node-disjoint paths for each biconnected component, and two walls can only be an invalid if they are in the same biconnected component and there is one wall in each path (this will make sense later).\n\nHowever, I couldn't figure out how to handle the case of two walls in the same biconnected component and in the two precomputed paths in constant time, defaulting to a full graph traversal for that case (here).\n\nI revisited the problem in 2025 because I'm rebuilding the game. The key new insight is the construction of the path-segment graph, which we'll get to below. Something that was very helpful in this breakthrough was vibe coding a tool to visualize the various graph transformations (we'll see screenshots of it in this post).\n\nYes, I could have coded the visualization tool myself back then, but vibe coding removed the friction. Ironically, vibe coding has a rep for only being good at starting projects and then abandoning them, but here it helped me pick up an abandoned project and finish it.\n\nPreliminary definitions\n\nThe algorithm relies heavily on the concepts of articulation points and biconnected components, so we'll need the following definitions:\n\nA biconnected graph is a graph that remains connected even if any single node is removed.\n\nAn articulation point is a node whose removal increases the number of connected components. A graph is biconnected if and only if it has no articulation points.\n\nA biconnected component is a maximal biconnected subgraph.\n\nA bridge is an edge whose removal increases the number of connected components.\n\nIn a connected graph with at least two nodes, every node is in at least one biconnected component. The graph can be decomposed into what is called the block-cut tree of the graph, which has one node per biconnected component and biconnected components are connected by articulation points. For example:\n\nThis graph on the left has four articulation points: 2, 4, 6, and 7. It has six biconnected components (shown in different colors). The bridges are (7, 9), (7, 8), and (6, 12).\n\nThe block-cut tree is a tree in the sense that there cannot be a cycle of biconnected components--the cycle would collapse into a single biconnected component.\n\nHere are some additional well known properties:\n\nAn articulation point is always in more than one biconnected component. For instance, node 7 in the picture above is in three biconnected components. An edge is always in a single biconnected component.\n\nNot every edge between articulation points is a bridge. For instance, (2, 4) in the graph above is not a bridge.\n\nEvery node adjacent to a bridge is an articulation point with the exception of degree-1 nodes (like 9 in the picture above).\n\nAn edge is a bridge if and only if it is the only edge in a biconnected component.\n\nIn a biconnected component that is not a single edge, there are two node-disjoint paths between any two nodes. For instance, in the blue biconnected component, there are two paths from 2 to 4 that don't share any nodes: 2 -> 4 and 2 -> 10 -> 11 -> 4.\n\nTwo biconnected components can only have one articulation point in common. Otherwise, the two biconnected components would collapse into a single one.\n\nThere cannot be a cycle that is not fully contained in a single biconnected component. Otherwise, all the biconnected components in the cycle would collapse into a single one. (That's why the block-cut tree is called a tree.)\n\nIf a simple path (path with no repeated nodes) leaves a biconnected component, it cannot return to it (for similar reasons).\n\nReduction to biconnected graphs\n\nIn this section, we'll reduce the original problem to the case where the graph is biconnected, which we'll tackle in the next section.\n\nNote that the graph from the Wall Game may not be biconnected. It may not even be connected--see, e.g., the isolated connected component in the top-left corner above. All we are guaranteed is that each player is in the same connected component as their goal.\n\nFirst, we'll get an edge case out of the way: if s and t are neighbors and connected by a bridge, then an edge pair is essential if and only if it contains that bridge.\n\nNext, consider the case where s and t are in the same biconnected component, C (which is not just a bridge). Any edge pair where at least one edge is in another biconnected component is not essential. Thus, we can focus on edge pairs inside C. In fact, when analyzing if an edge pair in C is essential, we can completely ignore the rest of the graph (we can literally remove nodes and edges outside of C). That is because any simple path from s to t must be fully contained in C (Property 8).\n\nIf s and t are not already in the same biconnected component, any path from s to t must go through the exact same sequence of articulation points and biconnected components. Otherwise, there would be a cycle of biconnected components, which is impossible (Property 7).\n\nLet C1, C2, ..., Ck be the sequence of biconnected components that any s-t path must go through. In fact, not only is the sequence of biconnected components fixed, but also the entry and exit nodes of each biconnected component. The entry and exit nodes must be an articulation point, except for C1, where the entry node is s, and Ck, where the exit node is t. This is because there cannot be two articulation points from Ci to Ci+1 (Property 6).\n\nAmong the biconnected components between s and t, there may be one or more consisting of a single edge (i.e., a bridge). Removing that bridge disconnects s and t by itself, so any edge pair containing it is automatically essential.\n\nAside from the specific case of bridge-only biconnected components, there is no way to disconnect s and t by removing two edges from different biconnected components.\n\nWhat that means is that we can tackle each biconnected component C1, C2, ..., Ck independently, and then combine the results.\n\nWe can start by finding the biconnected components of the graph and any s-t path. From there, we can decompose the input graph into C1, C2, ..., Ck, and solve the problem for each of them. Instead of s and t, for each biconnected component, we use the path's entry and exit nodes as the new s and t.\n\nThis all can be done in linear time, and allows us to reduce the general case to a number of instances of the biconnected case, all of which combined have an equal or smaller size than the original graph.\n\nNext, we'll focus exclusively on the special case where the input graph is biconnected.\n\nBiconnected graphs\n\nIn this section, we assume that G is biconnected.\n\nOne obstacle we'll need to overcome is that we cannot possibly store every essential pair in our data structure given the time and space constraints. The worst case for the number of essential pairs in a biconnected graph is about (V^2)/4, which happens when the graph forms a single cycle, and s and t are as far apart as possible in the cycle, with (V - 2)/2 edges between them on each side. In this case, each edge on one side of the cycle forms an essential pair with each edge on the other side of the cycle, for a total of ((V - 2)/2)^2 pairs. Since we want a data structure that takes O(V+E) space, we'll need to store some information that uses less space than the essential pairs themselves, but still allows us to answer queries in constant time.\n\nFinding two node-disjoint paths\n\nIn the algorithm, we'll need to find two node-disjoint paths between s and t, which we know exist because the graph is biconnected.\n\nThe naive approach of finding a simple path, removing the nodes, and then looking for a second path doesn't work, like in this case:\n\nFor example, in this graph, there are two node-disjoint paths from 3 to 2: 3 -> 1 -> 0 -> 2 and 3 -> 4 -> 5 -> 2. However, if we start by finding the path 3 -> 4 -> 0 -> 2 and remove nodes 4 and 0, we won't be able to find a second path.\n\nInstead, we can use the following approach:\n\n1. Take the undirected graph and convert it into a directed graph with the following transformation:\n\nEach node u becomes a pair of nodes, u_in and u_out, connected by an edge u_in -> u_out.\n\nEach undirected edge (u, v) becomes two directed edges, u_out -> v_in and v_out -> u_in. Note that the \"out\" nodes are always connected to \"in\" nodes. The only way to get to u_out is to come from u_in.\n\n2. Next, we need to find two edge-disjoint paths from s_out to t_in in this directed graph. These two paths can be mapped to two node-disjoint paths in the original graph because, for each node u in the original graph, they can't both go through the edge u_in -> u_out in the directed graph.\n\nThis image shows a biconnected graph with two node-disjoint paths from 0 to 5:\n\nFinding two edge-disjoint paths in a directed graph can be done with two iterations of the Ford-Fulkerson algorithm. Essentially, we can think of the directed graph as a flow network, where each edge has a capacity of 1. We then need to be able to send two units of flow from s to t. The paths of the flow form two edge-disjoint paths in the directed graph.\n\nBuilding the directed graph takes linear time, and each iteration of Ford-Fulkerson algorithm requires a linear-time graph traversal. Thus, this all takes linear time (see the TypeScript implementation).\n\nEssential edge candidates\n\nAmong all the edges in the biconnected graph, we will start by filtering down the edges that can be part of an essential pair to a smaller set of candidates.\n\nWe start by finding any two node-disjoint paths from s to t, as described above. Which we'll call the red path (R) and the blue path (B). We'll call the edges in R red edges and the edges in B blue edges.\n\nAn edge pair can only be essential if it has one red edge and one blue edge (otherwise, s and t remain connected via one of the two paths). Thus, we can narrow down the set of candidate edges to those in R and B.\n\nWe can narrow the candidate edges further. Consider a red edge, e1. We know that if e1 is part of an essential pair, (e1, e2), then e2 must be a blue edge. So, if s and t remain connected even after removing e1 and all the blue edges, then we can safely say that e1 can never be part of an essential pair. That is, e1 is not a candidate.\n\nWe can find all the red candidates, which we'll call RC = (r1, r2, ..., rk), in linear time, as follows:\n\nRemove all the blue edges from G.\n\nFind all the bridges in the remaining graph.\n\nRC is the list of red bridges.\n\nSimilarly, we can find all the blue candidates, which we'll call BC = (b1, b2, ..., bk'), by removing all the red edges from G and finding the bridges in the remaining graph that overlap with B:\n\nAn edge pair can only be essential if it contains an edge from RC and an edge from BC.\n\nHowever, not every edge pair with one edge in RC and one edge in RB is essential. For example:\n\nIn this graph, the essential pairs are (r1, b1), (r2, b2), and (r3, b2). Other pairs of candidates, like (r1, b2), are not essential. Intuitively, a pair of candidates is not essential when we can stich together parts of the red and blue paths together that avoid the candidates.\n\nThings will get a bit complicated from now on, so it's worth mentioning that, if we wanted to settle for not-always-constant-time queries, we could simply store the sets of red and blue candidates, and only do an s-t reachability check when we get a query with one red candidate and one blue candidate. For every other edge pair, we can simply return False in O(1) time.\n\nThe path-segment graph\n\nWe'll assume that RC and BC are both non-empty from now on (otherwise, we can just return False for every query).\n\nTo achieve worst-case constant-time queries, we'll need to construct what I call the path-segment graph:\n\nThis is an undirected graph that has one node for each disconnected segment of the red path after removing the red candidates, and one node for each disconnected segment of the blue path after removing the blue candidates.\n\nIn the path-segment graph, we call the nodes for the red segments rs_0, rs_1, ..., rs_k and the nodes for the blue segments bs_0, bs_1, ..., bs_k'. We'll also call them red-segment nodes and blue-segment nodes, respectively.\n\nThe nodes rs_0 and rs_1 are connected by an edge, which we call r1, just like in the original graph. Similarly, rs_1 and rs_2 are connected by r2, and so on, up to rs_k-1 and rs_k, which are connected by rk. The same applies to the blue-segment nodes, so every edge in RC and BC is \"present\" in the path-segment graph.\n\nBesides the RC and BC edges, which connect the nodes of the red-segment nodes and blue-segment nodes in two separate paths, there are also cross edges between red-segment and blue-segment nodes. Intuitively, these edges denote that we can go from one segment of the red path to a segment of the blue path without crossing any of the candidate edges.\n\nHere is the path-segment graph for the example above:\n\nThe red path is broken into four segments: rs_0 is just s, rs_1 is just the node between r1 and r2, rs_2 is the segment up to r3, and rs_3 is the final edge of the red path. Similarly, the blue path is broken into three segments.\n\nIn the path-segment graph, there is always a cross edge between rs_0 and bs_0 because they share the node s. Similarly, there is always a cross edge between rs_k and bs_k' because they share the node t. For this specific example, there is also a cross edge between rs_1 and bs_1 because we can walk from the node to the right of s to the segment of B that starts at the node below s without crossing any of the candidate edges.\n\nNext, we'll describe how to compute the cross edges.\n\nIf we take the original graph and remove all the red candidates and all the blue edges (G - RC - B), we are left with a sequence of connected components, each of which contains one of the red-path segments, and perhaps additional connected components that don't contain any of the red-path segments.\n\nWe call RCC_i the connected component in G - RC - B that contains the red segment rs_i. Thus, the red path traverses RCC_0, RCC_1, ..., RCC_k, in this order. We also do the same for the blue path, and call the components BCC_0, BCC_1, ..., BCC_k'.\n\nHere we can see the two sets of connected components for the example above (shown in different colors):\n\nTo compute the cross edges in the path-segment graph, we first label all the nodes in the original graph according to which RCC_i and BCC_j connected components they belong to. Then, we add a cross edge between rs_i and bs_j in the path-segment graph if and only if there is a node in the original graph that is in both RCC_i and BCC_j.\n\nHere is another example of path-segment graph:\n\nIn this graph, the essential pairs are (r1, b1), (r1, b2), (r4, b3), and (r4, b4).\n\nThis example shows that there can be candidates that are not part of any essential pair (r2 and r3 in this case).\n\nYou can create the visualizations above for any grid graph with a visualization tool I vibe coded: https://github.com/nmamano/two-edge-removal-problem/tree/main/python_visualization\n\nThe path-segment graph can be computed in linear time. In particular, it has at most V cross edges, since each cross edge (rs_i, bs_j) requires a node in the original graph contained in both RCC_i and BCC_j.\n\nReducing connectivity in the original graph to connectivity in the path-segment graph\n\nStarting from this section, we need one more bit of notation: we use the subindex >=i to indicate \"all subindices greater than or equal to i\" and the subindex <i to indicate \"all subindices less than i\".\n\nThe following lemma shows that instead of checking if a candidate pair, (ri, bj), disconnects s and t in the original graph, we can check if it disconnects rs_0 and rs_k in the path-segment graph. This makes our job easier since the path-segment graph is structurally simpler than the original graph.\n\nLemma 1: A candidate pair (ri, bj) is essential if and only if it disconnects rs_0 and rs_k in the path-segment graph.\n\nIn other words:\n\nIf removing (ri, bj) disconnects rs_0 and rs_k in the path-segment graph, then it disconnects s and t in the original graph.\n\nIf removing (ri, bj) does not disconnect rs_0 and rs_k in the path-segment graph, then it does not disconnect s and t in the original graph.\n\nStarting with (2), if there is a path from rs_0 to rs_k in the path-segment graph that does not use ri or bj, we can turn it into an s-t path in the original graph that does not use ri or bj either: we follow one of the paths, say R, until we have to use a cross edge in the path-segment graph, say, (rs_x, bs_y). We know that RCC_x and BCC_y share at least a node, v, so we can find a path from one of the nodes in the path segment for rs_x to v and from v to one of the nodes in the path segment for bs_y. We can then continue following the other path, B, until we reach t or need to use another cross edge, which we can handle in the same way.\n\nFor (1), we want to show that there is no s-t path in the original graph without ri and bj.\n\nBy definition, without ri, there is no way to get to RCC_>=i without using blue edges. However, using blue edges before bj still does not allow us to reach any nodes in RCC_>=i (otherwise, rs_0 and rs_k would still be connected in the path-segment graph thanks to a cross edge).\n\n(The proof for (1) is admittedly hand-wavy, I may have to revisit it.)\n\nCompressing the path-segment graph\n\nThe following lemma will allow us to do a final transformation to the path-segment graph to further simplify its structure (the exact reason will be clear later).\n\nLemma 2: The following two statements are equivalent: (a) A candidate pair (ri, bj) is essential; (b) for every cross edge (rs_x, bs_y) in the path-segment graph, ri and bj are both on the same side of that cross edge (i <= x and j <= y, or i > x and j > y).\n\n(a) => (b) direction: Assume, for the sake of contradiction, that (ri, bj) is essential but there is a cross edge (rs_x, bs_y) such that i <= x and j > y. Then, we can go from rs_0 to bs_0, from bs_0 to bs_y, from bs_y to rs_x, and from rs_x to rs_k. This contradicts that (ri, bj) is essential. The other case is symmetric.\n\n(b) => (a) direction: cross edges of the form (s1_<i, s2_<j) do not allow us to \"skip\" over ri and bj. Cross edges of the form (s1_>=i, s2_>=j) have two endpoints neither of which can be reached from rs_0 in the first place.\n\nLemma 2 is important for the following reason:\n\nIf we have a chain of edges in the path-segment graph, rx, ..., ry, without any cross edges coming out of the nodes between them, then all the edges in the chain have all the same cross edges on each side. A corollary of Lemma 2 is that combining any of these edges with a blue candidate, bj, has exactly the same effect on whether rs_0 and rs_k stay connected. Thus, we can compress the chain into a single edge, r_x,y, as shown in the figure:\n\nIn this path-segment graph, we compressed r1, r2, and r3 into r_1,3, left r4 alone (relabeled as r_4,4), and compressed r5 and r6 into r_5,6. The blue candidates got compressed similarly.\n\nThe result is a new graph, which we call the compressed path-segment graph. It is similar to the path-segment graph, but with potentially fewer nodes and edges.\n\nWe call a pair of edges in the compressed path-segment graph, (r_x,y, b_z,w), essential if they disconnect r_0 and r_k. What that means is that any red candidate compressed into r_x,y forms an essential pair with any blue candidate compressed into b_z,w.\n\nThe compressed path-segment graph has the property that every node is adjacent to at least one cross edge. This is important for one reason:\n\nIn the normal path-segment graph, an edge in the top path could form an essential pair with many edges in the bottom path, leading to a potentially quadratic number of essential pairs. In the compressed path-segment graph, each edge in the top path can only form an essential pair with at most one edge in the bottom path. This is because of Lemma 2: there are cross edges between every pair of edges in the bottom path, so only one of them can match the position of the top edge relative to all the cross edges.\n\nFinally, we reached a point where we can store all the essential pairs in O(V) space. We can only do this because each edge of the compressed path-segment graph represents potentially many candidates in the original graph.\n\nNow, we just need to compute them in linear time.\n\nComputing essential pairs in the compressed path-segment graph\n\nWe can use a straightforward two-pointer algorithm, with one pointer for each path. The red pointer starts at the edge r_1,x and the blue pointer starts at the edge b_1,y. For each pointer, we keep track of which cross edges we've already passed. Then, we have a case analysis:\n\nIf both pointers have passed the same cross edges, mark the current edge pair as essential, and advance both pointers.\n\nIf the red pointer has passed any cross edges that the blue pointer hasn't passed, advance the blue pointer.\n\nIf the blue pointer has passed any cross edges that the red pointer hasn't passed, advance the red pointer.\n\nWith this method, we can find and store all the essential pairs in the compressed path-segment graph in O(V) time.\n\nTo know if a pair of candidates (ri, bj) in G is essential, we check if the compressed edges they belong to form an essential pair in the compressed path-segment graph.\n\nImplementation\n\nIn this section, we'll see how all the pieces fit together by designing the full data structure as described at the beginning of the post.\n\nThe data structure is implemented in TypeScript here. There is also the brute-force solution, tests, the visualization tool (in Python), and a little benchmark we'll use for the next section.\n\nConstruction:\n\nThe only constraint on G is that s and t are connected and different.\n\nTime and space: O(V + E).\n\nTime and space: O(1).\n\nI generated 10 random 30x30 grid graphs, where each edge is present with probability 0.5. For each graph, I picked s and t randomly, making sure that s and t were connected.\n\nI then initialized the data structure for each graph and queried it with every edge pair in the graph. I also ran all the queries with the brute-force solution.\n\nHere are the results:\n\nThe bigger the graph, the more queries we can do, and thus the more the preprocessing pays off. With 11x11 grid graphs, which is the standard size for the Wall Game, we do only ~15k queries per graph, and the speedup is only about 6x.\n\nFor both 30x30 and 11x11 grid graphs, the construction of the data structures is about 3 orders of magnitude slower than solving a single query directly with a graph traversal. This is surprising, given the optimized data structure only does a constant number of graph traversals (about 10). My theory is that the overhead comes from allocating memory (e.g., for the various derived graphs; the keyword new appears ~30 times in the code) and from the use of hash sets and maps.\n\nOptimizing the code was not the main point of this post. It can be optimized further by doing things like:\n\nPre-allocating and reusing the visited and stack arrays across all the functions that need to do some kind of graph traversal.\n\nNot explicitly constructing the directed graph in findTwoNodeDisjointPaths().\n\nNot explicitly constructing graphs like G - R, G - B, G - R - BC, and G - B - RC. Instead, we can pass around a set of \"disallowed\" edges. (The path-segment graph and the compressed path-segment graphs are already not constructed explicitly.)\n\nAvoiding hash sets and maps with edges as keys. Instead, edges could be mapped to contiguous integers from 0 to E - 1 (I already avoided using sets and maps when the keys are integers starting at 0, like node indices).\n\nChoosing a better language for low-level optimizations...\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/double-edge-cut-problem#benchmark",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Double-Edge Cut Problem",
      "content": "Double-Edge Cut Problem\n\nIn this post, we'll solve a graph problem that comes up in the Wall Game.\n\nSee also the related, but easier, Single-Edge Cut Problem.\n\nThe double-edge cut problem\n\nYou are given an undirected, unweighted graph G with V nodes and E edges, where each node is identified by an integer from 0 to V - 1. You are also given a pair of distinct nodes, s and t, in the same connected component of G.\n\nWe say a pair of edges (e1, e2) is essential if removing e1 and e2 from G disconnects s and t.\n\nImplement a data structure that takes G, s, and t at construction time, and then can answer queries of the form \"Is a given pair of edges essential?\"\n\nIn this post, we'll see how to construct such a data structure in linear time and space (O(V + E)) and answer queries in constant time.\n\nIn this graph, if s is 0 and t is 6, the essential pairs are ((0, 1), (0, 3)), ((2, 4), (3, 8)), and ((2, 4), (7, 8)).\n\nAny other pair of edges can be removed and s and t will remain in the same connected component, even if the graph itself is disconnected. For instance, if we remove (4, 5) and (5, 6), node 5 ends in its own connected component, but s and t are still connected.\n\nBrute force solution\n\nThe brute force solution is to do nothing at construction time. For each query, take each pair of edges, remove them, and then use a graph traversal to see if s and t are still connected. This takes O(E) time per query.\n\nThe brute force implementation is on github. We'll compare it against the optimized solution in the benchmark at the end.\n\nThis is the key problem behind whether a double-wall move is valid or not in the Wall Game. The board of the Wall Game may look something like the picture on the left:\n\nThe right picture is the board modeled as a graph. The cells become nodes and two adjacent nodes are connected if there is no wall between them.\n\nDuring their turn, players can build up to two walls anywhere, which is like removing two edges. The only constraint is that they cannot fully block the opponent's path to their goal (or their own). In this setting, each player forms an s-t pair with their goal, and the essential edge pairs correspond to invalid double-wall moves.\n\nIn the picture, the red player and goal are labeled s and t, and one essential pair is shown in red. There are many more essential pairs.\n\nImagine that you want to implement an engine for the Wall Game. One question you'll probably have to answer frequently is, \"Given a position, is a given move valid?\" The hardest type of move to check is a double wall move (the single-wall move case is handled by the single-edge cut problem). To answer this question efficiently, we can solve the double-edge cut problem and build one data structure for each player; we can query them to check if a double wall move disconnects any player from their goal.\n\nI got nerd-sniped by this problem in 2021, when I was coding an engine for the Wall Game (it's on github; it's in C++ but you can play against it on wallwars.net thanks to WebAssembly). The engine is based on negamax with alpha-beta pruning, and the bottleneck is generating all the valid double-wall moves from a position.\n\nThe move generation implementation from back then already uses some of the ideas we'll see in this post, like the fact that we can precompute two node-disjoint paths for each biconnected component, and two walls can only be an invalid if they are in the same biconnected component and there is one wall in each path (this will make sense later).\n\nHowever, I couldn't figure out how to handle the case of two walls in the same biconnected component and in the two precomputed paths in constant time, defaulting to a full graph traversal for that case (here).\n\nI revisited the problem in 2025 because I'm rebuilding the game. The key new insight is the construction of the path-segment graph, which we'll get to below. Something that was very helpful in this breakthrough was vibe coding a tool to visualize the various graph transformations (we'll see screenshots of it in this post).\n\nYes, I could have coded the visualization tool myself back then, but vibe coding removed the friction. Ironically, vibe coding has a rep for only being good at starting projects and then abandoning them, but here it helped me pick up an abandoned project and finish it.\n\nPreliminary definitions\n\nThe algorithm relies heavily on the concepts of articulation points and biconnected components, so we'll need the following definitions:\n\nA biconnected graph is a graph that remains connected even if any single node is removed.\n\nAn articulation point is a node whose removal increases the number of connected components. A graph is biconnected if and only if it has no articulation points.\n\nA biconnected component is a maximal biconnected subgraph.\n\nA bridge is an edge whose removal increases the number of connected components.\n\nIn a connected graph with at least two nodes, every node is in at least one biconnected component. The graph can be decomposed into what is called the block-cut tree of the graph, which has one node per biconnected component and biconnected components are connected by articulation points. For example:\n\nThis graph on the left has four articulation points: 2, 4, 6, and 7. It has six biconnected components (shown in different colors). The bridges are (7, 9), (7, 8), and (6, 12).\n\nThe block-cut tree is a tree in the sense that there cannot be a cycle of biconnected components--the cycle would collapse into a single biconnected component.\n\nHere are some additional well known properties:\n\nAn articulation point is always in more than one biconnected component. For instance, node 7 in the picture above is in three biconnected components. An edge is always in a single biconnected component.\n\nNot every edge between articulation points is a bridge. For instance, (2, 4) in the graph above is not a bridge.\n\nEvery node adjacent to a bridge is an articulation point with the exception of degree-1 nodes (like 9 in the picture above).\n\nAn edge is a bridge if and only if it is the only edge in a biconnected component.\n\nIn a biconnected component that is not a single edge, there are two node-disjoint paths between any two nodes. For instance, in the blue biconnected component, there are two paths from 2 to 4 that don't share any nodes: 2 -> 4 and 2 -> 10 -> 11 -> 4.\n\nTwo biconnected components can only have one articulation point in common. Otherwise, the two biconnected components would collapse into a single one.\n\nThere cannot be a cycle that is not fully contained in a single biconnected component. Otherwise, all the biconnected components in the cycle would collapse into a single one. (That's why the block-cut tree is called a tree.)\n\nIf a simple path (path with no repeated nodes) leaves a biconnected component, it cannot return to it (for similar reasons).\n\nReduction to biconnected graphs\n\nIn this section, we'll reduce the original problem to the case where the graph is biconnected, which we'll tackle in the next section.\n\nNote that the graph from the Wall Game may not be biconnected. It may not even be connected--see, e.g., the isolated connected component in the top-left corner above. All we are guaranteed is that each player is in the same connected component as their goal.\n\nFirst, we'll get an edge case out of the way: if s and t are neighbors and connected by a bridge, then an edge pair is essential if and only if it contains that bridge.\n\nNext, consider the case where s and t are in the same biconnected component, C (which is not just a bridge). Any edge pair where at least one edge is in another biconnected component is not essential. Thus, we can focus on edge pairs inside C. In fact, when analyzing if an edge pair in C is essential, we can completely ignore the rest of the graph (we can literally remove nodes and edges outside of C). That is because any simple path from s to t must be fully contained in C (Property 8).\n\nIf s and t are not already in the same biconnected component, any path from s to t must go through the exact same sequence of articulation points and biconnected components. Otherwise, there would be a cycle of biconnected components, which is impossible (Property 7).\n\nLet C1, C2, ..., Ck be the sequence of biconnected components that any s-t path must go through. In fact, not only is the sequence of biconnected components fixed, but also the entry and exit nodes of each biconnected component. The entry and exit nodes must be an articulation point, except for C1, where the entry node is s, and Ck, where the exit node is t. This is because there cannot be two articulation points from Ci to Ci+1 (Property 6).\n\nAmong the biconnected components between s and t, there may be one or more consisting of a single edge (i.e., a bridge). Removing that bridge disconnects s and t by itself, so any edge pair containing it is automatically essential.\n\nAside from the specific case of bridge-only biconnected components, there is no way to disconnect s and t by removing two edges from different biconnected components.\n\nWhat that means is that we can tackle each biconnected component C1, C2, ..., Ck independently, and then combine the results.\n\nWe can start by finding the biconnected components of the graph and any s-t path. From there, we can decompose the input graph into C1, C2, ..., Ck, and solve the problem for each of them. Instead of s and t, for each biconnected component, we use the path's entry and exit nodes as the new s and t.\n\nThis all can be done in linear time, and allows us to reduce the general case to a number of instances of the biconnected case, all of which combined have an equal or smaller size than the original graph.\n\nNext, we'll focus exclusively on the special case where the input graph is biconnected.\n\nBiconnected graphs\n\nIn this section, we assume that G is biconnected.\n\nOne obstacle we'll need to overcome is that we cannot possibly store every essential pair in our data structure given the time and space constraints. The worst case for the number of essential pairs in a biconnected graph is about (V^2)/4, which happens when the graph forms a single cycle, and s and t are as far apart as possible in the cycle, with (V - 2)/2 edges between them on each side. In this case, each edge on one side of the cycle forms an essential pair with each edge on the other side of the cycle, for a total of ((V - 2)/2)^2 pairs. Since we want a data structure that takes O(V+E) space, we'll need to store some information that uses less space than the essential pairs themselves, but still allows us to answer queries in constant time.\n\nFinding two node-disjoint paths\n\nIn the algorithm, we'll need to find two node-disjoint paths between s and t, which we know exist because the graph is biconnected.\n\nThe naive approach of finding a simple path, removing the nodes, and then looking for a second path doesn't work, like in this case:\n\nFor example, in this graph, there are two node-disjoint paths from 3 to 2: 3 -> 1 -> 0 -> 2 and 3 -> 4 -> 5 -> 2. However, if we start by finding the path 3 -> 4 -> 0 -> 2 and remove nodes 4 and 0, we won't be able to find a second path.\n\nInstead, we can use the following approach:\n\n1. Take the undirected graph and convert it into a directed graph with the following transformation:\n\nEach node u becomes a pair of nodes, u_in and u_out, connected by an edge u_in -> u_out.\n\nEach undirected edge (u, v) becomes two directed edges, u_out -> v_in and v_out -> u_in. Note that the \"out\" nodes are always connected to \"in\" nodes. The only way to get to u_out is to come from u_in.\n\n2. Next, we need to find two edge-disjoint paths from s_out to t_in in this directed graph. These two paths can be mapped to two node-disjoint paths in the original graph because, for each node u in the original graph, they can't both go through the edge u_in -> u_out in the directed graph.\n\nThis image shows a biconnected graph with two node-disjoint paths from 0 to 5:\n\nFinding two edge-disjoint paths in a directed graph can be done with two iterations of the Ford-Fulkerson algorithm. Essentially, we can think of the directed graph as a flow network, where each edge has a capacity of 1. We then need to be able to send two units of flow from s to t. The paths of the flow form two edge-disjoint paths in the directed graph.\n\nBuilding the directed graph takes linear time, and each iteration of Ford-Fulkerson algorithm requires a linear-time graph traversal. Thus, this all takes linear time (see the TypeScript implementation).\n\nEssential edge candidates\n\nAmong all the edges in the biconnected graph, we will start by filtering down the edges that can be part of an essential pair to a smaller set of candidates.\n\nWe start by finding any two node-disjoint paths from s to t, as described above. Which we'll call the red path (R) and the blue path (B). We'll call the edges in R red edges and the edges in B blue edges.\n\nAn edge pair can only be essential if it has one red edge and one blue edge (otherwise, s and t remain connected via one of the two paths). Thus, we can narrow down the set of candidate edges to those in R and B.\n\nWe can narrow the candidate edges further. Consider a red edge, e1. We know that if e1 is part of an essential pair, (e1, e2), then e2 must be a blue edge. So, if s and t remain connected even after removing e1 and all the blue edges, then we can safely say that e1 can never be part of an essential pair. That is, e1 is not a candidate.\n\nWe can find all the red candidates, which we'll call RC = (r1, r2, ..., rk), in linear time, as follows:\n\nRemove all the blue edges from G.\n\nFind all the bridges in the remaining graph.\n\nRC is the list of red bridges.\n\nSimilarly, we can find all the blue candidates, which we'll call BC = (b1, b2, ..., bk'), by removing all the red edges from G and finding the bridges in the remaining graph that overlap with B:\n\nAn edge pair can only be essential if it contains an edge from RC and an edge from BC.\n\nHowever, not every edge pair with one edge in RC and one edge in RB is essential. For example:\n\nIn this graph, the essential pairs are (r1, b1), (r2, b2), and (r3, b2). Other pairs of candidates, like (r1, b2), are not essential. Intuitively, a pair of candidates is not essential when we can stich together parts of the red and blue paths together that avoid the candidates.\n\nThings will get a bit complicated from now on, so it's worth mentioning that, if we wanted to settle for not-always-constant-time queries, we could simply store the sets of red and blue candidates, and only do an s-t reachability check when we get a query with one red candidate and one blue candidate. For every other edge pair, we can simply return False in O(1) time.\n\nThe path-segment graph\n\nWe'll assume that RC and BC are both non-empty from now on (otherwise, we can just return False for every query).\n\nTo achieve worst-case constant-time queries, we'll need to construct what I call the path-segment graph:\n\nThis is an undirected graph that has one node for each disconnected segment of the red path after removing the red candidates, and one node for each disconnected segment of the blue path after removing the blue candidates.\n\nIn the path-segment graph, we call the nodes for the red segments rs_0, rs_1, ..., rs_k and the nodes for the blue segments bs_0, bs_1, ..., bs_k'. We'll also call them red-segment nodes and blue-segment nodes, respectively.\n\nThe nodes rs_0 and rs_1 are connected by an edge, which we call r1, just like in the original graph. Similarly, rs_1 and rs_2 are connected by r2, and so on, up to rs_k-1 and rs_k, which are connected by rk. The same applies to the blue-segment nodes, so every edge in RC and BC is \"present\" in the path-segment graph.\n\nBesides the RC and BC edges, which connect the nodes of the red-segment nodes and blue-segment nodes in two separate paths, there are also cross edges between red-segment and blue-segment nodes. Intuitively, these edges denote that we can go from one segment of the red path to a segment of the blue path without crossing any of the candidate edges.\n\nHere is the path-segment graph for the example above:\n\nThe red path is broken into four segments: rs_0 is just s, rs_1 is just the node between r1 and r2, rs_2 is the segment up to r3, and rs_3 is the final edge of the red path. Similarly, the blue path is broken into three segments.\n\nIn the path-segment graph, there is always a cross edge between rs_0 and bs_0 because they share the node s. Similarly, there is always a cross edge between rs_k and bs_k' because they share the node t. For this specific example, there is also a cross edge between rs_1 and bs_1 because we can walk from the node to the right of s to the segment of B that starts at the node below s without crossing any of the candidate edges.\n\nNext, we'll describe how to compute the cross edges.\n\nIf we take the original graph and remove all the red candidates and all the blue edges (G - RC - B), we are left with a sequence of connected components, each of which contains one of the red-path segments, and perhaps additional connected components that don't contain any of the red-path segments.\n\nWe call RCC_i the connected component in G - RC - B that contains the red segment rs_i. Thus, the red path traverses RCC_0, RCC_1, ..., RCC_k, in this order. We also do the same for the blue path, and call the components BCC_0, BCC_1, ..., BCC_k'.\n\nHere we can see the two sets of connected components for the example above (shown in different colors):\n\nTo compute the cross edges in the path-segment graph, we first label all the nodes in the original graph according to which RCC_i and BCC_j connected components they belong to. Then, we add a cross edge between rs_i and bs_j in the path-segment graph if and only if there is a node in the original graph that is in both RCC_i and BCC_j.\n\nHere is another example of path-segment graph:\n\nIn this graph, the essential pairs are (r1, b1), (r1, b2), (r4, b3), and (r4, b4).\n\nThis example shows that there can be candidates that are not part of any essential pair (r2 and r3 in this case).\n\nYou can create the visualizations above for any grid graph with a visualization tool I vibe coded: https://github.com/nmamano/two-edge-removal-problem/tree/main/python_visualization\n\nThe path-segment graph can be computed in linear time. In particular, it has at most V cross edges, since each cross edge (rs_i, bs_j) requires a node in the original graph contained in both RCC_i and BCC_j.\n\nReducing connectivity in the original graph to connectivity in the path-segment graph\n\nStarting from this section, we need one more bit of notation: we use the subindex >=i to indicate \"all subindices greater than or equal to i\" and the subindex <i to indicate \"all subindices less than i\".\n\nThe following lemma shows that instead of checking if a candidate pair, (ri, bj), disconnects s and t in the original graph, we can check if it disconnects rs_0 and rs_k in the path-segment graph. This makes our job easier since the path-segment graph is structurally simpler than the original graph.\n\nLemma 1: A candidate pair (ri, bj) is essential if and only if it disconnects rs_0 and rs_k in the path-segment graph.\n\nIn other words:\n\nIf removing (ri, bj) disconnects rs_0 and rs_k in the path-segment graph, then it disconnects s and t in the original graph.\n\nIf removing (ri, bj) does not disconnect rs_0 and rs_k in the path-segment graph, then it does not disconnect s and t in the original graph.\n\nStarting with (2), if there is a path from rs_0 to rs_k in the path-segment graph that does not use ri or bj, we can turn it into an s-t path in the original graph that does not use ri or bj either: we follow one of the paths, say R, until we have to use a cross edge in the path-segment graph, say, (rs_x, bs_y). We know that RCC_x and BCC_y share at least a node, v, so we can find a path from one of the nodes in the path segment for rs_x to v and from v to one of the nodes in the path segment for bs_y. We can then continue following the other path, B, until we reach t or need to use another cross edge, which we can handle in the same way.\n\nFor (1), we want to show that there is no s-t path in the original graph without ri and bj.\n\nBy definition, without ri, there is no way to get to RCC_>=i without using blue edges. However, using blue edges before bj still does not allow us to reach any nodes in RCC_>=i (otherwise, rs_0 and rs_k would still be connected in the path-segment graph thanks to a cross edge).\n\n(The proof for (1) is admittedly hand-wavy, I may have to revisit it.)\n\nCompressing the path-segment graph\n\nThe following lemma will allow us to do a final transformation to the path-segment graph to further simplify its structure (the exact reason will be clear later).\n\nLemma 2: The following two statements are equivalent: (a) A candidate pair (ri, bj) is essential; (b) for every cross edge (rs_x, bs_y) in the path-segment graph, ri and bj are both on the same side of that cross edge (i <= x and j <= y, or i > x and j > y).\n\n(a) => (b) direction: Assume, for the sake of contradiction, that (ri, bj) is essential but there is a cross edge (rs_x, bs_y) such that i <= x and j > y. Then, we can go from rs_0 to bs_0, from bs_0 to bs_y, from bs_y to rs_x, and from rs_x to rs_k. This contradicts that (ri, bj) is essential. The other case is symmetric.\n\n(b) => (a) direction: cross edges of the form (s1_<i, s2_<j) do not allow us to \"skip\" over ri and bj. Cross edges of the form (s1_>=i, s2_>=j) have two endpoints neither of which can be reached from rs_0 in the first place.\n\nLemma 2 is important for the following reason:\n\nIf we have a chain of edges in the path-segment graph, rx, ..., ry, without any cross edges coming out of the nodes between them, then all the edges in the chain have all the same cross edges on each side. A corollary of Lemma 2 is that combining any of these edges with a blue candidate, bj, has exactly the same effect on whether rs_0 and rs_k stay connected. Thus, we can compress the chain into a single edge, r_x,y, as shown in the figure:\n\nIn this path-segment graph, we compressed r1, r2, and r3 into r_1,3, left r4 alone (relabeled as r_4,4), and compressed r5 and r6 into r_5,6. The blue candidates got compressed similarly.\n\nThe result is a new graph, which we call the compressed path-segment graph. It is similar to the path-segment graph, but with potentially fewer nodes and edges.\n\nWe call a pair of edges in the compressed path-segment graph, (r_x,y, b_z,w), essential if they disconnect r_0 and r_k. What that means is that any red candidate compressed into r_x,y forms an essential pair with any blue candidate compressed into b_z,w.\n\nThe compressed path-segment graph has the property that every node is adjacent to at least one cross edge. This is important for one reason:\n\nIn the normal path-segment graph, an edge in the top path could form an essential pair with many edges in the bottom path, leading to a potentially quadratic number of essential pairs. In the compressed path-segment graph, each edge in the top path can only form an essential pair with at most one edge in the bottom path. This is because of Lemma 2: there are cross edges between every pair of edges in the bottom path, so only one of them can match the position of the top edge relative to all the cross edges.\n\nFinally, we reached a point where we can store all the essential pairs in O(V) space. We can only do this because each edge of the compressed path-segment graph represents potentially many candidates in the original graph.\n\nNow, we just need to compute them in linear time.\n\nComputing essential pairs in the compressed path-segment graph\n\nWe can use a straightforward two-pointer algorithm, with one pointer for each path. The red pointer starts at the edge r_1,x and the blue pointer starts at the edge b_1,y. For each pointer, we keep track of which cross edges we've already passed. Then, we have a case analysis:\n\nIf both pointers have passed the same cross edges, mark the current edge pair as essential, and advance both pointers.\n\nIf the red pointer has passed any cross edges that the blue pointer hasn't passed, advance the blue pointer.\n\nIf the blue pointer has passed any cross edges that the red pointer hasn't passed, advance the red pointer.\n\nWith this method, we can find and store all the essential pairs in the compressed path-segment graph in O(V) time.\n\nTo know if a pair of candidates (ri, bj) in G is essential, we check if the compressed edges they belong to form an essential pair in the compressed path-segment graph.\n\nImplementation\n\nIn this section, we'll see how all the pieces fit together by designing the full data structure as described at the beginning of the post.\n\nThe data structure is implemented in TypeScript here. There is also the brute-force solution, tests, the visualization tool (in Python), and a little benchmark we'll use for the next section.\n\nConstruction:\n\nThe only constraint on G is that s and t are connected and different.\n\nTime and space: O(V + E).\n\nTime and space: O(1).\n\nI generated 10 random 30x30 grid graphs, where each edge is present with probability 0.5. For each graph, I picked s and t randomly, making sure that s and t were connected.\n\nI then initialized the data structure for each graph and queried it with every edge pair in the graph. I also ran all the queries with the brute-force solution.\n\nHere are the results:\n\nThe bigger the graph, the more queries we can do, and thus the more the preprocessing pays off. With 11x11 grid graphs, which is the standard size for the Wall Game, we do only ~15k queries per graph, and the speedup is only about 6x.\n\nFor both 30x30 and 11x11 grid graphs, the construction of the data structures is about 3 orders of magnitude slower than solving a single query directly with a graph traversal. This is surprising, given the optimized data structure only does a constant number of graph traversals (about 10). My theory is that the overhead comes from allocating memory (e.g., for the various derived graphs; the keyword new appears ~30 times in the code) and from the use of hash sets and maps.\n\nOptimizing the code was not the main point of this post. It can be optimized further by doing things like:\n\nPre-allocating and reusing the visited and stack arrays across all the functions that need to do some kind of graph traversal.\n\nNot explicitly constructing the directed graph in findTwoNodeDisjointPaths().\n\nNot explicitly constructing graphs like G - R, G - B, G - R - BC, and G - B - RC. Instead, we can pass around a set of \"disallowed\" edges. (The path-segment graph and the compressed path-segment graphs are already not constructed explicitly.)\n\nAvoiding hash sets and maps with edges as keys. Instead, edges could be mapped to contiguous integers from 0 to E - 1 (I already avoided using sets and maps when the keys are integers starting at 0, like node indices).\n\nChoosing a better language for low-level optimizations...\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/double-edge-cut-problem#the-path-segment-graph",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game UI Design (+ Frontend Generators)",
      "content": "Wall Game UI Design (+ Frontend Generators)\n\nThis blog post is a design doc for the frontend of wallgame.io, a board game I'm making. However, something probably more interesting came out of it: an assessment of frontend generators' ability to one-shot a 6000-word design doc prompt. The results deeply impressed me. They are in an appendix at the bottom. Feel free to skip the design doc and check out the appendix.\n\nThis is the specification of the frontend for the Wall Game, an online strategy board game. It only specifies the logic/functionality. It is agnostic of the look.\n\nA first version of the game is already available at wallwars.net. This is a UI overhaul with the following goals:\n\nA smooth onboarding experience. It should be very clear how to navigate the site and in what order to do things.\n\nTeaching the game to new players in a structured way.\n\nExpansive solo modes so that players can have fun even if there is no one else online.\n\nImproving the user journey of inviting friends to play.\n\nSupporting game variants as a first-class feature (this was a key feature for replayability when playing with a physical board).\n\nSupporting game variants with a varying number of players.\n\nSupporting multiple bots, including custom bots to foster the \"engine dev\" community.\n\nClean interface to game data, like past games, player history, rankings, etc., by showing interlinked tables with SQL-like features like filtering.\n\nMore \"social\" features, like an in-game chat and the ability to watch live games.\n\nFrontend Overview\n\nThe site is a SPA (single page app). There are 9 main pages, all of which are accessible from the top navigation bar. If a screen is not wide enough to show all the tabs, they are collapsed as necessary into a hamburger menu icon. Tabs act as buttons to show the corresponding page. Pages are self-contained and have their own URL:\n\nIn order, the tabs are:\n\nPlay (default) - wallgame.io\n\nRanking - wallgame.io/ranking\n\nPast games - wallgame.io/past-games\n\nLive games - wallgame.io/live-games\n\nLearn - wallgame.io/learn\n\nAbout - wallgame.io/about\n\nSettings - wallgame.io/settings\n\nProfile (appears as Login if the user is not logged in) - wallgame.io/profile\n\nThe navigation bar is always visible, and the current tab is highlighted.\n\nWe'll first go over the basic concepts, then some of the basic components reused across multiple pages, and finally, we'll go over each page (out of order).\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nPlayer types: there are 5 player types in the context of a game created by a user: \"You\": the user itself. \"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.) \"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\"). \"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game. \"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nPlayer types: there are 5 player types in the context of a game created by a user:\n\n\"You\": the user itself.\n\n\"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.)\n\n\"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\").\n\n\"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game.\n\n\"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter): The user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win). The user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully. The user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter):\n\nThe user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win).\n\nThe user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully.\n\nThe user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nThis section describes specific high-level components of the UI, which are reused in various places.\n\nThis is the main component involved in playing the game.\n\nA rectangular grid of square cells, with thick margins between them (that's where the walls go).\n\nA cell may contain one or more pawns. There is no limit on how many pawns can be in the same cell.\n\nA staged or premoved pawn move is shown with an arrow. Arbitrary arrows can also be added as calculations. It should be clear which one is which.\n\nBetween every two cells adjacent vertically or horizontally, there is a space where a wall can be placed, staged, premoved, calculated, or missing.\n\nThe corner between four cells is called a \"pillar\" and is not an interactable element.\n\nPlaced walls are colored according to the color of the pawns of the player who placed them.\n\nSimilar to chess and checkers, the cells are colored alternatively, so that cells that are an even number of moves away from each other share a color. The contrast between the two colors is subtle.\n\nLike chess, rows are labeled with numbers (starting from 1 on the top) and columns are labeled with letters (starting from 'a' on the left). The first cell in each row is labeled with the corresponding row number. The first cell in each column is labeled with the corresponding column letter. The labels are subtle, taking only a corner of the cell.\n\nThe last move is highlighted so it is easy for players to see what the opponent just did.\n\nThis includes the board itself and surrounding elements for any related information and interactions:\n\nthe timers. The timer of the player to move is highlighted.\n\nthe player names and ELOs. The name of the player to move is highlighted.\n\nthe move history in standard notation, with buttons to go back and forth and buttons to go to the beginning and latest move.\n\nthe chat. The chat can have multiple \"channels\": the \"game chat\", seen by all the players but not the audience the \"team chat\", seen only by players on the same team the \"audience chat\", seen only by the audience\n\nthe \"game chat\", seen by all the players but not the audience\n\nthe \"team chat\", seen only by players on the same team\n\nthe \"audience chat\", seen only by the audience\n\nan indicator of whose turn it is\n\nonline indicators for each player (if a player does not have the game tab/app active, it shows as offline)\n\nmenus for out-of-game interactions: \"resign\", \"offer draw\", \"propose take back\", \"give time (1 min)\", \"rematch\"\n\na button to toggle sounds\n\ncontextual information: the game variant and parameters the time control rated status the match score whose turn it is the player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\") after the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\nthe game variant and parameters\n\nthe time control\n\nrated status\n\nthe match score\n\nwhose turn it is\n\nthe player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\")\n\nafter the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\na button to see/copy the game's replay notation and standard notation\n\nGame configuration panel\n\nThis includes all the configuration options for a game.\n\ntime control: a selector with the options \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\".\n\nrated status: yes/no. If the player is not logged in, the 'rated status' is set to \"no\" and grayed out. There should be an informational text that says that the user needs to be logged in to play rated games.\n\nvariant: a selector of supported variants.\n\nadditional parameters that depend on the variant. These parameters appear in a container, and the container changes depending on the variant.\n\nFor example, for the standard variant:\n\nBoard width: number. Default: 8\n\nBoard height: number. Default: 8\n\nPlayer configuration\n\nA little component that lets you configure how a player in a game will move. It consists of a selector with a few options, each of which has an informational text.\n\n\"You\": \"You'll make the moves.\"\n\n\"Friend\": \"You'll get a link to share with a friend to join the game.\"\n\n\"Matched user\": \"You'll be paired with a random player with compatible settings and similar rating.\"\n\n\"Easy Bot\": \"You'll play against an easy AI bot.\"\n\n\"Medium Bot\": \"You'll play against a medium AI bot.\"\n\n\"Hard Bot\": \"You'll play against a hard AI bot.\"\n\n\"Custom bot\": \"You'll get an access token so that you can connect your own bot. See here for more information.\" The text links to a blog post explaining how to make a custom bot and connect it to the game using the token.\n\nThere is no default. It depends on the context.\n\nGame setup page\n\nThis page has its own URL: wallgame.io/game-setup.\n\nIt has two sections:\n\nCreate game\n\nCreate game\n\nThis part has the following elements:\n\nA button: \"Create game\".\n\nA player configuration component for each player (which depends on the variant, as set in #4). The selectors are labeled \"Player 1\", \"Player 2\", and so on. The default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe selectors are labeled \"Player 1\", \"Player 2\", and so on.\n\nThe default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe game configuration panel. Choosing a variant with more than 2 players will affect the number of player configuration components in #2.\n\nThis part has the following elements:\n\nA heading \"Join game\"\n\nA table showing games from other players that are in the \"matching stage\" and waiting for someone to join.\n\nThe table has the following columns:\n\nJoin: a button which, when clicked, joins the game.\n\nRated: yes/no.\n\nTime control: a string formatted like \"blitz (3+2)\"\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height).\n\nPlayer: a string formatted like \"name1 (1200)\". The numbers in parentheses is the rating. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (XXX) & name2 (YYY) vs name3 (ZZZ)\".\n\nThe rows are ordered by ELO closest to the current user's ELO. If the user chose a variant, rated status, time control, or board size in the game configuration panel, rows matching those settings are prioritized. Games that have been in \"matching stage\" for longer are also prioritized.\n\nThe parameterized URL is wallgame.io/game/game-id\n\nThe game page shows a game, identified with a given game ID in the URL. The game could be in the \"matching stage\", ongoing, or finished (a past game) The URL can be shared to join the game (if it is in the \"matching stage\"), to spectate it live (if it is ongoing) or watch it as a past game (if it is finished).\n\nThe game page has one main component: the board view.\n\nDepending on the context, it could contain other elements. See, e.g., the case of the \"Solo campaign\" puzzles, which contain an additional explanation text. So far, this seems to be the only exception.\n\nMatching stage panel\n\nWhen a user creates a game from wallgame.io/game-setup, a game ID is generated and they are taken to the game page with that game ID.\n\nHowever, it is possible that not all players are ready. For instance, if one of the player types is \"friend\", the game cannot start until the friend joins the game.\n\nIf not all players are ready, a \"matching stage\" panel component is shown as a modal over a faded out version of the game page.\n\nThe modal has a title: \"Waiting for players\". It contains one row for each player. Each row contains:\n\nThe player type (e.g., \"You\", \"Friend\", \"Easy Bot\", \"Medium Bot\", \"Hard Bot\", \"Custom Bot\", \"Matched player\")\n\nAn indication of whether the player is ready.\n\nInstructions for how that player should join the game If the player is \"You\", the player is automatically ready. If the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard. If the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready. If the player is \"Custom Bot\", the instructions include an access token for a custom bot. If the player is \"Matched player\", the instructions are to wait for someone to join.\n\nIf the player is \"You\", the player is automatically ready.\n\nIf the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard.\n\nIf the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready.\n\nIf the player is \"Custom Bot\", the instructions include an access token for a custom bot.\n\nIf the player is \"Matched player\", the instructions are to wait for someone to join.\n\nA button to abort the game and return to the previous page.\n\nIf a player joins a game but there are other players that are not ready (in the case of variants with more than 2 players), they will also see the matching stage panel.\n\nTab 7: Settings\n\nSettings have three sections:\n\nUser settings\n\nVisual style\n\nDefault game parameters\n\nFor sections 2 and 3, there should be an information box indicating that if the user is not logged in, they are saved as local cookies in the web browser. If they are logged in, the settings are saved to their account instead.\n\n1. User settings\n\nThis has one field:\n\nDisplay name (text field)\n\nIt behaves a bit differently depending on if the user is logged in.\n\nFor logged in users, the display name shows their current name and it is editable.\n\nThere should be a button next to the \"display name\" text field that says \"Change if available\" and an informational text that says \"Names must be unique across the site (case insensitive). You can only switch to another name not already in use.\" The button should be grayed out if the text field matches their current name. Names including \"guest\" or \"deleted\" or \"bot\" are not allowed. If the user tries to change to such a name, it should be explained to them.\n\nIf the user is not logged in, the display name should be grayed out and fixed as: \"Guest\"\n\nThere should also be an indication that the user needs to be logged in to change their display name, with a button to the Profile page.\n\n2. Visual style\n\nDark theme: on/off. Default: on\n\nBoard theme: selector. Default: \"classic\".\n\nPawn color: selector. Default: default.\n\nCat pawn: selector.\n\nMouse pawn: selector.\n\n... (one selector for each pawn type that appears in any variant)\n\nThe pawn selectors are between icons/small images.\n\n3. Default game parameters.\n\nThis is the game configuration panel component.\n\nA text says, \"When setting up a game, these parameters will be used as default.\"\n\nTab 6: About\n\nThis contains short informational text. The text can be something like this:\n\n\"Wall Game is a board game about building walls and outsmarting your opponents. It is inspired by Quoridor (wiki link) and Blockade (wiki link). Basic instructions about navigating the website (where to find the rules etc). Created by Nil Mamano (link). For more, you can read the blog (link).\"\n\nTab 8: Profile\n\nThis page looks different depending on whether the user is logged in or not.\n\nNot logged in\n\nThe tab appears as \"Login\".\n\nThe page shows two main buttons: log in and sign up\n\nIt includes a bit of text: \"Log in or sign up to choose a name, play rated games, and see your game history.\"\n\nFor the login and sign up flows, the user is redirected to an external auth service, so they are not part of this UI.\n\nThe tab appears as \"Profile\".\n\nIt shows the user display name and rating at the top, followed by a series of buttons grouped in two groups:\n\nPast Games: takes you to the Past Games tab but with the user's name already set as filter.\n\nRanking: takes you to the Ranking tab but with the user's name already set as filter.\n\nSettings: takes you to the settings page.\n\nDelete account\n\nThe delete account button shows a confirmation dialog: \"Your email will be deleted from the DB and all games you played will appear as 'Deleted User' and you won't be able to play again with this account. Are you sure?\"\n\nTab 3: Past games\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default. Filters are added as query parameters to the URL, so they can be shared.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nPlayer: text field (empty field acts as \"all\")\n\nPlayer: text field (empty field acts as \"all\").\n\nTime period: a date range\n\nThe two player fields serve the same purpose. Filling only one gives you all games with that player. Filling both gives you all games including both players.\n\nGames with fewer than 2 moves are filtered out. Games aborted during the \"matching stage\" are not even stored.\n\nThe rows are ordered by date. The order cannot be changed.\n\nWatch: a button which, when clicked, takes you to see the past game.\n\nVariant: clicking on a variant sets the variant filter.\n\nRated: yes/no. Clicking on a rating sets the rated status filter.\n\nTime control: a string formatted like \"blitz (3+2)\". Clicking on a time control sets the time control filter.\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height). Clicking on a board size sets the board size filter.\n\nPlayers: a string formatted like \"name1 (1200) vs name2 (1234)\". The numbers in parentheses are the ratings at the start of the game. Clicking on a name sets the first player filter. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (1200) & name2 (1234) vs name3 (1234) & name4 (1234)\". Clicking on the \"vs\" sets both player filters, with slight tweaks depending on the variant.\n\nMoves: a number. The number of moves of the game.\n\nViews: a number. The number of views the game got.\n\ndate: date type. When the game was played.\n\nThe name of the winning player is highlighted. Draws are also indicated.\n\nPast game view\n\nWhen a user clicks the \"Watch\" button for a past game, they are taken to the \"game page\" for that game (e.g., wallgame.io/game/2ei3nd43).\n\nThe final position is shown by default.\n\nThe chat is grayed out with a message that says \"Chat is not preserved.\"\n\nTab 4: Live games\n\nSimilar to the \"Past games\" page, this page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nThe formatting of the columns is the same as for \"Past Games\".\n\nWatch: a button that takes you to spectate the game in real time.\n\nViewers: a number.\n\nVariant: see \"Past games\" table.\n\nRated: see \"Past games\" table.\n\nTime control: see \"Past games\" table.\n\nBoard size: see \"Past games\" table.\n\nPlayers: see \"Past games\" table.\n\nMoves: see \"Past games\" table.\n\nThe rows are sorted by viewers first, by max ELO second.\n\nWhen a game ends, the number of spectators becomes the initial number of views in the past games table.\n\nLive game view\n\nWhen a user clicks the \"Watch\" button for a live game, they are taken to the \"game page\" for that game (e.g., wallgame.io/live/2ei3nd43).\n\nThe latest state of the game is shown by default.\n\nAs players make moves, spectators receive and see real-time updates.\n\nSpectators see the \"Spectator chat\", which is different than the ones the players see.\n\nTab 2: Ranking\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe filters do not have an \"all\" option.\n\nVariant: default: standard\n\nTime control: default: rapid\n\nPlayer: text field. Default: empty. The player filter acts more like a search box. If filled and the player exists, it only shows the row corresponding to that player and a few rows before and after. If the player does not exist, it shows nothing.\n\nRank: number starting at 1\n\nPlayer: the display name. It updates whenever players change their names delete their accounts.\n\nRating: the ELO rating. These are numbers sorted in decreasing order.\n\nPeak rating: the max ELO rating that player has ever had.\n\nRecord: a string formatted like \"10-4\" indicating the number of points the player got and lost across all its games.\n\nFirst game: a date.\n\nLast game: a date.\n\nClicking anywhere on a row takes you to the \"Past games\" page with the variant, time control, and player filters set. The \"rated\" filter is also set to \"yes\".\n\nTab 5: Learn\n\nThis page contains only static content, in four sections:\n\nRules (standard)\n\nNotation (standard)\n\nLessons (standard)\n\nAll the sections may contain images.\n\nSections can be collapsed.\n\nThis contains a couple of paragraphs explaining the rules of the \"standard\" variant.\n\nIt ends with: \"You can now start the solo campaign.\", with a link to the play tab (wallgame.io).\n\nThis contains a couple of paragraphs explaining the standard notation. This is useful since it appears in the game history element of the \"board view\" component.\n\nThis contains a bullet point list of links to blog posts explaining strategic and tactical ideas. More lessons can be added over time.\n\nThis contains definitions and special rules for all the supported variants.\n\nTab 1: Play\n\nThis is the 'landing' page.\n\nIts main purpose is to easily access the 6 game modes:\n\nSolo campaign\n\nStudy board\n\nPlay with others\n\nInvite friend\n\nIt contains three sections:\n\nSingle-player fun\n\nPlay with others\n\nGame showcase\n\nThe first two contain various buttons to go to the various game modes. The final one is just decorative. It's not there because it's related to the \"Play\" theme, but because it's the landing page.\n\nSingle-player fun\n\nThis section contains the following buttons:\n\nSolo campaign. There is an annotation that says \"Start here!\"\n\nStudy board\n\nPlay with others\n\nThis section contains the following buttons:\n\nFind others\n\nInvite friend\n\nGame showcase\n\nThis section shows a board and autoplays random past games, at high speed (2 moves per second). Above the board, a text says: \"Game showcase: name1 (1200) vs name2 (1234) (DATE)\", with the players and date updating as the game changes. There should also be a button to stop the autoplay.\n\nClicking on it takes you to the \"game page\" to watch the game, analogous to the \"Past games\" page. The only difference is that the game starts at the position that last played automatically in the game showcase.\n\nGame mode 2: Puzzles\n\nThe URL is wallgame.io/puzzles\n\nThe puzzles page has a list of puzzles.\n\nEach puzzle has:\n\nplay button\n\ndifficulty rating\n\ncompleted: yes/no. An indication of whether the user already solved it\n\nIf the user is not logged in, the 'completed' status is grayed out. There should be an information box indicating that the user should log in to save their completion status.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/puzzles/1, where 1 is the puzzle number. This makes it so that the user can share a puzzle by sharing the route.\n\nGame mode 1: Solo campaign\n\nThe URL is wallgame.io/solo-campaign\n\nThe solo campaign menu consists of a list of puzzles just like the menu for puzzles.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/solo-campaign/1, where 1 is the puzzle number.\n\nUnlike in normal puzzles, in solo campaign puzzles:\n\nThere is a text above the board view indicating what to do to win.\n\nThe game is usually played until the end.\n\nGame mode 3: Play vs AI\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Easy Bot\".\n\nGame mode 5: Play with others\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Matched user\".\n\nGame mode 6: Invite friend\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Friend\".\n\nGame mode 4: Study board\n\nThis takes you to a special instance of the \"game page\" with route wallgame.io/study-board.\n\nThe design for the study board page is work in progress.\n\nFinal thoughts\n\nI usually figure out the shape of things as I build them, like I did for wallwars.net, instead of writing a long design doc upfront. However:\n\nTo justify a full rewrite, I wanted to make sure the new design would accomplish the improvements that I wanted to see on the original site (see the list at the beginning of this post).\n\nAI-assisted coding has made all coding easier, but it has improved new code generation more than it has improved refactoring. For me, this shifted the tradeoff to the point where it seemed worth it to try to preempt as many direction shifts as possible.\n\nIn any case, now that I have this doc, I think it's a good opportunity to test out the various frontend generators (lovable and company) and see what they spit out. I probably won't use any of them directly, but they should give me good ideas for the styling.\n\nI fed this whole blog post to v0.dev (free tier). The prompt was \"Create mocks for the attached design doc.\" + this blog post, which is about 6000 words (a 33kB attachment).\n\nApart from putting the files in the wrong directory, it one-shotted the whole app with great prompt adherence and, in my opinion, great taste to fill in the gaps (recall that this design doc says basically nothing about styling).\n\nYou can see the results below (I skipped the less interesting pages).\n\nI emphasize that I did not have to break down the prompt into smaller chunks, as I'm so used to with tools like Cursor or basically anything LLM-based. I did not have to go screen by screen. It generated about 20 files and 3000 lines of next.js, with all navigation working as expected and mock data. I did not have to carefully craft a prompt on top of the design doc (though you can argue that this blog post is a great prompt). As someone who uses vibe coding regularly, this truly impressed me.\n\nI tried other frontend generators with the same prompt. lovable.dev did OK with prompt adherence (some pages did not work), but it did not have the same taste as v0.dev. It looks like a generic corporate site. Lovable's board component also looks messed up.\n\nbolt.new had great prompt adherence, about the same as v0.dev, but the site looked generic like lovable's (and the board was also messed up). V0 had the best use of space.\n\nOther tools I tried had a prompt length limit, so I didn't bother.\n\nIn the end, I just went back to v0.dev and used the rest of my daily free credits to ask it for different color themes.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-ui?category=wallgame#game-page",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game UI Design (+ Frontend Generators)",
      "content": "Wall Game UI Design (+ Frontend Generators)\n\nThis blog post is a design doc for the frontend of wallgame.io, a board game I'm making. However, something probably more interesting came out of it: an assessment of frontend generators' ability to one-shot a 6000-word design doc prompt. The results deeply impressed me. They are in an appendix at the bottom. Feel free to skip the design doc and check out the appendix.\n\nThis is the specification of the frontend for the Wall Game, an online strategy board game. It only specifies the logic/functionality. It is agnostic of the look.\n\nA first version of the game is already available at wallwars.net. This is a UI overhaul with the following goals:\n\nA smooth onboarding experience. It should be very clear how to navigate the site and in what order to do things.\n\nTeaching the game to new players in a structured way.\n\nExpansive solo modes so that players can have fun even if there is no one else online.\n\nImproving the user journey of inviting friends to play.\n\nSupporting game variants as a first-class feature (this was a key feature for replayability when playing with a physical board).\n\nSupporting game variants with a varying number of players.\n\nSupporting multiple bots, including custom bots to foster the \"engine dev\" community.\n\nClean interface to game data, like past games, player history, rankings, etc., by showing interlinked tables with SQL-like features like filtering.\n\nMore \"social\" features, like an in-game chat and the ability to watch live games.\n\nFrontend Overview\n\nThe site is a SPA (single page app). There are 9 main pages, all of which are accessible from the top navigation bar. If a screen is not wide enough to show all the tabs, they are collapsed as necessary into a hamburger menu icon. Tabs act as buttons to show the corresponding page. Pages are self-contained and have their own URL:\n\nIn order, the tabs are:\n\nPlay (default) - wallgame.io\n\nRanking - wallgame.io/ranking\n\nPast games - wallgame.io/past-games\n\nLive games - wallgame.io/live-games\n\nLearn - wallgame.io/learn\n\nAbout - wallgame.io/about\n\nSettings - wallgame.io/settings\n\nProfile (appears as Login if the user is not logged in) - wallgame.io/profile\n\nThe navigation bar is always visible, and the current tab is highlighted.\n\nWe'll first go over the basic concepts, then some of the basic components reused across multiple pages, and finally, we'll go over each page (out of order).\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nPlayer types: there are 5 player types in the context of a game created by a user: \"You\": the user itself. \"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.) \"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\"). \"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game. \"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nPlayer types: there are 5 player types in the context of a game created by a user:\n\n\"You\": the user itself.\n\n\"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.)\n\n\"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\").\n\n\"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game.\n\n\"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter): The user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win). The user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully. The user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter):\n\nThe user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win).\n\nThe user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully.\n\nThe user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nThis section describes specific high-level components of the UI, which are reused in various places.\n\nThis is the main component involved in playing the game.\n\nA rectangular grid of square cells, with thick margins between them (that's where the walls go).\n\nA cell may contain one or more pawns. There is no limit on how many pawns can be in the same cell.\n\nA staged or premoved pawn move is shown with an arrow. Arbitrary arrows can also be added as calculations. It should be clear which one is which.\n\nBetween every two cells adjacent vertically or horizontally, there is a space where a wall can be placed, staged, premoved, calculated, or missing.\n\nThe corner between four cells is called a \"pillar\" and is not an interactable element.\n\nPlaced walls are colored according to the color of the pawns of the player who placed them.\n\nSimilar to chess and checkers, the cells are colored alternatively, so that cells that are an even number of moves away from each other share a color. The contrast between the two colors is subtle.\n\nLike chess, rows are labeled with numbers (starting from 1 on the top) and columns are labeled with letters (starting from 'a' on the left). The first cell in each row is labeled with the corresponding row number. The first cell in each column is labeled with the corresponding column letter. The labels are subtle, taking only a corner of the cell.\n\nThe last move is highlighted so it is easy for players to see what the opponent just did.\n\nThis includes the board itself and surrounding elements for any related information and interactions:\n\nthe timers. The timer of the player to move is highlighted.\n\nthe player names and ELOs. The name of the player to move is highlighted.\n\nthe move history in standard notation, with buttons to go back and forth and buttons to go to the beginning and latest move.\n\nthe chat. The chat can have multiple \"channels\": the \"game chat\", seen by all the players but not the audience the \"team chat\", seen only by players on the same team the \"audience chat\", seen only by the audience\n\nthe \"game chat\", seen by all the players but not the audience\n\nthe \"team chat\", seen only by players on the same team\n\nthe \"audience chat\", seen only by the audience\n\nan indicator of whose turn it is\n\nonline indicators for each player (if a player does not have the game tab/app active, it shows as offline)\n\nmenus for out-of-game interactions: \"resign\", \"offer draw\", \"propose take back\", \"give time (1 min)\", \"rematch\"\n\na button to toggle sounds\n\ncontextual information: the game variant and parameters the time control rated status the match score whose turn it is the player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\") after the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\nthe game variant and parameters\n\nthe time control\n\nrated status\n\nthe match score\n\nwhose turn it is\n\nthe player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\")\n\nafter the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\na button to see/copy the game's replay notation and standard notation\n\nGame configuration panel\n\nThis includes all the configuration options for a game.\n\ntime control: a selector with the options \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\".\n\nrated status: yes/no. If the player is not logged in, the 'rated status' is set to \"no\" and grayed out. There should be an informational text that says that the user needs to be logged in to play rated games.\n\nvariant: a selector of supported variants.\n\nadditional parameters that depend on the variant. These parameters appear in a container, and the container changes depending on the variant.\n\nFor example, for the standard variant:\n\nBoard width: number. Default: 8\n\nBoard height: number. Default: 8\n\nPlayer configuration\n\nA little component that lets you configure how a player in a game will move. It consists of a selector with a few options, each of which has an informational text.\n\n\"You\": \"You'll make the moves.\"\n\n\"Friend\": \"You'll get a link to share with a friend to join the game.\"\n\n\"Matched user\": \"You'll be paired with a random player with compatible settings and similar rating.\"\n\n\"Easy Bot\": \"You'll play against an easy AI bot.\"\n\n\"Medium Bot\": \"You'll play against a medium AI bot.\"\n\n\"Hard Bot\": \"You'll play against a hard AI bot.\"\n\n\"Custom bot\": \"You'll get an access token so that you can connect your own bot. See here for more information.\" The text links to a blog post explaining how to make a custom bot and connect it to the game using the token.\n\nThere is no default. It depends on the context.\n\nGame setup page\n\nThis page has its own URL: wallgame.io/game-setup.\n\nIt has two sections:\n\nCreate game\n\nCreate game\n\nThis part has the following elements:\n\nA button: \"Create game\".\n\nA player configuration component for each player (which depends on the variant, as set in #4). The selectors are labeled \"Player 1\", \"Player 2\", and so on. The default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe selectors are labeled \"Player 1\", \"Player 2\", and so on.\n\nThe default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe game configuration panel. Choosing a variant with more than 2 players will affect the number of player configuration components in #2.\n\nThis part has the following elements:\n\nA heading \"Join game\"\n\nA table showing games from other players that are in the \"matching stage\" and waiting for someone to join.\n\nThe table has the following columns:\n\nJoin: a button which, when clicked, joins the game.\n\nRated: yes/no.\n\nTime control: a string formatted like \"blitz (3+2)\"\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height).\n\nPlayer: a string formatted like \"name1 (1200)\". The numbers in parentheses is the rating. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (XXX) & name2 (YYY) vs name3 (ZZZ)\".\n\nThe rows are ordered by ELO closest to the current user's ELO. If the user chose a variant, rated status, time control, or board size in the game configuration panel, rows matching those settings are prioritized. Games that have been in \"matching stage\" for longer are also prioritized.\n\nThe parameterized URL is wallgame.io/game/game-id\n\nThe game page shows a game, identified with a given game ID in the URL. The game could be in the \"matching stage\", ongoing, or finished (a past game) The URL can be shared to join the game (if it is in the \"matching stage\"), to spectate it live (if it is ongoing) or watch it as a past game (if it is finished).\n\nThe game page has one main component: the board view.\n\nDepending on the context, it could contain other elements. See, e.g., the case of the \"Solo campaign\" puzzles, which contain an additional explanation text. So far, this seems to be the only exception.\n\nMatching stage panel\n\nWhen a user creates a game from wallgame.io/game-setup, a game ID is generated and they are taken to the game page with that game ID.\n\nHowever, it is possible that not all players are ready. For instance, if one of the player types is \"friend\", the game cannot start until the friend joins the game.\n\nIf not all players are ready, a \"matching stage\" panel component is shown as a modal over a faded out version of the game page.\n\nThe modal has a title: \"Waiting for players\". It contains one row for each player. Each row contains:\n\nThe player type (e.g., \"You\", \"Friend\", \"Easy Bot\", \"Medium Bot\", \"Hard Bot\", \"Custom Bot\", \"Matched player\")\n\nAn indication of whether the player is ready.\n\nInstructions for how that player should join the game If the player is \"You\", the player is automatically ready. If the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard. If the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready. If the player is \"Custom Bot\", the instructions include an access token for a custom bot. If the player is \"Matched player\", the instructions are to wait for someone to join.\n\nIf the player is \"You\", the player is automatically ready.\n\nIf the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard.\n\nIf the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready.\n\nIf the player is \"Custom Bot\", the instructions include an access token for a custom bot.\n\nIf the player is \"Matched player\", the instructions are to wait for someone to join.\n\nA button to abort the game and return to the previous page.\n\nIf a player joins a game but there are other players that are not ready (in the case of variants with more than 2 players), they will also see the matching stage panel.\n\nTab 7: Settings\n\nSettings have three sections:\n\nUser settings\n\nVisual style\n\nDefault game parameters\n\nFor sections 2 and 3, there should be an information box indicating that if the user is not logged in, they are saved as local cookies in the web browser. If they are logged in, the settings are saved to their account instead.\n\n1. User settings\n\nThis has one field:\n\nDisplay name (text field)\n\nIt behaves a bit differently depending on if the user is logged in.\n\nFor logged in users, the display name shows their current name and it is editable.\n\nThere should be a button next to the \"display name\" text field that says \"Change if available\" and an informational text that says \"Names must be unique across the site (case insensitive). You can only switch to another name not already in use.\" The button should be grayed out if the text field matches their current name. Names including \"guest\" or \"deleted\" or \"bot\" are not allowed. If the user tries to change to such a name, it should be explained to them.\n\nIf the user is not logged in, the display name should be grayed out and fixed as: \"Guest\"\n\nThere should also be an indication that the user needs to be logged in to change their display name, with a button to the Profile page.\n\n2. Visual style\n\nDark theme: on/off. Default: on\n\nBoard theme: selector. Default: \"classic\".\n\nPawn color: selector. Default: default.\n\nCat pawn: selector.\n\nMouse pawn: selector.\n\n... (one selector for each pawn type that appears in any variant)\n\nThe pawn selectors are between icons/small images.\n\n3. Default game parameters.\n\nThis is the game configuration panel component.\n\nA text says, \"When setting up a game, these parameters will be used as default.\"\n\nTab 6: About\n\nThis contains short informational text. The text can be something like this:\n\n\"Wall Game is a board game about building walls and outsmarting your opponents. It is inspired by Quoridor (wiki link) and Blockade (wiki link). Basic instructions about navigating the website (where to find the rules etc). Created by Nil Mamano (link). For more, you can read the blog (link).\"\n\nTab 8: Profile\n\nThis page looks different depending on whether the user is logged in or not.\n\nNot logged in\n\nThe tab appears as \"Login\".\n\nThe page shows two main buttons: log in and sign up\n\nIt includes a bit of text: \"Log in or sign up to choose a name, play rated games, and see your game history.\"\n\nFor the login and sign up flows, the user is redirected to an external auth service, so they are not part of this UI.\n\nThe tab appears as \"Profile\".\n\nIt shows the user display name and rating at the top, followed by a series of buttons grouped in two groups:\n\nPast Games: takes you to the Past Games tab but with the user's name already set as filter.\n\nRanking: takes you to the Ranking tab but with the user's name already set as filter.\n\nSettings: takes you to the settings page.\n\nDelete account\n\nThe delete account button shows a confirmation dialog: \"Your email will be deleted from the DB and all games you played will appear as 'Deleted User' and you won't be able to play again with this account. Are you sure?\"\n\nTab 3: Past games\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default. Filters are added as query parameters to the URL, so they can be shared.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nPlayer: text field (empty field acts as \"all\")\n\nPlayer: text field (empty field acts as \"all\").\n\nTime period: a date range\n\nThe two player fields serve the same purpose. Filling only one gives you all games with that player. Filling both gives you all games including both players.\n\nGames with fewer than 2 moves are filtered out. Games aborted during the \"matching stage\" are not even stored.\n\nThe rows are ordered by date. The order cannot be changed.\n\nWatch: a button which, when clicked, takes you to see the past game.\n\nVariant: clicking on a variant sets the variant filter.\n\nRated: yes/no. Clicking on a rating sets the rated status filter.\n\nTime control: a string formatted like \"blitz (3+2)\". Clicking on a time control sets the time control filter.\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height). Clicking on a board size sets the board size filter.\n\nPlayers: a string formatted like \"name1 (1200) vs name2 (1234)\". The numbers in parentheses are the ratings at the start of the game. Clicking on a name sets the first player filter. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (1200) & name2 (1234) vs name3 (1234) & name4 (1234)\". Clicking on the \"vs\" sets both player filters, with slight tweaks depending on the variant.\n\nMoves: a number. The number of moves of the game.\n\nViews: a number. The number of views the game got.\n\ndate: date type. When the game was played.\n\nThe name of the winning player is highlighted. Draws are also indicated.\n\nPast game view\n\nWhen a user clicks the \"Watch\" button for a past game, they are taken to the \"game page\" for that game (e.g., wallgame.io/game/2ei3nd43).\n\nThe final position is shown by default.\n\nThe chat is grayed out with a message that says \"Chat is not preserved.\"\n\nTab 4: Live games\n\nSimilar to the \"Past games\" page, this page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nThe formatting of the columns is the same as for \"Past Games\".\n\nWatch: a button that takes you to spectate the game in real time.\n\nViewers: a number.\n\nVariant: see \"Past games\" table.\n\nRated: see \"Past games\" table.\n\nTime control: see \"Past games\" table.\n\nBoard size: see \"Past games\" table.\n\nPlayers: see \"Past games\" table.\n\nMoves: see \"Past games\" table.\n\nThe rows are sorted by viewers first, by max ELO second.\n\nWhen a game ends, the number of spectators becomes the initial number of views in the past games table.\n\nLive game view\n\nWhen a user clicks the \"Watch\" button for a live game, they are taken to the \"game page\" for that game (e.g., wallgame.io/live/2ei3nd43).\n\nThe latest state of the game is shown by default.\n\nAs players make moves, spectators receive and see real-time updates.\n\nSpectators see the \"Spectator chat\", which is different than the ones the players see.\n\nTab 2: Ranking\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe filters do not have an \"all\" option.\n\nVariant: default: standard\n\nTime control: default: rapid\n\nPlayer: text field. Default: empty. The player filter acts more like a search box. If filled and the player exists, it only shows the row corresponding to that player and a few rows before and after. If the player does not exist, it shows nothing.\n\nRank: number starting at 1\n\nPlayer: the display name. It updates whenever players change their names delete their accounts.\n\nRating: the ELO rating. These are numbers sorted in decreasing order.\n\nPeak rating: the max ELO rating that player has ever had.\n\nRecord: a string formatted like \"10-4\" indicating the number of points the player got and lost across all its games.\n\nFirst game: a date.\n\nLast game: a date.\n\nClicking anywhere on a row takes you to the \"Past games\" page with the variant, time control, and player filters set. The \"rated\" filter is also set to \"yes\".\n\nTab 5: Learn\n\nThis page contains only static content, in four sections:\n\nRules (standard)\n\nNotation (standard)\n\nLessons (standard)\n\nAll the sections may contain images.\n\nSections can be collapsed.\n\nThis contains a couple of paragraphs explaining the rules of the \"standard\" variant.\n\nIt ends with: \"You can now start the solo campaign.\", with a link to the play tab (wallgame.io).\n\nThis contains a couple of paragraphs explaining the standard notation. This is useful since it appears in the game history element of the \"board view\" component.\n\nThis contains a bullet point list of links to blog posts explaining strategic and tactical ideas. More lessons can be added over time.\n\nThis contains definitions and special rules for all the supported variants.\n\nTab 1: Play\n\nThis is the 'landing' page.\n\nIts main purpose is to easily access the 6 game modes:\n\nSolo campaign\n\nStudy board\n\nPlay with others\n\nInvite friend\n\nIt contains three sections:\n\nSingle-player fun\n\nPlay with others\n\nGame showcase\n\nThe first two contain various buttons to go to the various game modes. The final one is just decorative. It's not there because it's related to the \"Play\" theme, but because it's the landing page.\n\nSingle-player fun\n\nThis section contains the following buttons:\n\nSolo campaign. There is an annotation that says \"Start here!\"\n\nStudy board\n\nPlay with others\n\nThis section contains the following buttons:\n\nFind others\n\nInvite friend\n\nGame showcase\n\nThis section shows a board and autoplays random past games, at high speed (2 moves per second). Above the board, a text says: \"Game showcase: name1 (1200) vs name2 (1234) (DATE)\", with the players and date updating as the game changes. There should also be a button to stop the autoplay.\n\nClicking on it takes you to the \"game page\" to watch the game, analogous to the \"Past games\" page. The only difference is that the game starts at the position that last played automatically in the game showcase.\n\nGame mode 2: Puzzles\n\nThe URL is wallgame.io/puzzles\n\nThe puzzles page has a list of puzzles.\n\nEach puzzle has:\n\nplay button\n\ndifficulty rating\n\ncompleted: yes/no. An indication of whether the user already solved it\n\nIf the user is not logged in, the 'completed' status is grayed out. There should be an information box indicating that the user should log in to save their completion status.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/puzzles/1, where 1 is the puzzle number. This makes it so that the user can share a puzzle by sharing the route.\n\nGame mode 1: Solo campaign\n\nThe URL is wallgame.io/solo-campaign\n\nThe solo campaign menu consists of a list of puzzles just like the menu for puzzles.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/solo-campaign/1, where 1 is the puzzle number.\n\nUnlike in normal puzzles, in solo campaign puzzles:\n\nThere is a text above the board view indicating what to do to win.\n\nThe game is usually played until the end.\n\nGame mode 3: Play vs AI\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Easy Bot\".\n\nGame mode 5: Play with others\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Matched user\".\n\nGame mode 6: Invite friend\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Friend\".\n\nGame mode 4: Study board\n\nThis takes you to a special instance of the \"game page\" with route wallgame.io/study-board.\n\nThe design for the study board page is work in progress.\n\nFinal thoughts\n\nI usually figure out the shape of things as I build them, like I did for wallwars.net, instead of writing a long design doc upfront. However:\n\nTo justify a full rewrite, I wanted to make sure the new design would accomplish the improvements that I wanted to see on the original site (see the list at the beginning of this post).\n\nAI-assisted coding has made all coding easier, but it has improved new code generation more than it has improved refactoring. For me, this shifted the tradeoff to the point where it seemed worth it to try to preempt as many direction shifts as possible.\n\nIn any case, now that I have this doc, I think it's a good opportunity to test out the various frontend generators (lovable and company) and see what they spit out. I probably won't use any of them directly, but they should give me good ideas for the styling.\n\nI fed this whole blog post to v0.dev (free tier). The prompt was \"Create mocks for the attached design doc.\" + this blog post, which is about 6000 words (a 33kB attachment).\n\nApart from putting the files in the wrong directory, it one-shotted the whole app with great prompt adherence and, in my opinion, great taste to fill in the gaps (recall that this design doc says basically nothing about styling).\n\nYou can see the results below (I skipped the less interesting pages).\n\nI emphasize that I did not have to break down the prompt into smaller chunks, as I'm so used to with tools like Cursor or basically anything LLM-based. I did not have to go screen by screen. It generated about 20 files and 3000 lines of next.js, with all navigation working as expected and mock data. I did not have to carefully craft a prompt on top of the design doc (though you can argue that this blog post is a great prompt). As someone who uses vibe coding regularly, this truly impressed me.\n\nI tried other frontend generators with the same prompt. lovable.dev did OK with prompt adherence (some pages did not work), but it did not have the same taste as v0.dev. It looks like a generic corporate site. Lovable's board component also looks messed up.\n\nbolt.new had great prompt adherence, about the same as v0.dev, but the site looked generic like lovable's (and the board was also messed up). V0 had the best use of space.\n\nOther tools I tried had a prompt length limit, so I didn't bother.\n\nIn the end, I just went back to v0.dev and used the rest of my daily free credits to ask it for different color themes.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-ui?category=wallgame#concepts",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game UI Design (+ Frontend Generators)",
      "content": "Wall Game UI Design (+ Frontend Generators)\n\nThis blog post is a design doc for the frontend of wallgame.io, a board game I'm making. However, something probably more interesting came out of it: an assessment of frontend generators' ability to one-shot a 6000-word design doc prompt. The results deeply impressed me. They are in an appendix at the bottom. Feel free to skip the design doc and check out the appendix.\n\nThis is the specification of the frontend for the Wall Game, an online strategy board game. It only specifies the logic/functionality. It is agnostic of the look.\n\nA first version of the game is already available at wallwars.net. This is a UI overhaul with the following goals:\n\nA smooth onboarding experience. It should be very clear how to navigate the site and in what order to do things.\n\nTeaching the game to new players in a structured way.\n\nExpansive solo modes so that players can have fun even if there is no one else online.\n\nImproving the user journey of inviting friends to play.\n\nSupporting game variants as a first-class feature (this was a key feature for replayability when playing with a physical board).\n\nSupporting game variants with a varying number of players.\n\nSupporting multiple bots, including custom bots to foster the \"engine dev\" community.\n\nClean interface to game data, like past games, player history, rankings, etc., by showing interlinked tables with SQL-like features like filtering.\n\nMore \"social\" features, like an in-game chat and the ability to watch live games.\n\nFrontend Overview\n\nThe site is a SPA (single page app). There are 9 main pages, all of which are accessible from the top navigation bar. If a screen is not wide enough to show all the tabs, they are collapsed as necessary into a hamburger menu icon. Tabs act as buttons to show the corresponding page. Pages are self-contained and have their own URL:\n\nIn order, the tabs are:\n\nPlay (default) - wallgame.io\n\nRanking - wallgame.io/ranking\n\nPast games - wallgame.io/past-games\n\nLive games - wallgame.io/live-games\n\nLearn - wallgame.io/learn\n\nAbout - wallgame.io/about\n\nSettings - wallgame.io/settings\n\nProfile (appears as Login if the user is not logged in) - wallgame.io/profile\n\nThe navigation bar is always visible, and the current tab is highlighted.\n\nWe'll first go over the basic concepts, then some of the basic components reused across multiple pages, and finally, we'll go over each page (out of order).\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nPlayer types: there are 5 player types in the context of a game created by a user: \"You\": the user itself. \"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.) \"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\"). \"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game. \"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nPlayer types: there are 5 player types in the context of a game created by a user:\n\n\"You\": the user itself.\n\n\"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.)\n\n\"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\").\n\n\"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game.\n\n\"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter): The user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win). The user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully. The user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter):\n\nThe user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win).\n\nThe user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully.\n\nThe user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nThis section describes specific high-level components of the UI, which are reused in various places.\n\nThis is the main component involved in playing the game.\n\nA rectangular grid of square cells, with thick margins between them (that's where the walls go).\n\nA cell may contain one or more pawns. There is no limit on how many pawns can be in the same cell.\n\nA staged or premoved pawn move is shown with an arrow. Arbitrary arrows can also be added as calculations. It should be clear which one is which.\n\nBetween every two cells adjacent vertically or horizontally, there is a space where a wall can be placed, staged, premoved, calculated, or missing.\n\nThe corner between four cells is called a \"pillar\" and is not an interactable element.\n\nPlaced walls are colored according to the color of the pawns of the player who placed them.\n\nSimilar to chess and checkers, the cells are colored alternatively, so that cells that are an even number of moves away from each other share a color. The contrast between the two colors is subtle.\n\nLike chess, rows are labeled with numbers (starting from 1 on the top) and columns are labeled with letters (starting from 'a' on the left). The first cell in each row is labeled with the corresponding row number. The first cell in each column is labeled with the corresponding column letter. The labels are subtle, taking only a corner of the cell.\n\nThe last move is highlighted so it is easy for players to see what the opponent just did.\n\nThis includes the board itself and surrounding elements for any related information and interactions:\n\nthe timers. The timer of the player to move is highlighted.\n\nthe player names and ELOs. The name of the player to move is highlighted.\n\nthe move history in standard notation, with buttons to go back and forth and buttons to go to the beginning and latest move.\n\nthe chat. The chat can have multiple \"channels\": the \"game chat\", seen by all the players but not the audience the \"team chat\", seen only by players on the same team the \"audience chat\", seen only by the audience\n\nthe \"game chat\", seen by all the players but not the audience\n\nthe \"team chat\", seen only by players on the same team\n\nthe \"audience chat\", seen only by the audience\n\nan indicator of whose turn it is\n\nonline indicators for each player (if a player does not have the game tab/app active, it shows as offline)\n\nmenus for out-of-game interactions: \"resign\", \"offer draw\", \"propose take back\", \"give time (1 min)\", \"rematch\"\n\na button to toggle sounds\n\ncontextual information: the game variant and parameters the time control rated status the match score whose turn it is the player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\") after the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\nthe game variant and parameters\n\nthe time control\n\nrated status\n\nthe match score\n\nwhose turn it is\n\nthe player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\")\n\nafter the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\na button to see/copy the game's replay notation and standard notation\n\nGame configuration panel\n\nThis includes all the configuration options for a game.\n\ntime control: a selector with the options \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\".\n\nrated status: yes/no. If the player is not logged in, the 'rated status' is set to \"no\" and grayed out. There should be an informational text that says that the user needs to be logged in to play rated games.\n\nvariant: a selector of supported variants.\n\nadditional parameters that depend on the variant. These parameters appear in a container, and the container changes depending on the variant.\n\nFor example, for the standard variant:\n\nBoard width: number. Default: 8\n\nBoard height: number. Default: 8\n\nPlayer configuration\n\nA little component that lets you configure how a player in a game will move. It consists of a selector with a few options, each of which has an informational text.\n\n\"You\": \"You'll make the moves.\"\n\n\"Friend\": \"You'll get a link to share with a friend to join the game.\"\n\n\"Matched user\": \"You'll be paired with a random player with compatible settings and similar rating.\"\n\n\"Easy Bot\": \"You'll play against an easy AI bot.\"\n\n\"Medium Bot\": \"You'll play against a medium AI bot.\"\n\n\"Hard Bot\": \"You'll play against a hard AI bot.\"\n\n\"Custom bot\": \"You'll get an access token so that you can connect your own bot. See here for more information.\" The text links to a blog post explaining how to make a custom bot and connect it to the game using the token.\n\nThere is no default. It depends on the context.\n\nGame setup page\n\nThis page has its own URL: wallgame.io/game-setup.\n\nIt has two sections:\n\nCreate game\n\nCreate game\n\nThis part has the following elements:\n\nA button: \"Create game\".\n\nA player configuration component for each player (which depends on the variant, as set in #4). The selectors are labeled \"Player 1\", \"Player 2\", and so on. The default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe selectors are labeled \"Player 1\", \"Player 2\", and so on.\n\nThe default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe game configuration panel. Choosing a variant with more than 2 players will affect the number of player configuration components in #2.\n\nThis part has the following elements:\n\nA heading \"Join game\"\n\nA table showing games from other players that are in the \"matching stage\" and waiting for someone to join.\n\nThe table has the following columns:\n\nJoin: a button which, when clicked, joins the game.\n\nRated: yes/no.\n\nTime control: a string formatted like \"blitz (3+2)\"\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height).\n\nPlayer: a string formatted like \"name1 (1200)\". The numbers in parentheses is the rating. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (XXX) & name2 (YYY) vs name3 (ZZZ)\".\n\nThe rows are ordered by ELO closest to the current user's ELO. If the user chose a variant, rated status, time control, or board size in the game configuration panel, rows matching those settings are prioritized. Games that have been in \"matching stage\" for longer are also prioritized.\n\nThe parameterized URL is wallgame.io/game/game-id\n\nThe game page shows a game, identified with a given game ID in the URL. The game could be in the \"matching stage\", ongoing, or finished (a past game) The URL can be shared to join the game (if it is in the \"matching stage\"), to spectate it live (if it is ongoing) or watch it as a past game (if it is finished).\n\nThe game page has one main component: the board view.\n\nDepending on the context, it could contain other elements. See, e.g., the case of the \"Solo campaign\" puzzles, which contain an additional explanation text. So far, this seems to be the only exception.\n\nMatching stage panel\n\nWhen a user creates a game from wallgame.io/game-setup, a game ID is generated and they are taken to the game page with that game ID.\n\nHowever, it is possible that not all players are ready. For instance, if one of the player types is \"friend\", the game cannot start until the friend joins the game.\n\nIf not all players are ready, a \"matching stage\" panel component is shown as a modal over a faded out version of the game page.\n\nThe modal has a title: \"Waiting for players\". It contains one row for each player. Each row contains:\n\nThe player type (e.g., \"You\", \"Friend\", \"Easy Bot\", \"Medium Bot\", \"Hard Bot\", \"Custom Bot\", \"Matched player\")\n\nAn indication of whether the player is ready.\n\nInstructions for how that player should join the game If the player is \"You\", the player is automatically ready. If the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard. If the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready. If the player is \"Custom Bot\", the instructions include an access token for a custom bot. If the player is \"Matched player\", the instructions are to wait for someone to join.\n\nIf the player is \"You\", the player is automatically ready.\n\nIf the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard.\n\nIf the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready.\n\nIf the player is \"Custom Bot\", the instructions include an access token for a custom bot.\n\nIf the player is \"Matched player\", the instructions are to wait for someone to join.\n\nA button to abort the game and return to the previous page.\n\nIf a player joins a game but there are other players that are not ready (in the case of variants with more than 2 players), they will also see the matching stage panel.\n\nTab 7: Settings\n\nSettings have three sections:\n\nUser settings\n\nVisual style\n\nDefault game parameters\n\nFor sections 2 and 3, there should be an information box indicating that if the user is not logged in, they are saved as local cookies in the web browser. If they are logged in, the settings are saved to their account instead.\n\n1. User settings\n\nThis has one field:\n\nDisplay name (text field)\n\nIt behaves a bit differently depending on if the user is logged in.\n\nFor logged in users, the display name shows their current name and it is editable.\n\nThere should be a button next to the \"display name\" text field that says \"Change if available\" and an informational text that says \"Names must be unique across the site (case insensitive). You can only switch to another name not already in use.\" The button should be grayed out if the text field matches their current name. Names including \"guest\" or \"deleted\" or \"bot\" are not allowed. If the user tries to change to such a name, it should be explained to them.\n\nIf the user is not logged in, the display name should be grayed out and fixed as: \"Guest\"\n\nThere should also be an indication that the user needs to be logged in to change their display name, with a button to the Profile page.\n\n2. Visual style\n\nDark theme: on/off. Default: on\n\nBoard theme: selector. Default: \"classic\".\n\nPawn color: selector. Default: default.\n\nCat pawn: selector.\n\nMouse pawn: selector.\n\n... (one selector for each pawn type that appears in any variant)\n\nThe pawn selectors are between icons/small images.\n\n3. Default game parameters.\n\nThis is the game configuration panel component.\n\nA text says, \"When setting up a game, these parameters will be used as default.\"\n\nTab 6: About\n\nThis contains short informational text. The text can be something like this:\n\n\"Wall Game is a board game about building walls and outsmarting your opponents. It is inspired by Quoridor (wiki link) and Blockade (wiki link). Basic instructions about navigating the website (where to find the rules etc). Created by Nil Mamano (link). For more, you can read the blog (link).\"\n\nTab 8: Profile\n\nThis page looks different depending on whether the user is logged in or not.\n\nNot logged in\n\nThe tab appears as \"Login\".\n\nThe page shows two main buttons: log in and sign up\n\nIt includes a bit of text: \"Log in or sign up to choose a name, play rated games, and see your game history.\"\n\nFor the login and sign up flows, the user is redirected to an external auth service, so they are not part of this UI.\n\nThe tab appears as \"Profile\".\n\nIt shows the user display name and rating at the top, followed by a series of buttons grouped in two groups:\n\nPast Games: takes you to the Past Games tab but with the user's name already set as filter.\n\nRanking: takes you to the Ranking tab but with the user's name already set as filter.\n\nSettings: takes you to the settings page.\n\nDelete account\n\nThe delete account button shows a confirmation dialog: \"Your email will be deleted from the DB and all games you played will appear as 'Deleted User' and you won't be able to play again with this account. Are you sure?\"\n\nTab 3: Past games\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default. Filters are added as query parameters to the URL, so they can be shared.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nPlayer: text field (empty field acts as \"all\")\n\nPlayer: text field (empty field acts as \"all\").\n\nTime period: a date range\n\nThe two player fields serve the same purpose. Filling only one gives you all games with that player. Filling both gives you all games including both players.\n\nGames with fewer than 2 moves are filtered out. Games aborted during the \"matching stage\" are not even stored.\n\nThe rows are ordered by date. The order cannot be changed.\n\nWatch: a button which, when clicked, takes you to see the past game.\n\nVariant: clicking on a variant sets the variant filter.\n\nRated: yes/no. Clicking on a rating sets the rated status filter.\n\nTime control: a string formatted like \"blitz (3+2)\". Clicking on a time control sets the time control filter.\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height). Clicking on a board size sets the board size filter.\n\nPlayers: a string formatted like \"name1 (1200) vs name2 (1234)\". The numbers in parentheses are the ratings at the start of the game. Clicking on a name sets the first player filter. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (1200) & name2 (1234) vs name3 (1234) & name4 (1234)\". Clicking on the \"vs\" sets both player filters, with slight tweaks depending on the variant.\n\nMoves: a number. The number of moves of the game.\n\nViews: a number. The number of views the game got.\n\ndate: date type. When the game was played.\n\nThe name of the winning player is highlighted. Draws are also indicated.\n\nPast game view\n\nWhen a user clicks the \"Watch\" button for a past game, they are taken to the \"game page\" for that game (e.g., wallgame.io/game/2ei3nd43).\n\nThe final position is shown by default.\n\nThe chat is grayed out with a message that says \"Chat is not preserved.\"\n\nTab 4: Live games\n\nSimilar to the \"Past games\" page, this page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nThe formatting of the columns is the same as for \"Past Games\".\n\nWatch: a button that takes you to spectate the game in real time.\n\nViewers: a number.\n\nVariant: see \"Past games\" table.\n\nRated: see \"Past games\" table.\n\nTime control: see \"Past games\" table.\n\nBoard size: see \"Past games\" table.\n\nPlayers: see \"Past games\" table.\n\nMoves: see \"Past games\" table.\n\nThe rows are sorted by viewers first, by max ELO second.\n\nWhen a game ends, the number of spectators becomes the initial number of views in the past games table.\n\nLive game view\n\nWhen a user clicks the \"Watch\" button for a live game, they are taken to the \"game page\" for that game (e.g., wallgame.io/live/2ei3nd43).\n\nThe latest state of the game is shown by default.\n\nAs players make moves, spectators receive and see real-time updates.\n\nSpectators see the \"Spectator chat\", which is different than the ones the players see.\n\nTab 2: Ranking\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe filters do not have an \"all\" option.\n\nVariant: default: standard\n\nTime control: default: rapid\n\nPlayer: text field. Default: empty. The player filter acts more like a search box. If filled and the player exists, it only shows the row corresponding to that player and a few rows before and after. If the player does not exist, it shows nothing.\n\nRank: number starting at 1\n\nPlayer: the display name. It updates whenever players change their names delete their accounts.\n\nRating: the ELO rating. These are numbers sorted in decreasing order.\n\nPeak rating: the max ELO rating that player has ever had.\n\nRecord: a string formatted like \"10-4\" indicating the number of points the player got and lost across all its games.\n\nFirst game: a date.\n\nLast game: a date.\n\nClicking anywhere on a row takes you to the \"Past games\" page with the variant, time control, and player filters set. The \"rated\" filter is also set to \"yes\".\n\nTab 5: Learn\n\nThis page contains only static content, in four sections:\n\nRules (standard)\n\nNotation (standard)\n\nLessons (standard)\n\nAll the sections may contain images.\n\nSections can be collapsed.\n\nThis contains a couple of paragraphs explaining the rules of the \"standard\" variant.\n\nIt ends with: \"You can now start the solo campaign.\", with a link to the play tab (wallgame.io).\n\nThis contains a couple of paragraphs explaining the standard notation. This is useful since it appears in the game history element of the \"board view\" component.\n\nThis contains a bullet point list of links to blog posts explaining strategic and tactical ideas. More lessons can be added over time.\n\nThis contains definitions and special rules for all the supported variants.\n\nTab 1: Play\n\nThis is the 'landing' page.\n\nIts main purpose is to easily access the 6 game modes:\n\nSolo campaign\n\nStudy board\n\nPlay with others\n\nInvite friend\n\nIt contains three sections:\n\nSingle-player fun\n\nPlay with others\n\nGame showcase\n\nThe first two contain various buttons to go to the various game modes. The final one is just decorative. It's not there because it's related to the \"Play\" theme, but because it's the landing page.\n\nSingle-player fun\n\nThis section contains the following buttons:\n\nSolo campaign. There is an annotation that says \"Start here!\"\n\nStudy board\n\nPlay with others\n\nThis section contains the following buttons:\n\nFind others\n\nInvite friend\n\nGame showcase\n\nThis section shows a board and autoplays random past games, at high speed (2 moves per second). Above the board, a text says: \"Game showcase: name1 (1200) vs name2 (1234) (DATE)\", with the players and date updating as the game changes. There should also be a button to stop the autoplay.\n\nClicking on it takes you to the \"game page\" to watch the game, analogous to the \"Past games\" page. The only difference is that the game starts at the position that last played automatically in the game showcase.\n\nGame mode 2: Puzzles\n\nThe URL is wallgame.io/puzzles\n\nThe puzzles page has a list of puzzles.\n\nEach puzzle has:\n\nplay button\n\ndifficulty rating\n\ncompleted: yes/no. An indication of whether the user already solved it\n\nIf the user is not logged in, the 'completed' status is grayed out. There should be an information box indicating that the user should log in to save their completion status.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/puzzles/1, where 1 is the puzzle number. This makes it so that the user can share a puzzle by sharing the route.\n\nGame mode 1: Solo campaign\n\nThe URL is wallgame.io/solo-campaign\n\nThe solo campaign menu consists of a list of puzzles just like the menu for puzzles.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/solo-campaign/1, where 1 is the puzzle number.\n\nUnlike in normal puzzles, in solo campaign puzzles:\n\nThere is a text above the board view indicating what to do to win.\n\nThe game is usually played until the end.\n\nGame mode 3: Play vs AI\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Easy Bot\".\n\nGame mode 5: Play with others\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Matched user\".\n\nGame mode 6: Invite friend\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Friend\".\n\nGame mode 4: Study board\n\nThis takes you to a special instance of the \"game page\" with route wallgame.io/study-board.\n\nThe design for the study board page is work in progress.\n\nFinal thoughts\n\nI usually figure out the shape of things as I build them, like I did for wallwars.net, instead of writing a long design doc upfront. However:\n\nTo justify a full rewrite, I wanted to make sure the new design would accomplish the improvements that I wanted to see on the original site (see the list at the beginning of this post).\n\nAI-assisted coding has made all coding easier, but it has improved new code generation more than it has improved refactoring. For me, this shifted the tradeoff to the point where it seemed worth it to try to preempt as many direction shifts as possible.\n\nIn any case, now that I have this doc, I think it's a good opportunity to test out the various frontend generators (lovable and company) and see what they spit out. I probably won't use any of them directly, but they should give me good ideas for the styling.\n\nI fed this whole blog post to v0.dev (free tier). The prompt was \"Create mocks for the attached design doc.\" + this blog post, which is about 6000 words (a 33kB attachment).\n\nApart from putting the files in the wrong directory, it one-shotted the whole app with great prompt adherence and, in my opinion, great taste to fill in the gaps (recall that this design doc says basically nothing about styling).\n\nYou can see the results below (I skipped the less interesting pages).\n\nI emphasize that I did not have to break down the prompt into smaller chunks, as I'm so used to with tools like Cursor or basically anything LLM-based. I did not have to go screen by screen. It generated about 20 files and 3000 lines of next.js, with all navigation working as expected and mock data. I did not have to carefully craft a prompt on top of the design doc (though you can argue that this blog post is a great prompt). As someone who uses vibe coding regularly, this truly impressed me.\n\nI tried other frontend generators with the same prompt. lovable.dev did OK with prompt adherence (some pages did not work), but it did not have the same taste as v0.dev. It looks like a generic corporate site. Lovable's board component also looks messed up.\n\nbolt.new had great prompt adherence, about the same as v0.dev, but the site looked generic like lovable's (and the board was also messed up). V0 had the best use of space.\n\nOther tools I tried had a prompt length limit, so I didn't bother.\n\nIn the end, I just went back to v0.dev and used the rest of my daily free credits to ask it for different color themes.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-ui?category=wallgame#game-setup-page",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wall Game UI Design (+ Frontend Generators)",
      "content": "Wall Game UI Design (+ Frontend Generators)\n\nThis blog post is a design doc for the frontend of wallgame.io, a board game I'm making. However, something probably more interesting came out of it: an assessment of frontend generators' ability to one-shot a 6000-word design doc prompt. The results deeply impressed me. They are in an appendix at the bottom. Feel free to skip the design doc and check out the appendix.\n\nThis is the specification of the frontend for the Wall Game, an online strategy board game. It only specifies the logic/functionality. It is agnostic of the look.\n\nA first version of the game is already available at wallwars.net. This is a UI overhaul with the following goals:\n\nA smooth onboarding experience. It should be very clear how to navigate the site and in what order to do things.\n\nTeaching the game to new players in a structured way.\n\nExpansive solo modes so that players can have fun even if there is no one else online.\n\nImproving the user journey of inviting friends to play.\n\nSupporting game variants as a first-class feature (this was a key feature for replayability when playing with a physical board).\n\nSupporting game variants with a varying number of players.\n\nSupporting multiple bots, including custom bots to foster the \"engine dev\" community.\n\nClean interface to game data, like past games, player history, rankings, etc., by showing interlinked tables with SQL-like features like filtering.\n\nMore \"social\" features, like an in-game chat and the ability to watch live games.\n\nFrontend Overview\n\nThe site is a SPA (single page app). There are 9 main pages, all of which are accessible from the top navigation bar. If a screen is not wide enough to show all the tabs, they are collapsed as necessary into a hamburger menu icon. Tabs act as buttons to show the corresponding page. Pages are self-contained and have their own URL:\n\nIn order, the tabs are:\n\nPlay (default) - wallgame.io\n\nRanking - wallgame.io/ranking\n\nPast games - wallgame.io/past-games\n\nLive games - wallgame.io/live-games\n\nLearn - wallgame.io/learn\n\nAbout - wallgame.io/about\n\nSettings - wallgame.io/settings\n\nProfile (appears as Login if the user is not logged in) - wallgame.io/profile\n\nThe navigation bar is always visible, and the current tab is highlighted.\n\nWe'll first go over the basic concepts, then some of the basic components reused across multiple pages, and finally, we'll go over each page (out of order).\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nVariants: the game will have variants with slightly different rules. The only initial variants are \"Standard\" and \"Classic\", but the UI is designed to support new variants.\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nTime control: games are timed, like in chess. The time control specifies the amount of time each player has and the increment per turn. The time controls are \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\". The notation \"x+y\" indicates the starting time per side (x) and the increment per move (y). The default is \"Rapid (10+2)\". There is no way to customize the duration/increment within a category like \"Bullet\".\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nBoard dimensions: games are played on a board which is a rectangular grid. In most variants, players can choose the dimensions they want to play on. The minimum width is 2, and the maximum is 12. Same for the height. Board dimensions are grouped into \"Small\" (up to 36 squares), \"Medium\" (up to 81 squares) and \"Large\" (more than 81 squares). Default is 8x8.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nTurns and moves: a game consists of a series of turns. Each turn consists of a move by every player. The variant determines the number of players.\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPlayer order: Each turn, each player makes a move in a specific order established before the start of the game. Players can be identified by move order as \"first mover\", \"second mover\", ... (and maybe more depending on the variant). The player order is established at the end of the \"matching stage\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawns types: players move pieces called pawns. Pawns can have different types, depending on the variants. E.g., in the \"standard\" variant, a pawn can be a \"cat\" or a \"mouse\". In the \"classic\" variant, a pawn can be a \"cat\" or a \"goal\".\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nPawn aesthetics: Pawn looks can be customized by the user without affecting game logic. Players can choose between different shapes for each pawn type. There is a default shape for each type (i.e., select among a few options for \"cat\", a few options for \"mouse\", etc.). Players can also choose colors freely or leave the color as \"default\". The default color is special because it depends on the player order (e.g., first mover defaults to red, and second mover defaults to blue). If both players choose the same color, default colors will be used instead.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nWalls: walls block the movement of pawns across the board. A wall can be placed, usually by a player, horizontally or vertically between two cells. Wall colors indicate who placed them.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nBot: also known as engine or \"AI\". A program that can play the game. The game comes with 3 built-in bots: \"Easy\", \"Medium\", \"Hard\". Bots interface with the game like a human: they need to manage their time, etc.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nCustom bot: the site allows users to plug in their own bots to play games on the website. This requires the user to use a special client/API that acts as a bridge between their bot and the server.\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nELO: ELO is a number indicating the strength of a player, like in chess. Players have a separate ELO for each time control and variant. Games can be rated or not rated. Only rated games affect ELO. Only logged-in users can play rated games. The starting ELO is 1200. Non-logged in users are always considered to have a rating of 1200. Bots have a fixed ELO: 1200 for \"Easy\", 1500 for \"Medium\", and 1800 for \"Strong\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nGame parameters: each variant has its own set of parameters that affect the logic of the game, and which can be adjusted by players before starting. (Time control is not considered part of the game parameters since every variant has it.) A common parameter among most variants is the board dimensions. Another possible example would be the starting position of the pawns. Some parameters can also involve randomization (e.g., \"place X walls randomly\"). Randomized effects are applied when the game starts, at the end of the \"matching stage\".\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nMatching stage: after a player has fully configured all the necessary parameters for a game, and decided who will be each player (e.g., are they playing vs a bot, or waiting for a friend to join, or trying to match with a stranger online), the game enters the \"matching stage\" where it waits for all the players to be ready. E.g., the matching stage may be instantaneous when playing a bot, but it may take a while to find someone online to play. If any player leaves during the matching stage, the game is aborted. E.g., if the variant has 4 players, and 3 players are ready, but one of them navigates away from the page, the game is aborted.\n\nPlayer types: there are 5 player types in the context of a game created by a user: \"You\": the user itself. \"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.) \"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\"). \"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game. \"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nPlayer types: there are 5 player types in the context of a game created by a user:\n\n\"You\": the user itself.\n\n\"Friend\": an out-of-the-game friend of the user. When entering the matching stage, a link is generated for each \"friend\" to join the game. The user can send it to them. (Following the link directly joins the game. If the 'friend' wants to play with an account instead of being anonymous, they should first go to wallgame.io, create an account, and then click the link.)\n\n\"Bot\": one of the built-in bots (\"Easy\", \"Medium\", or \"Strong\").\n\n\"Custom bot\": the user's own bot. When entering the matching stage, an access token is created that the user needs to give to the client running their bot to join the game.\n\n\"Matched user\" (need a better name for this): When entering the matching stage, the game is added to the public lobby. From there, anyone can click on it to join the game. The game will also try to automatically match users in the matching stage. However, they must have compatible settings: time control, rated status (whether the game is rated or not), and game parameters. When waiting for a matched user, inside the matching stage, there is a box you can check to \"Match even if the game parameters are different as long as the time control, rated status, and variant are the same\". If there is no one available, the user stays in the matching stage until there is someone, or times out after 3 minutes (with an informational message). If there are multiple options, players with similar ratings will be paired.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nActions: Each move consists of a series of actions. For instance, the 'standard' variation has two actions per move. The most common actions are \"move\" and \"wall\". A \"move\" action consists of moving a pawn to an adjacent cell (not blocked by a wall). A \"wall\" action consists of placing a wall between two cells.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nAction staging: a \"move\" is not final until the user has indicated all the actions. That means that, e.g., if a move is two actions and a player chooses a \"wall\" action as their first action, that action is not final until they choose their second action. The first action is \"staged\". The user can change their mind and undo staged actions. Opponents don't see staged actions.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nPremoving: during the opponents turn, a player can make \"premoves\", actions that are automatically staged or submitted when it is the player's turn. You can only premove the number of actions in one move.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nCalculations: a player may want help visualizing moves by themselves or their opponents before they are actually played. They can simulate placing walls and draw arrows between cells (to simulate pawn moves) without actually moving/staging/premoving anything. Calculations are just a visual aid and not part of the game logic.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nMatch: a match is a series of consecutive games between the same players. To extend a match with another game, players just need to propose and accept a rematch. Matches have scores: for two player games, wins are 1 point and draws are 0.5 points for each.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPlayer names: Non-logged in users are all called \"Guest\". This means there is no way to distinguish non-logged in users, which acts as an incentive to create an account. Logged in users, get a random, unique username upon account creation. They can change it by going to settings. However, player names are unique across the whole game, meaning that they can only pick a name not already taken.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter): The user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win). The user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully. The user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nPuzzle: a game that starts from a specific position (not necessarily a realistic one), without time control, and where the user always moves first. The user is given a goal upfront: win or draw. When the user moves, the following can happen (the criterion to determine which one is determined by the puzzle setter):\n\nThe user has made a mistake. The user is notified and the move is undone automatically rolled back. The user is also allowed to \"play the game through\" after a mistake to understand why their move is wrong. In this case, a strong bot takes over, which should be able to convert the position into a win (if the user's goal was to draw) or a win or draw (if the user's goal was to win).\n\nThe user has gained a 'decisive advantage' (if the goal is to win) or 'secured a draw' (if the goal is to draw). The puzzle ends successfully.\n\nThe user has made a correct move but the puzzle is not over. The opponent makes a move, which can either be fixed by the puzzle setter or played by a strong bot (the Wall Game often has many equally good moves, so it is not possible to preprogram an answer to every possible user move). The puzzle goes on.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nReplay notation: a JSON string representing a game (finished or unfinished). It not only includes the list of moves, but the player information and every interaction needed to perfectly reproduce the game as it happened when played (e.g., the timing of the moves, rejected draw offers, etc). Each variant may require tweaks. For variants with parameters involving randomization, the random seed is included. The only thing that is not saved is the chat.\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nStandard notation: a string format representing a game (finished or unfinished). It contains a header with the variant and parameters and the player names, and a body with the sequence of moves. It is meant to be compact while human-readable. Each variant may require tweaks. The standard notation is based on cell names (e.g., \"e4\").\n\nThis section describes specific high-level components of the UI, which are reused in various places.\n\nThis is the main component involved in playing the game.\n\nA rectangular grid of square cells, with thick margins between them (that's where the walls go).\n\nA cell may contain one or more pawns. There is no limit on how many pawns can be in the same cell.\n\nA staged or premoved pawn move is shown with an arrow. Arbitrary arrows can also be added as calculations. It should be clear which one is which.\n\nBetween every two cells adjacent vertically or horizontally, there is a space where a wall can be placed, staged, premoved, calculated, or missing.\n\nThe corner between four cells is called a \"pillar\" and is not an interactable element.\n\nPlaced walls are colored according to the color of the pawns of the player who placed them.\n\nSimilar to chess and checkers, the cells are colored alternatively, so that cells that are an even number of moves away from each other share a color. The contrast between the two colors is subtle.\n\nLike chess, rows are labeled with numbers (starting from 1 on the top) and columns are labeled with letters (starting from 'a' on the left). The first cell in each row is labeled with the corresponding row number. The first cell in each column is labeled with the corresponding column letter. The labels are subtle, taking only a corner of the cell.\n\nThe last move is highlighted so it is easy for players to see what the opponent just did.\n\nThis includes the board itself and surrounding elements for any related information and interactions:\n\nthe timers. The timer of the player to move is highlighted.\n\nthe player names and ELOs. The name of the player to move is highlighted.\n\nthe move history in standard notation, with buttons to go back and forth and buttons to go to the beginning and latest move.\n\nthe chat. The chat can have multiple \"channels\": the \"game chat\", seen by all the players but not the audience the \"team chat\", seen only by players on the same team the \"audience chat\", seen only by the audience\n\nthe \"game chat\", seen by all the players but not the audience\n\nthe \"team chat\", seen only by players on the same team\n\nthe \"audience chat\", seen only by the audience\n\nan indicator of whose turn it is\n\nonline indicators for each player (if a player does not have the game tab/app active, it shows as offline)\n\nmenus for out-of-game interactions: \"resign\", \"offer draw\", \"propose take back\", \"give time (1 min)\", \"rematch\"\n\na button to toggle sounds\n\ncontextual information: the game variant and parameters the time control rated status the match score whose turn it is the player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\") after the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\nthe game variant and parameters\n\nthe time control\n\nrated status\n\nthe match score\n\nwhose turn it is\n\nthe player types (\"you\", \"friend\", \"easy/medium/hard bot\", \"custom bot\", \"matched player\")\n\nafter the game ends, the game outcome: which player won and the reason (timeout, resignation, knockout, agreement, tie, abandoned), or whether the game was a draw and the reason (e.g., agreement, tie)\n\na button to see/copy the game's replay notation and standard notation\n\nGame configuration panel\n\nThis includes all the configuration options for a game.\n\ntime control: a selector with the options \"Bullet (1+0)\", \"Blitz (3+2)\", \"Rapid (10+2)\", and \"Classical (30+0)\".\n\nrated status: yes/no. If the player is not logged in, the 'rated status' is set to \"no\" and grayed out. There should be an informational text that says that the user needs to be logged in to play rated games.\n\nvariant: a selector of supported variants.\n\nadditional parameters that depend on the variant. These parameters appear in a container, and the container changes depending on the variant.\n\nFor example, for the standard variant:\n\nBoard width: number. Default: 8\n\nBoard height: number. Default: 8\n\nPlayer configuration\n\nA little component that lets you configure how a player in a game will move. It consists of a selector with a few options, each of which has an informational text.\n\n\"You\": \"You'll make the moves.\"\n\n\"Friend\": \"You'll get a link to share with a friend to join the game.\"\n\n\"Matched user\": \"You'll be paired with a random player with compatible settings and similar rating.\"\n\n\"Easy Bot\": \"You'll play against an easy AI bot.\"\n\n\"Medium Bot\": \"You'll play against a medium AI bot.\"\n\n\"Hard Bot\": \"You'll play against a hard AI bot.\"\n\n\"Custom bot\": \"You'll get an access token so that you can connect your own bot. See here for more information.\" The text links to a blog post explaining how to make a custom bot and connect it to the game using the token.\n\nThere is no default. It depends on the context.\n\nGame setup page\n\nThis page has its own URL: wallgame.io/game-setup.\n\nIt has two sections:\n\nCreate game\n\nCreate game\n\nThis part has the following elements:\n\nA button: \"Create game\".\n\nA player configuration component for each player (which depends on the variant, as set in #4). The selectors are labeled \"Player 1\", \"Player 2\", and so on. The default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe selectors are labeled \"Player 1\", \"Player 2\", and so on.\n\nThe default option for \"Player 1\" is \"You\", and for the others it is \"Easy Bot\".\n\nThe game configuration panel. Choosing a variant with more than 2 players will affect the number of player configuration components in #2.\n\nThis part has the following elements:\n\nA heading \"Join game\"\n\nA table showing games from other players that are in the \"matching stage\" and waiting for someone to join.\n\nThe table has the following columns:\n\nJoin: a button which, when clicked, joins the game.\n\nRated: yes/no.\n\nTime control: a string formatted like \"blitz (3+2)\"\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height).\n\nPlayer: a string formatted like \"name1 (1200)\". The numbers in parentheses is the rating. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (XXX) & name2 (YYY) vs name3 (ZZZ)\".\n\nThe rows are ordered by ELO closest to the current user's ELO. If the user chose a variant, rated status, time control, or board size in the game configuration panel, rows matching those settings are prioritized. Games that have been in \"matching stage\" for longer are also prioritized.\n\nThe parameterized URL is wallgame.io/game/game-id\n\nThe game page shows a game, identified with a given game ID in the URL. The game could be in the \"matching stage\", ongoing, or finished (a past game) The URL can be shared to join the game (if it is in the \"matching stage\"), to spectate it live (if it is ongoing) or watch it as a past game (if it is finished).\n\nThe game page has one main component: the board view.\n\nDepending on the context, it could contain other elements. See, e.g., the case of the \"Solo campaign\" puzzles, which contain an additional explanation text. So far, this seems to be the only exception.\n\nMatching stage panel\n\nWhen a user creates a game from wallgame.io/game-setup, a game ID is generated and they are taken to the game page with that game ID.\n\nHowever, it is possible that not all players are ready. For instance, if one of the player types is \"friend\", the game cannot start until the friend joins the game.\n\nIf not all players are ready, a \"matching stage\" panel component is shown as a modal over a faded out version of the game page.\n\nThe modal has a title: \"Waiting for players\". It contains one row for each player. Each row contains:\n\nThe player type (e.g., \"You\", \"Friend\", \"Easy Bot\", \"Medium Bot\", \"Hard Bot\", \"Custom Bot\", \"Matched player\")\n\nAn indication of whether the player is ready.\n\nInstructions for how that player should join the game If the player is \"You\", the player is automatically ready. If the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard. If the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready. If the player is \"Custom Bot\", the instructions include an access token for a custom bot. If the player is \"Matched player\", the instructions are to wait for someone to join.\n\nIf the player is \"You\", the player is automatically ready.\n\nIf the player is \"Friend\", the instructions include a link to share with the friend and an easy way to copy it to the clipboard.\n\nIf the player is \"Easy Bot\", \"Medium Bot\", or \"Hard Bot\", the player is automatically ready.\n\nIf the player is \"Custom Bot\", the instructions include an access token for a custom bot.\n\nIf the player is \"Matched player\", the instructions are to wait for someone to join.\n\nA button to abort the game and return to the previous page.\n\nIf a player joins a game but there are other players that are not ready (in the case of variants with more than 2 players), they will also see the matching stage panel.\n\nTab 7: Settings\n\nSettings have three sections:\n\nUser settings\n\nVisual style\n\nDefault game parameters\n\nFor sections 2 and 3, there should be an information box indicating that if the user is not logged in, they are saved as local cookies in the web browser. If they are logged in, the settings are saved to their account instead.\n\n1. User settings\n\nThis has one field:\n\nDisplay name (text field)\n\nIt behaves a bit differently depending on if the user is logged in.\n\nFor logged in users, the display name shows their current name and it is editable.\n\nThere should be a button next to the \"display name\" text field that says \"Change if available\" and an informational text that says \"Names must be unique across the site (case insensitive). You can only switch to another name not already in use.\" The button should be grayed out if the text field matches their current name. Names including \"guest\" or \"deleted\" or \"bot\" are not allowed. If the user tries to change to such a name, it should be explained to them.\n\nIf the user is not logged in, the display name should be grayed out and fixed as: \"Guest\"\n\nThere should also be an indication that the user needs to be logged in to change their display name, with a button to the Profile page.\n\n2. Visual style\n\nDark theme: on/off. Default: on\n\nBoard theme: selector. Default: \"classic\".\n\nPawn color: selector. Default: default.\n\nCat pawn: selector.\n\nMouse pawn: selector.\n\n... (one selector for each pawn type that appears in any variant)\n\nThe pawn selectors are between icons/small images.\n\n3. Default game parameters.\n\nThis is the game configuration panel component.\n\nA text says, \"When setting up a game, these parameters will be used as default.\"\n\nTab 6: About\n\nThis contains short informational text. The text can be something like this:\n\n\"Wall Game is a board game about building walls and outsmarting your opponents. It is inspired by Quoridor (wiki link) and Blockade (wiki link). Basic instructions about navigating the website (where to find the rules etc). Created by Nil Mamano (link). For more, you can read the blog (link).\"\n\nTab 8: Profile\n\nThis page looks different depending on whether the user is logged in or not.\n\nNot logged in\n\nThe tab appears as \"Login\".\n\nThe page shows two main buttons: log in and sign up\n\nIt includes a bit of text: \"Log in or sign up to choose a name, play rated games, and see your game history.\"\n\nFor the login and sign up flows, the user is redirected to an external auth service, so they are not part of this UI.\n\nThe tab appears as \"Profile\".\n\nIt shows the user display name and rating at the top, followed by a series of buttons grouped in two groups:\n\nPast Games: takes you to the Past Games tab but with the user's name already set as filter.\n\nRanking: takes you to the Ranking tab but with the user's name already set as filter.\n\nSettings: takes you to the settings page.\n\nDelete account\n\nThe delete account button shows a confirmation dialog: \"Your email will be deleted from the DB and all games you played will appear as 'Deleted User' and you won't be able to play again with this account. Are you sure?\"\n\nTab 3: Past games\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default. Filters are added as query parameters to the URL, so they can be shared.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nPlayer: text field (empty field acts as \"all\")\n\nPlayer: text field (empty field acts as \"all\").\n\nTime period: a date range\n\nThe two player fields serve the same purpose. Filling only one gives you all games with that player. Filling both gives you all games including both players.\n\nGames with fewer than 2 moves are filtered out. Games aborted during the \"matching stage\" are not even stored.\n\nThe rows are ordered by date. The order cannot be changed.\n\nWatch: a button which, when clicked, takes you to see the past game.\n\nVariant: clicking on a variant sets the variant filter.\n\nRated: yes/no. Clicking on a rating sets the rated status filter.\n\nTime control: a string formatted like \"blitz (3+2)\". Clicking on a time control sets the time control filter.\n\nBoard size: a string formatted like \"medium (8x8)\" (width x height). Clicking on a board size sets the board size filter.\n\nPlayers: a string formatted like \"name1 (1200) vs name2 (1234)\". The numbers in parentheses are the ratings at the start of the game. Clicking on a name sets the first player filter. Depending on the variant, if the variant has more than two players, this string may look different. E.g., \"name1 (1200) & name2 (1234) vs name3 (1234) & name4 (1234)\". Clicking on the \"vs\" sets both player filters, with slight tweaks depending on the variant.\n\nMoves: a number. The number of moves of the game.\n\nViews: a number. The number of views the game got.\n\ndate: date type. When the game was played.\n\nThe name of the winning player is highlighted. Draws are also indicated.\n\nPast game view\n\nWhen a user clicks the \"Watch\" button for a past game, they are taken to the \"game page\" for that game (e.g., wallgame.io/game/2ei3nd43).\n\nThe final position is shown by default.\n\nThe chat is grayed out with a message that says \"Chat is not preserved.\"\n\nTab 4: Live games\n\nSimilar to the \"Past games\" page, this page consists of a set of filters and a table where rows are filtered by those filters.\n\nAll the filters have an \"all\" option which is the default.\n\nVariant: selector\n\nRated: yes/no\n\nTime control: selector\n\nBoard dimensions: selector with (small / medium / large / all). This field may be disabled (grayed out) depending on the variant.\n\nELO: a numerical range\n\nThe formatting of the columns is the same as for \"Past Games\".\n\nWatch: a button that takes you to spectate the game in real time.\n\nViewers: a number.\n\nVariant: see \"Past games\" table.\n\nRated: see \"Past games\" table.\n\nTime control: see \"Past games\" table.\n\nBoard size: see \"Past games\" table.\n\nPlayers: see \"Past games\" table.\n\nMoves: see \"Past games\" table.\n\nThe rows are sorted by viewers first, by max ELO second.\n\nWhen a game ends, the number of spectators becomes the initial number of views in the past games table.\n\nLive game view\n\nWhen a user clicks the \"Watch\" button for a live game, they are taken to the \"game page\" for that game (e.g., wallgame.io/live/2ei3nd43).\n\nThe latest state of the game is shown by default.\n\nAs players make moves, spectators receive and see real-time updates.\n\nSpectators see the \"Spectator chat\", which is different than the ones the players see.\n\nTab 2: Ranking\n\nThis page consists of a set of filters and a table where rows are filtered by those filters.\n\nThe filters do not have an \"all\" option.\n\nVariant: default: standard\n\nTime control: default: rapid\n\nPlayer: text field. Default: empty. The player filter acts more like a search box. If filled and the player exists, it only shows the row corresponding to that player and a few rows before and after. If the player does not exist, it shows nothing.\n\nRank: number starting at 1\n\nPlayer: the display name. It updates whenever players change their names delete their accounts.\n\nRating: the ELO rating. These are numbers sorted in decreasing order.\n\nPeak rating: the max ELO rating that player has ever had.\n\nRecord: a string formatted like \"10-4\" indicating the number of points the player got and lost across all its games.\n\nFirst game: a date.\n\nLast game: a date.\n\nClicking anywhere on a row takes you to the \"Past games\" page with the variant, time control, and player filters set. The \"rated\" filter is also set to \"yes\".\n\nTab 5: Learn\n\nThis page contains only static content, in four sections:\n\nRules (standard)\n\nNotation (standard)\n\nLessons (standard)\n\nAll the sections may contain images.\n\nSections can be collapsed.\n\nThis contains a couple of paragraphs explaining the rules of the \"standard\" variant.\n\nIt ends with: \"You can now start the solo campaign.\", with a link to the play tab (wallgame.io).\n\nThis contains a couple of paragraphs explaining the standard notation. This is useful since it appears in the game history element of the \"board view\" component.\n\nThis contains a bullet point list of links to blog posts explaining strategic and tactical ideas. More lessons can be added over time.\n\nThis contains definitions and special rules for all the supported variants.\n\nTab 1: Play\n\nThis is the 'landing' page.\n\nIts main purpose is to easily access the 6 game modes:\n\nSolo campaign\n\nStudy board\n\nPlay with others\n\nInvite friend\n\nIt contains three sections:\n\nSingle-player fun\n\nPlay with others\n\nGame showcase\n\nThe first two contain various buttons to go to the various game modes. The final one is just decorative. It's not there because it's related to the \"Play\" theme, but because it's the landing page.\n\nSingle-player fun\n\nThis section contains the following buttons:\n\nSolo campaign. There is an annotation that says \"Start here!\"\n\nStudy board\n\nPlay with others\n\nThis section contains the following buttons:\n\nFind others\n\nInvite friend\n\nGame showcase\n\nThis section shows a board and autoplays random past games, at high speed (2 moves per second). Above the board, a text says: \"Game showcase: name1 (1200) vs name2 (1234) (DATE)\", with the players and date updating as the game changes. There should also be a button to stop the autoplay.\n\nClicking on it takes you to the \"game page\" to watch the game, analogous to the \"Past games\" page. The only difference is that the game starts at the position that last played automatically in the game showcase.\n\nGame mode 2: Puzzles\n\nThe URL is wallgame.io/puzzles\n\nThe puzzles page has a list of puzzles.\n\nEach puzzle has:\n\nplay button\n\ndifficulty rating\n\ncompleted: yes/no. An indication of whether the user already solved it\n\nIf the user is not logged in, the 'completed' status is grayed out. There should be an information box indicating that the user should log in to save their completion status.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/puzzles/1, where 1 is the puzzle number. This makes it so that the user can share a puzzle by sharing the route.\n\nGame mode 1: Solo campaign\n\nThe URL is wallgame.io/solo-campaign\n\nThe solo campaign menu consists of a list of puzzles just like the menu for puzzles.\n\nWhen the user clicks on a puzzle, they are taken to the \"game page\" initialized with the starting position of the puzzle. The route is wallgame.io/solo-campaign/1, where 1 is the puzzle number.\n\nUnlike in normal puzzles, in solo campaign puzzles:\n\nThere is a text above the board view indicating what to do to win.\n\nThe game is usually played until the end.\n\nGame mode 3: Play vs AI\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Easy Bot\".\n\nGame mode 5: Play with others\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Matched user\".\n\nGame mode 6: Invite friend\n\nThis is just the \"game setup page\" with the first player defaulting to \"You\" and the others to \"Friend\".\n\nGame mode 4: Study board\n\nThis takes you to a special instance of the \"game page\" with route wallgame.io/study-board.\n\nThe design for the study board page is work in progress.\n\nFinal thoughts\n\nI usually figure out the shape of things as I build them, like I did for wallwars.net, instead of writing a long design doc upfront. However:\n\nTo justify a full rewrite, I wanted to make sure the new design would accomplish the improvements that I wanted to see on the original site (see the list at the beginning of this post).\n\nAI-assisted coding has made all coding easier, but it has improved new code generation more than it has improved refactoring. For me, this shifted the tradeoff to the point where it seemed worth it to try to preempt as many direction shifts as possible.\n\nIn any case, now that I have this doc, I think it's a good opportunity to test out the various frontend generators (lovable and company) and see what they spit out. I probably won't use any of them directly, but they should give me good ideas for the styling.\n\nI fed this whole blog post to v0.dev (free tier). The prompt was \"Create mocks for the attached design doc.\" + this blog post, which is about 6000 words (a 33kB attachment).\n\nApart from putting the files in the wrong directory, it one-shotted the whole app with great prompt adherence and, in my opinion, great taste to fill in the gaps (recall that this design doc says basically nothing about styling).\n\nYou can see the results below (I skipped the less interesting pages).\n\nI emphasize that I did not have to break down the prompt into smaller chunks, as I'm so used to with tools like Cursor or basically anything LLM-based. I did not have to go screen by screen. It generated about 20 files and 3000 lines of next.js, with all navigation working as expected and mock data. I did not have to carefully craft a prompt on top of the design doc (though you can argue that this blog post is a great prompt). As someone who uses vibe coding regularly, this truly impressed me.\n\nI tried other frontend generators with the same prompt. lovable.dev did OK with prompt adherence (some pages did not work), but it did not have the same taste as v0.dev. It looks like a generic corporate site. Lovable's board component also looks messed up.\n\nbolt.new had great prompt adherence, about the same as v0.dev, but the site looked generic like lovable's (and the board was also messed up). V0 had the best use of space.\n\nOther tools I tried had a prompt length limit, so I didn't bother.\n\nIn the end, I just went back to v0.dev and used the rest of my daily free credits to ask it for different color themes.\n\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/wall-game-ui?category=wallgame#components",
      "author": "",
      "user_id": ""
    }
  ]
}